# WARNING - Generated by {fusen} from dev/flat_dev.Rmd: do not edit by hand

#' @title Prepare Analysis plan
#' @param xlsformpath path to the (extended) xlsform file used to collect the data
#' 
#' @importFrom dplyr mutate filter rename first recode if_else matches distinct row_number arrange left_join bind_rows summarise group_by case_when select
#' @importFrom purrr accumulate2 map_chr
#' @importFrom readxl read_excel
#' @importFrom stringr str_c
#' @importFrom tidyr separate
#' @importFrom tidyselect starts_with matches
#' @importFrom utils tail head
#' 
#' @return A "kobodico" S3 class object (list) formatted to the specifications of "kobocruncher".
#' @export
#' @examples
#' dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
#' # Survey
#' questions <- as.data.frame(dico[["variables"]])
#' knitr::kable(utils::head(questions, 10))
#' # Choices
#' responses <- as.data.frame(dico[["modalities"]])
#' knitr::kable(utils::head(responses, 10))
#' # Settings
#' metadata <- as.data.frame(dico[["settings"]])
#' knitr::kable(utils::head(metadata, 10))
#' # Report ToC
#' toc <- as.data.frame(dico[["plan"]])
#' knitr::kable(utils::head(toc, 10))
#' # Indicator
#' indicator <- as.data.frame(dico[["indicator"]])
#' knitr::kable(utils::head(indicator, 10))


# prefixer::import_from(fun = kobo_dico)

kobo_dico <- function(xlsformpath) {
   survey <- readxl::read_excel(xlsformpath,   
                                sheet = "survey")
  
   ## variables  ----------------------------------->
  variables <-  survey |>
    ## Rename and use what ever label set is coming first 
    dplyr::rename(label = dplyr::first(tidyselect::starts_with("label")),
                  hint = dplyr::first(tidyselect::starts_with("hint"))) |>
    
    
    # Clean the begin and end in case the _ would be missing...
    dplyr::mutate(type = dplyr::recode(type, 
                                        "begin group" = "begin_group" ,
                                        "end group"   ="end_group",
                                       "begin repeat" = "begin_repeat" ,
                                       "end repeat"   ="end_repeat")) |>
    
    ## separate the type
    tidyr::separate(type, 
                        into = c("type", "list_name"), 
                        sep = " ",
                        fill = "right")   |>
    
    ## Need to add more cleaning in case...
    #dplyr::filter(!(is.na(name))) |>
    #dplyr::filter(!(is.na(label))) |>
    dplyr::filter(!(is.na(type))) |>
    
   # capturing repeat, group and rebuilding full name
    dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                                  function (repeatvar, type, name) {
                                                    if (type  == "begin_repeat")  c(repeatvar, name)
                                                    else if (type  == "end_repeat") utils::head(repeatvar, -1)
                                                    else repeatvar
                                                  }, .init = character()) |> utils::tail(-1) ,  
                  ##Apply a function to each element of a list 
                  repeatvar = purrr::map_chr(repeatvar,
                                             stringr::str_c, 
                                             collapse = ".") ,
                  
                  ## Build the scope
                  scope = purrr::accumulate2(type, name,
                                             function (scope, 
                                                       type, 
                                                       name ) {
                                               
                    ## Rebuild variable name based potential combination of sequence   
                    if (type == "begin_group")  c(scope, name )
                    else if (type == "begin_repeat")  c(scope, name )
                    else if (type  == "end_group") utils::head(scope, -1)
                    else if (type  == "end_repeat") utils::head(scope, -1)
                    else scope
                         }, .init = character()) |> 
                      utils::tail(-1) ,
                  ##Apply a function to each element of a list 
                  scope = purrr::map_chr(scope,
                                         stringr::str_c,
                                         collapse = ".") ,
                  name =  dplyr::if_else(scope == "", name, paste0(scope,".",name)  ) ,
                  repeatvar = dplyr::if_else(repeatvar == "", "main", repeatvar  )) 
  
  
  ## Fix when we have calculate variable - either numeric or select_one
  
  
  
    if ("chapter" %in% colnames(variables)) { } else {  variables$chapter <- NA  }
    if ("subchapter" %in% colnames( variables)) { } else {  variables$subchapter <- NA   }
    if ("disaggregation" %in% colnames(variables)) { } else {  variables$disaggregation <- NA  }
    if ("correlate" %in% colnames( variables)) { } else {  variables$correlate <- NA   }  
  
  # Adding the appearance variable that will be used for likert charts
  # to check and check and remove label appearance 
    if ("appearance" %in% colnames(variables)) {   } else {   variables$appearance <- ""  }
  

     choices <- readxl::read_excel(xlsformpath,   sheet = "choices")  
    if ("order" %in% colnames( choices)) { } else {  choices$order <- NA   }
     modalities <- choices |>
                   dplyr::rename(label = dplyr::first(dplyr::matches("^label")))
     
     settings <- readxl::read_excel(xlsformpath,   
                                sheet = "settings")
     
     ### Building the plan ######
     ## Build the question order for the crunching report
     if (  nrow(as.data.frame(variables)|> dplyr::filter(! is.na(chapter)))  > 1 ) {
       
       
      ## Reinsert chapter and subchapter as begin_group
       subchapterorder <- as.data.frame(variables) |>
          dplyr::distinct(chapter, subchapter) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::mutate( subchapternum = dplyr::row_number())
        
        plansub  <- as.data.frame(variables) |>
            dplyr::filter(! is.na(chapter) ) |>
           dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
           dplyr::group_by( chapter, subchapter) |>
           dplyr::summarise( type = "begin_group",
                      name =  "labelsub.chapter" ) |>
           dplyr::mutate( label = subchapter) |>
           dplyr::bind_rows(as.data.frame(variables) |>
                              dplyr::filter(! is.na(chapter) ) |>
                              dplyr::filter( ! type  %in% c("begin_group", "end_group") ) ) |>
           dplyr::left_join(subchapterorder, by = c("chapter", "subchapter")) |>
           #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
           dplyr::arrange(subchapternum)  |>
          dplyr::mutate( labelsub.chapter = paste0("labelsub.chapter" , subchapternum ) ) |>
          dplyr::mutate(  name= dplyr::case_when(
              name == "labelsub.chapter" ~ labelsub.chapter ,
              TRUE ~ name) )
        
        chapterorder <- as.data.frame(variables) |>
          dplyr::distinct(chapter) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::mutate( chapternum = dplyr::row_number())
        
        plan  <- as.data.frame(variables) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
          dplyr::group_by( chapter) |>
          dplyr::summarise( type = "begin_group",
                            name = "labelchapter" ) |>
           dplyr::mutate( label = chapter) |>
          dplyr::bind_rows(plansub ) |>
          dplyr::left_join(chapterorder, by = c("chapter" )) |>
          #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
          dplyr::arrange(chapternum) |>
          dplyr::mutate( labelchapter = paste0("labelchapter" , chapternum ) ) |>
          dplyr::mutate(  name= dplyr::case_when(
              name == "labelchapter" ~ labelchapter ,
              TRUE ~ name) ) |>
          dplyr::select( type, label,name) |>
          ## Remove all componnnents without label in case subchapter are not defined
          dplyr::filter( ! (is.na(label)))
        
        } else { 
        plan <- as.data.frame(variables) |>
          dplyr::select(type, label,name)|>
          dplyr::filter( ! type  %in% c("note",  "end_group") )
       }
       
     ## adding indicators  ----------------------------------->
    indicator <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath,   
                                sheet = "indicator"),stringsAsFactors = FALSE)
        }, error = function(err) {
          data.frame(
            type = character(),
            name = character(),
            label = character(),
            list_name = character(),
            hint = character(),
            repeatvar = character(),
            calculation = character(),
            chapter = character(),
            subchapter = character(),
            disaggregation = character(),
            correlate = character(),
            cluster = character(),
            predict = character(),
            score = character(),
            mappoint = character(),
            mappoly = character(),
            stringsAsFactors = FALSE
          )
         }
        )
        if ("type" %in% colnames(indicator)) {   } else {    indicator$type <- ""   }
        if ("name" %in% colnames(indicator)) {   } else {    indicator$name <- ""   }
        if ("label" %in% colnames(indicator)) {   } else {    indicator$label <- ""   }
        if ("list_name" %in% colnames(indicator)) {   } else {    indicator$list_name <- ""   }
        if ("hint" %in% colnames(indicator)) {   } else {    indicator$hint <- ""   }
        if ("repeatvar" %in% colnames(indicator)) { } else { indicator$repeatvar <- ""   }
        if ("calculation" %in% colnames(indicator)) { } else { indicator$calculation <- ""   }
        if ("chapter" %in% colnames(indicator)) { } else { indicator$chapter <- ""   }
        if ("subchapter" %in% colnames(indicator)) { } else { indicator$subchapter <- ""   }
        if ("correlate" %in% colnames(indicator)) {    } else {  indicator$correlate <- ""}
        if ("disaggregation" %in% colnames(indicator)) { } else { indicator$disaggregation <- ""  }
        if ("cluster" %in% colnames(indicator)) { } else { indicator$cluster <- ""}
        if ("predict" %in% colnames(indicator)) {     } else { indicator$predict <- ""  }
        if ("score" %in% colnames(indicator)) {     } else { indicator$score <- ""  }
        if ("mappoint" %in% colnames(indicator)) {    } else { indicator$mappoint <- ""}
        if ("mappoly" %in% colnames(indicator)) {    } else { indicator$mappoly <- ""}
    
        indicator <- indicator[ ,c("type","name","label", "list_name", "hint",
                                   "repeatvar", "calculation",
                                   "chapter","subchapter", "disaggregation", "correlate",
                                    "cluster", "predict", "score", "mappoint", "mappoly")]
     
     
     
    dico <- list( variables = variables, 
                  modalities = modalities,
                  settings = settings,
                  plan = plan,
                  indicator = indicator)
    class(dico) <- "kobodico" # assigns a "kobodico" class to the list. Helpful for later on. 
    ## Build dico object as list with both variables and modalities
    
     
    #cat("\n******************** Summary of the Analysis Plan *********************\n \n")
    ## get a summary of what we have to inform user
    ## Check Variable lenght
    # if( length(survey$label) )
    ## Do we have chapters? If yes how many?
    ## Do we have anonymisation instructions? If yes, is it correctly set? How many direct identifiers, key variables, sensitive variables
    ## Do we have cleaning instructions? Are they set up for the select_ variable
    ## Do we have disaggregation instructions (yes)? -- Should Are they set up for the select_one variable
    ## Do we have correlate instructions  (yes)? Are they set up for the select_one variable       
    ## Do we have cluster instructions  (yes)? Are they set up for the select_one variable 
    ## Do we have predict instructions  (one unique target, at least 2 predictor)? Are they set up for the select_one variable 
    ## Do we have mappoint, mappoly (yes)? Are they set up for the select_one variable 
    
    
    
    return(dico )
}

