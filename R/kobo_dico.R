# WARNING - Generated by {fusen} from /dev/flat_dev.Rmd: do not edit by hand

#' @title Prepare Analysis plan
#' @param xlsformpath path to the (extended) xlsform file used to collect the data
#' 
#' @return A "kobodico" S3 class object (list) formatted to the specifications of "kobocruncher".
#' @export

#' @examples
#' dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
#' # Survey
#' questions <- as.data.frame(dico[1])
#' knitr::kable(utils::head(questions, 10))
#' # Choices
#' responses <- as.data.frame(dico[2])
#' knitr::kable(utils::head(responses, 10))
#' # Settings
#' metadata <- as.data.frame(dico[3])
#' knitr::kable(utils::head(metadata, 10))
#' # Report ToC
#' toc <- as.data.frame(dico[4])
#' knitr::kable(utils::head(toc, 10))
#' # Indicator
#' indicator <- as.data.frame(dico[5])
#' knitr::kable(utils::head(indicator, 10))
kobo_dico <- function(xlsformpath) {
   survey <- readxl::read_excel(xlsformpath,   
                                sheet = "survey")
  
   ## variables ###############
  variables <-  survey |>
    ## Rename and use what ever label set is coming first 
    dplyr::rename(label = dplyr::first(tidyselect::starts_with("label")),
                  hint = dplyr::first(tidyselect::starts_with("hint"))) |>
    
    
    # Clean the begin and end in case the _ would be missing...
    dplyr::mutate(type = dplyr::recode(type, 
                                        "begin group" = "begin_group" ,
                                        "end group"   ="end_group",
                                       "begin repeat" = "begin_repeat" ,
                                       "end repeat"   ="end_repeat")) |>
    
    ## spearate the type
    tidyr::separate(type, 
                        into = c("type", "list_name"), 
                        sep = " ",
                        fill = "right")   |>
    
    ## Need to add more cleaning in case...
    #dplyr::filter(!(is.na(name))) |>
    #dplyr::filter(!(is.na(label))) |>
    dplyr::filter(!(is.na(type))) |>
    
    # capturing repeat
    dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                                  function (repeatvar, type, name) {
                                                    if (type  == "begin_repeat")  c(repeatvar, name)
                                                    else if (type  == "end_repeat") utils::head(repeatvar, -1)
                                                    else repeatvar
                                                  }, .init = character()) |> utils::tail(-1),
                  ##Apply a function to each element of a list 
                  repeatvar = purrr::map_chr(repeatvar,
                                             stringr::str_c, 
                                             collapse = ".") ,
                  name = dplyr::case_when(repeatvar == "" ~ name,
                                          type == "begin_repeat"~ repeatvar,
                                          TRUE ~ stringr::str_c(repeatvar, name, sep = "."))) |>
                 
    
      # capturing Group
      dplyr::mutate(scope = purrr::accumulate2(type, name,
                                               function (scope, 
                                                         type, 
                                                         name) {
                                                 if (type == "begin_group") 
                                                    c(scope, name)
                                                    else if (type == "end_group") utils::head(scope, -1)
                                                 else scope
                                               }, .init = character()) |> utils::tail(-1),
                    ##Apply a function to each element of a list 
                    scope = purrr::map_chr(scope, 
                                           stringr::str_c, 
                                           collapse = "."),         
                    
                    name = dplyr::case_when(scope == "" ~ name,
                                            type == "begin_group" ~ scope,
                                            TRUE ~ stringr::str_c(scope, name, sep = "."))) 
  
  
  ## Fix when we have calculate variable - either numeric or select_one
  
  ## Add dataframe number
  ## Counter..
  variables$dataframenew <- 0
  for (i in 2:nrow(variables)){
    #i <- 10
    #cat( variables[i, c("repeatvar")] )
    if (variables[i, c("repeatvar")] != variables[i-1, c("repeatvar")] &
        variables[i, c("repeatvar")] !="" ) {
      variables[i, c("dataframenew")] <- 1
    } else{
      variables[i, c("dataframenew")] <- 0
    }
  }
   ## Counter..
  variables$dataframecount <- 1
  for (i in 2:nrow(variables)){  
    if (variables[i, c("repeatvar")] != "") {
      variables[i, c("dataframecount")] <- variables[i-1, c("dataframecount")] + variables[i, c("dataframenew")]
    } else{
      variables[i, c("dataframecount")] <- variables[i-1, c("dataframecount")]
    }
    
  }
   ## Framenumber
  variables$dataframe <- 1
  for (i in 2:nrow(variables)){  
    if (variables[i, c("repeatvar")] != "") {
          variables[i, c("dataframe")] <- variables[i, c("dataframecount")] 
        } else{
          variables[i, c("dataframe")] <- 1
        }
   }
  variables$dataframecount <- NULL
  variables$dataframenew <- NULL
  
    if ("chapter" %in% colnames(variables)) { } else {  variables$chapter <- NA  }
    if ("subchapter" %in% colnames( variables)) { } else {  variables$subchapter <- NA   }
    if ("disaggregation" %in% colnames(variables)) { } else {  variables$disaggregation <- NA  }
    if ("correlate" %in% colnames( variables)) { } else {  variables$correlate <- NA   }  
  
  # Adding the appearance variable that will be used for likert charts
  # to check and check and remove label appearance 
    if ("appearance" %in% colnames(variables)) {   } else {   variables$appearance <- ""  }
  

     choices <- readxl::read_excel(xlsformpath,   sheet = "choices")  
    if ("order" %in% colnames( choices)) { } else {  choices$order <- NA   }
     modalities <- choices |>
                   dplyr::rename(label = dplyr::first(matches("^label")))
     
     settings <- readxl::read_excel(xlsformpath,   
                                sheet = "settings")
     
     ### Building the plan ######
     ## Build the question order for the crunching report
     if (  nrow(as.data.frame(variables)|> dplyr::filter(! is.na(chapter)))  > 1 ) {
       
       
      ## Reinsert chapter and subchapter as begin_group
       subchapterorder <- as.data.frame(variables) |>
          dplyr::distinct(chapter, subchapter) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::mutate( subchapternum = dplyr::row_number())
        
        plansub  <- as.data.frame(variables) |>
            dplyr::filter(! is.na(chapter) ) |>
           dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
           dplyr::group_by( chapter, subchapter) |>
           dplyr::summarise( type = "begin_group",
                      name =  "labelsub.chapter" ) |>
           dplyr::mutate( label = subchapter) |>
           dplyr::bind_rows(as.data.frame(variables) |>
                              dplyr::filter(! is.na(chapter) ) |>
                              dplyr::filter( ! type  %in% c("begin_group", "end_group") ) ) |>
           dplyr::left_join(subchapterorder, by = c("chapter", "subchapter")) |>
           #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
           dplyr::arrange(subchapternum)  |>
          dplyr::mutate( labelsub.chapter = paste0("labelsub.chapter" , subchapternum ) ) |>
          dplyr::mutate(  name= dplyr::case_when(
              name == "labelsub.chapter" ~ labelsub.chapter ,
              TRUE ~ name) )
        
        chapterorder <- as.data.frame(variables) |>
          dplyr::distinct(chapter) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::mutate( chapternum = dplyr::row_number())
        
        plan  <- as.data.frame(variables) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
          dplyr::group_by( chapter) |>
          dplyr::summarise( type = "begin_group",
                            name = "labelchapter" ) |>
           dplyr::mutate( label = chapter) |>
          dplyr::bind_rows(plansub ) |>
          dplyr::left_join(chapterorder, by = c("chapter" )) |>
          #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
          dplyr::arrange(chapternum) |>
          dplyr::mutate( labelchapter = paste0("labelchapter" , chapternum ) ) |>
          dplyr::mutate(  name= dplyr::case_when(
              name == "labelchapter" ~ labelchapter ,
              TRUE ~ name) ) |>
          dplyr::select( type, label,name)
        
        } else { 
        plan <- as.data.frame(variables) |>
          dplyr::select(type, label,name)|>
          dplyr::filter( ! type  %in% c("note",  "end_group") )
       }
       
     ## adding indicators 
    indicator <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath,   
                                sheet = "indicator"),stringsAsFactors = FALSE)
        }, error = function(err) {
          data.frame(
            type = character(),
            name = character(),
            label = character(),
            hint = character(),
            dataframe = character(),
            calculation = character(),
            chapter = character(),
            subchapter = character(),
            disaggregation = character(),
            correlate = character(),
            cluster = character(),
            predict = character(),
            score = character(),
            mappoint = character(),
            mappoly = character(),
            stringsAsFactors = FALSE
          )
         }
        )
        if ("type" %in% colnames(indicator)) {   } else {    indicator$type <- ""   }
        if ("name" %in% colnames(indicator)) {   } else {    indicator$name <- ""   }
        if ("label" %in% colnames(indicator)) {   } else {    indicator$label <- ""   }
        if ("hint" %in% colnames(indicator)) {   } else {    indicator$hint <- ""   }
        if ("dataframe" %in% colnames(indicator)) { } else { indicator$dataframe <- ""   }
        if ("calculation" %in% colnames(indicator)) { } else { indicator$calculation <- ""   }
        if ("chapter" %in% colnames(indicator)) { } else { indicator$chapter <- ""   }
        if ("subchapter" %in% colnames(indicator)) { } else { indicator$subchapter <- ""   }
        if ("correlate" %in% colnames(indicator)) {    } else {  indicator$correlate <- ""}
        if ("disaggregation" %in% colnames(indicator)) { } else { indicator$disaggregation <- ""  }
        if ("cluster" %in% colnames(indicator)) { } else { indicator$cluster <- ""}
        if ("predict" %in% colnames(indicator)) {     } else { indicator$predict <- ""  }
        if ("score" %in% colnames(indicator)) {     } else { indicator$score <- ""  }
        if ("mappoint" %in% colnames(indicator)) {    } else { indicator$mappoint <- ""}
        if ("mappoly" %in% colnames(indicator)) {    } else { indicator$mappoly <- ""}
    
        indicator <- indicator[ ,c("type","name","label", "hint",
                                   "dataframe", "calculation",
                                   "chapter","subchapter", "disaggregation", "correlate",
                                    "cluster", "predict", "score", "mappoint", "mappoly")]
     
     
     
    dico <- list( variables, 
                  modalities,
                  settings,
                  plan,
                  indicator)
    class(dico) <- "kobodico" # assigns a "kobodico" class to the list. Helpful for later on. 
    ## Build dico object as list with both variables and modalities
    return(dico )
}

