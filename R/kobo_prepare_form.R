# WARNING - Generated by {fusen} from /dev/flat_dev.Rmd: do not edit by hand


#' @title Prepare XLSform and review Analysis
#' 
#' @description  Prepare XLSform by adding instructions for the analysis plan and checking that structure and settings are correct.
#' This function open the xlsform - extend if required including the excel formatting, 
#' display the analysis plan summary and resave the file at the end. 
#' 
#'  Once those elements are set up, they will be automatically considered during the automatic crunching phase.
#'  An additional worksheet is also created to document the information required for registration on UNHCR CKAN instance http://ridl.unhcr.org
#'  
#'  1. Configuration of how questions are grouped together in the report:
#'     - chapter: by default the crunching report is presented according to the group. Once set, this will replace the original grouping. Only variable defined within a chapter will be displayed in the crunching report. By dafault chapter will follow the questions sequence - if chapters start with a number that number will overrule the sequence
#'     - subchapter: provides a second level of details below the chapter if subchapters start with a number that number will overrule the sequence
#' 
#'  2. Configuration for data manipulation:
#'     - clean: define what variable shall be re-categorized during cleaning - a local copy of all levels will be locally saved in order to do the mapping in excel. When the mapping is available, it will be automatically applied to the data. Can be useful to reduce the number of categories.
#'     - anonymise: define what variables to consider to statistical disclosure risk measurement and subsequent data treatment
#'  
#'  3. Configuration of specific charts, visualization and analysis: 
#'  
#'     - disaggregation: define variable to use for visual cross tabulation - functions with "_cross"
#'     - correlate: define the variable to use to explore statistical association - works under certain restrictions (i.e. between 2 categorical variables only): kobo_correlate
#'     - cluster: define variable to generate an unsupervised classification (i.e. hierarchical clustering based on multiple correspondance analysis) kobo_cluster
#'     - predict: define variable to use to generate predictive model, ie.e the target variable and the predictors.  kobo_predict
#'     - score: define the different dimensions of a score - and used the score set up for the choice test different aggregation approaches
#'     - mappoint, mappoly: define the variable to use to generate maps - kobo_map
#'  
#' In case if those fields do not yet exist, the function will create dummy column for each one.
#' Also, coloring all rows that have type equal to "begin group", "end group", "begin repeat" or "end repeat" for better legibility
#'
#' @param xlsformpath The full path and filename of the xlsform to be accessed (has to be xlsx file)
#' @param xlsformpathout The full path and filename of the xlsform to be accessed (has to be xlsx file)
#' @param label_language Optional if the form used multiple languages, indicate the language to use to prepare the analysis plan - check first in your original file -default is  ::english (en)
#' @param ridl If available, it will prefill the RIDL info through what was already recorded there
#'
#' @export 
#' @examples
#' # kobo_prepare_form(xlsformpath = system.file("form.xlsx", package = "kobocruncher"),
#' #                   xlsformpathout = "form_with_plan.xlsx",
#' #                   label_language = "")
kobo_prepare_form <- function(xlsformpath,
                              xlsformpathout,
                              label_language = "",
                              ridl = "") {
  
  # Excel Styling Elements
  # To add filters for sheet, we have to set the range for addAutoFilter() function
  # EX: addAutoFilter(sheet1, "A1:P1") --> add a filter on the 1rd row, columns A:P
  # dfref dataframe allows to find 'P' based on number of columns in the sheet, if number of columns equal to 6 then the range will be A1:dfref[6,] -- A1:F1
  dfref <- data.frame(
    key = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256),
    val = c('A1', 'B1', 'C1', 'D1', 'E1', 'F1', 'G1', 'H1', 'I1', 'J1', 'K1', 'L1', 'M1', 'N1', 'O1', 'P1', 'Q1', 'R1', 'S1', 'T1', 'U1', 'V1', 'W1', 'X1', 'Y1', 'Z1', 'AA1', 'AB1', 'AC1', 'AD1', 'AE1', 'AF1', 'AG1', 'AH1', 'AI1', 'AJ1', 'AK1', 'AL1', 'AM1', 'AN1', 'AO1', 'AP1', 'AQ1', 'AR1', 'AS1', 'AT1', 'AU1', 'AV1', 'AW1', 'AX1', 'AY1', 'AZ1', 'BA1', 'BB1', 'BC1', 'BD1', 'BE1', 'BF1', 'BG1', 'BH1', 'BI1', 'BJ1', 'BK1', 'BL1', 'BM1', 'BN1', 'BO1', 'BP1', 'BQ1', 'BR1', 'BS1', 'BT1', 'BU1', 'BV1', 'BW1', 'BX1', 'BY1', 'BZ1', 'CA1', 'CB1', 'CC1', 'CD1', 'CE1', 'CF1', 'CG1', 'CH1', 'CI1', 'CJ1', 'CK1', 'CL1', 'CM1', 'CN1', 'CO1', 'CP1', 'CQ1', 'CR1', 'CS1', 'CT1', 'CU1', 'CV1', 'CW1', 'CX1', 'CY1', 'CZ1', 'DA1', 'DB1', 'DC1', 'DD1', 'DE1', 'DF1', 'DG1', 'DH1', 'DI1', 'DJ1', 'DK1', 'DL1', 'DM1', 'DN1', 'DO1', 'DP1', 'DQ1', 'DR1', 'DS1', 'DT1', 'DU1', 'DV1', 'DW1', 'DX1', 'DY1', 'DZ1', 'EA1', 'EB1', 'EC1', 'ED1', 'EE1', 'EF1', 'EG1', 'EH1', 'EI1', 'EJ1', 'EK1', 'EL1', 'EM1', 'EN1', 'EO1', 'EP1', 'EQ1', 'ER1', 'ES1', 'ET1', 'EU1', 'EV1', 'EW1', 'EX1', 'EY1', 'EZ1', 'FA1', 'FB1', 'FC1', 'FD1', 'FE1', 'FF1', 'FG1', 'FH1', 'FI1', 'FJ1', 'FK1', 'FL1', 'FM1', 'FN1', 'FO1', 'FP1', 'FQ1', 'FR1', 'FS1', 'FT1', 'FU1', 'FV1', 'FW1', 'FX1', 'FY1', 'FZ1', 'GA1', 'GB1', 'GC1', 'GD1', 'GE1', 'GF1', 'GG1', 'GH1', 'GI1', 'GJ1', 'GK1', 'GL1', 'GM1', 'GN1', 'GO1', 'GP1', 'GQ1', 'GR1', 'GS1', 'GT1', 'GU1', 'GV1', 'GW1', 'GX1', 'GY1', 'GZ1', 'HA1', 'HB1', 'HC1', 'HD1', 'HE1', 'HF1', 'HG1', 'HH1', 'HI1', 'HJ1', 'HK1', 'HL1', 'HM1', 'HN1', 'HO1', 'HP1', 'HQ1', 'HR1', 'HS1', 'HT1', 'HU1', 'HV1', 'HW1', 'HX1', 'HY1', 'HZ1', 'IA1', 'IB1', 'IC1', 'ID1', 'IE1', 'IF1', 'IG1', 'IH1', 'II1', 'IJ1', 'IK1', 'IL1', 'IM1', 'IN1', 'IO1', 'IP1', 'IQ1', 'IR1', 'IS1', 'IT1', 'IU1', 'IV1')
  )
  
  #For better legibility create specific styles for rows that defines header
  headerSt <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fontSize = 13, fgFill = "grey50",
                                     border = "TopBottom", borderColour = "grey80", borderStyle = "thin")
  #For better legibility create specific styles for rows that defines groups 
  cs1 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "black", fgFill = "orange",
                                border = "TopBottom", borderColour = "orange", borderStyle = "thin")
  #For better legibility create specific styles for rows that defines repeat 
  cs2 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fgFill = "skyblue",
                                border = "TopBottom", borderColour = "skyblue", borderStyle = "thin")    
  
  
  tryCatch({
    
    ## Create a blank workbook
    wb <- openxlsx::createWorkbook()
    
        
    ### Settings sheet ----------------------------------->
    settings <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "settings"),
                    stringsAsFactors = FALSE)
    }, error = function(err) {
      data.frame(
        form_title  = c("study"),
        form_id  = c("koboID"),
        default_language  = c("::spanish (es)"),
        #form_title = character(),
        #form_id = character(),
        #default_language = character(),
        stringsAsFactors = FALSE
      )
    }) 
        
    settings <- readxl::read_excel(xlsformpath,  sheet = "settings")
    #form_instance <- as.character(settings$form_title)
  
    ## Check if a default language is set up in the settings - and add the correct separator
    # for test settings$default_language <- NULL
    label_language <- ifelse( is.null(label_language),
                              ifelse( is.null(settings$default_language),
                                      label_language,
                                      paste0("::",settings$default_language)),
                              paste0("::",label_language))
    if (settings$form_title =="" | is.na(settings$form_title)) { } else {settings$form_title <- "Study"}
   

    
    
    ### Survey sheet  ----------------------------------->
    survey <- tryCatch({
      suppressMessages(
        as.data.frame(readxl::read_excel(xlsformpath, sheet = "survey"),
                      stringsAsFactors = FALSE) #read survey sheet from the form
      ) ## avid all the new names message...
      
    }, error = function(err) {
      data.frame( #if it doesn't exist, we need to create empty dataframe with those fields
        type = character(),
        name = character(),
        label = character(),
        labelQ = character(),
        hint = character(),
        hintQ = character(),
        relevant = character(),
        required = character(),
        constraint = character(),
        appareance = character(),
        repeat_count = character(),
        calculation = character(),
        choice_filter = character(),
        read_only = character(),
        default = character(),
        ## Additional variable for analysis plan
        clean = character(),
        anonymise = character(),
        chapter = character(),
        disaggregation = character(),
        correlate = character(),
        cluster = character(),
        predict = character(),
        mappoint = character(),
        mappoly = character(),
        stringsAsFactors = FALSE,
        check.names = F
      )
    })
    

    
    
    ## Remove all na column in case...
    survey <- survey |>
      dplyr::select(where(function(x) any(!is.na(x))))
    
    ## Clean the label and hint in relation with the selected language
    names(survey)[tolower(names(survey)) == tolower(paste0("label",label_language) )] <- "label"
    names(survey)[tolower(names(survey)) == tolower(paste0("hint",label_language) )] <- "hint"

    
    ## Adding variable if not present and checking the content of the variable to build up the analysis plan summary... 
    if ("hint" %in% colnames(survey)) {   } else {    survey$hint <- ""   }
    if ("appareance" %in% colnames(survey)) {   } else {    survey$appareance <- ""   }
    if ("chapter" %in% colnames(survey)) { } else { survey$chapter <- ""   }
    if ("subchapter" %in% colnames(survey)) { } else { survey$subchapter <- ""   }
    if ("correlate" %in% colnames(survey)) {    } else {  survey$correlate <- ""}
    if ("disaggregation" %in% colnames(survey)) { } else { survey$disaggregation <- ""  }
    if ("clean" %in% colnames(survey)) {     } else {  survey$clean <- "" }
    if ("anonymise" %in% colnames(survey)) {     } else {survey$anonymise <- ""}
    if ("cluster" %in% colnames(survey)) { } else { survey$cluster <- ""}
    if ("predict" %in% colnames(survey)) {     } else { survey$predict <- ""  }
    if ("score" %in% colnames(survey)) {     } else { survey$score <- ""  }
    if ("mappoint" %in% colnames(survey)) {    } else { survey$mappoint <- ""}
    if ("mappoly" %in% colnames(survey)) {    } else { survey$mappoly <- ""}
    survey$label.lenght <- nchar(survey$label)
    ## add the full name that will be used by functions
    survey$fullname <- survey |> 
      # capturing repeat
      dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                  function (repeatvar, type, name) {
                                    if (type  == "begin_repeat")  c(repeatvar, name)
                                   else if (type  == "end_repeat") utils::head(repeatvar, -1)
                                   else repeatvar
                                            }, .init = character()) |> utils::tail(-1),
                    ##Apply a function to each element of a list 
                    repeatvar = purrr::map_chr(repeatvar,
                                  stringr::str_c, 
                                             collapse = ".") ,
                    name = dplyr::case_when(repeatvar == "" ~ name,
                                  type == "begin_repeat"~ repeatvar,
                                  TRUE ~ stringr::str_c(repeatvar, name, sep = "."))) |>
      
      # capturing Group
      dplyr::mutate(scope = purrr::accumulate2(type, name,
                                             function (scope, 
                                                       type, 
                                                       name) {
                                           if (type == "begin_group") 
                                                   c(scope, name)
                                                 else if (type == "end_group") utils::head(scope, -1)
                                                 else scope
                                               }, .init = character()) |> utils::tail(-1),
                    ##Apply a function to each element of a list 
                    scope = purrr::map_chr(scope, 
                                           stringr::str_c, 
                                           collapse = "."),         
                    
                    name = dplyr::case_when(scope == "" ~ name,
                                            type == "begin_group" ~ scope,
                                            TRUE ~ stringr::str_c(scope, name, sep = "."))) |>
                    dplyr::pull(name)
    if ("labelQ" %in% colnames(survey)) {    } else {  survey$labelQ <- survey$label }
    if ("hintQ" %in% colnames(survey)) {    } else { survey$hintQ <- survey$hint}
    
    ### order in user friendly    way
    namesOfSur <- c( "type", "name", "label", "hint", 
                     "chapter", "subchapter",
                     "anonymise",  "clean"     ,
                     "disaggregation", "correlate",
                     "cluster"  , "predict" ,"score" ,
                     "mappoint",  "mappoly",
                     "label.lenght", "fullname",
                     "labelQ", "hintQ",
                     "required", "relevant",
                     "constraint", "calculation","appareance" )
    namesOfSur <- as.data.frame(namesOfSur) |>
      dplyr::filter(namesOfSur %in% colnames(survey)) |>
      dplyr::pull() 
    survey <- survey[ ,namesOfSur]
    ## need to delete empty rows from the form
    survey <- as.data.frame(survey[!is.na(survey$type), ])
    survey[is.na(survey)] <-  ""
    sheetname <- "survey"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, survey, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(survey), widths = "auto")
    openxlsx::setColWidths(wb, sheetname, cols = 2:3, widths = 30)
    all.cols <- 1:ncol(survey)
    hdr.rows <- 1
    group.rows <- which(stringr::str_detect(survey$type, "group"))+1
    repeat.rows <- which(stringr::str_detect(survey$type, "repeat"))+1
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, all.cols, gridExpand = TRUE)
    openxlsx::addStyle(wb, sheetname, cs1, group.rows, all.cols, gridExpand = TRUE)
    openxlsx::addStyle(wb, sheetname, cs2, repeat.rows, all.cols, gridExpand = TRUE)
    
    ### Choices sheet ----------------------------------->
    choices <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "choices"),
                    stringsAsFactors = FALSE) #read survey sheet from the form
    }, error = function(err) {
      data.frame( #if it doesn't exist, we need to create empty dataframe with those fields
        list_name = character(),
        name = character(),
        label = character(),
        labelQ = character(),
        order = character(),
        stringsAsFactors = FALSE,
        check.names = F
      )
    }) 
    ## Rename the variable label
    
    ## Rename the variable label based on language
    names(choices)[tolower(names(choices)) == tolower(paste0("label",label_language) )] <- "label"
    
    namesOfCho <- c("list_name", "name", "label")
    if (sum(namesOfCho %in% colnames(choices)) != length(namesOfCho)) {
      return(structure('Please make sure the choices sheet has at minima the following columns:
                        "list_name", "name" , "label"', class = "try-error"))
    }
    
    choices$label.lenght <- nchar(choices$label)
    choices$labelQ <- choices$label   
    ### add column if not present
    if ("order" %in% colnames(choices)) { } else { choices$order <- ""}
    if ("score" %in% colnames(choices)) {  } else { choices$score <- ""}
    namesOfCho <- c("list_name", "name", "label",  "order", "score","label.lenght","labelQ") 
    namesOfCho <- as.data.frame(namesOfCho) |>
      dplyr::filter(namesOfCho %in% colnames(choices)) |>
      dplyr::pull() 
    choices <- choices[ ,namesOfCho]
    sheetname <- "choices"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, choices, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(choices), widths = "auto")
    openxlsx::setColWidths(wb, sheetname, cols = 2:3, widths = 30)
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(choices), gridExpand = TRUE)
    
     ### settings sheets ----------------------------------->
    sheetname <- "settings"
    all.cols <- 1:ncol(settings)
    hdr.rows <- 1
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, settings, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(settings), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(settings), gridExpand = TRUE)
    
    ### RIDL sheets ----------------------------------->
    ridl_schema <- jsonlite::fromJSON("https://raw.githubusercontent.com/okfn/ckanext-unhcr/master/ckanext/unhcr/schemas/dataset.json")
    ridl_dataset_fields <- ridl_schema$dataset_fields # |> tibble::as_tibble()
    ridl_resource_fields <- ridl_schema$resource_fields # |> tibble::as_tibble()
    ridl_choices <-
      ridl_dataset_fields |>
      dplyr::mutate(choices = purrr::map(choices, as.data.frame)) |>
      dplyr::select(field_name, choices) |>
      tidyr::unnest(choices) |>
      dplyr::select(list_name = field_name, name = value, label) |>
      as.data.frame()
    ridl_metadata <-
      ridl_dataset_fields |>
      dplyr::transmute(
        type =
          dplyr::case_when(
            preset == "multiple_select" ~ stringr::str_c("select_multiple", field_name, sep = " "),
            field_name %in% ridl_choices$list_name ~ stringr::str_c("select_one", field_name, sep = " "),
            TRUE ~ "text"),
        name = field_name,
        label,
        required,
        hint = dplyr::if_else(!is.na(help_text), help_text, form_placeholder),
        value = "")
    
    sheetname <- "ridl-metadata"
    if (sheetname %in% readxl::excel_sheets(xlsformpath)) {
      ridl_metadata <-
        ridl_metadata |>
        dplyr::select(-value) |>
        dplyr::left_join(readxl::read_excel(xlsformpath, sheet = sheetname) |> dplyr::select(name, value), by = "name")
    }
    
    sheetname <- "ridl-metadata"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, ridl_metadata, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(ridl_metadata), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(ridl_metadata), gridExpand = TRUE)
    sheetname <- "ridl-choices"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, ridl_choices, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(ridl_choices), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(ridl_choices), gridExpand = TRUE)
    
    
    
    ###  indicator sheet  ----------------------------------->
    indicator <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "indicator"),stringsAsFactors = FALSE)
    }, error = function(err) {
      data.frame(
        type = character(),
        name = character(),
        label = character(),
        hint = character(),
        dataframe = character(),
        calculation = character(),
        chapter = character(),
        subchapter = character(),
        disaggregation = character(),
        correlate = character(),
        cluster = character(),
        predict = character(),
        score = character(),
        mappoint = character(),
        mappoly = character(),
        stringsAsFactors = FALSE
      )
     }
    )
        if ("type" %in% colnames(indicator)) {   } else {    indicator$type <- ""   }
        if ("name" %in% colnames(indicator)) {   } else {    indicator$name <- ""   }
        if ("label" %in% colnames(indicator)) {   } else {    indicator$label <- ""   }
        if ("hint" %in% colnames(indicator)) {   } else {    indicator$hint <- ""   }
        if ("dataframe" %in% colnames(indicator)) { } else { indicator$dataframe <- ""   }
        if ("calculation" %in% colnames(indicator)) { } else { indicator$calculation <- ""   }
        if ("chapter" %in% colnames(indicator)) { } else { indicator$chapter <- ""   }
        if ("subchapter" %in% colnames(indicator)) { } else { indicator$subchapter <- ""   }
        if ("correlate" %in% colnames(indicator)) {    } else {  indicator$correlate <- ""}
        if ("disaggregation" %in% colnames(indicator)) { } else { indicator$disaggregation <- ""  }
        if ("cluster" %in% colnames(indicator)) { } else { indicator$cluster <- ""}
        if ("predict" %in% colnames(indicator)) {     } else { indicator$predict <- ""  }
        if ("score" %in% colnames(indicator)) {     } else { indicator$score <- ""  }
        if ("mappoint" %in% colnames(indicator)) {    } else { indicator$mappoint <- ""}
        if ("mappoly" %in% colnames(indicator)) {    } else { indicator$mappoly <- ""}

    indicator <- indicator[ ,c("type","name","label", "hint",
                               "dataframe", "calculation",
                               "chapter","subchapter", "disaggregation", "correlate",
                                "cluster", "predict", "score", "mappoint", "mappoly")]
    sheetname <- "indicator"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, indicator, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(indicator), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(indicator), gridExpand = TRUE)

    
    
    cat("\n******************** Summary of the Analysis Plan *********************\n \n")
    ### Saving final ######################################    
    if (file.exists(xlsformpathout)) file.remove(xlsformpathout)
    openxlsx::saveWorkbook(wb, xlsformpathout)
    
    
    
    
    
    
    
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
    ## get a summary of what we have
    ## Check Variable lenght
    # if( length(survey$label) )
    ## Do we have chapters? If yes how many?
    ## Do we have anonymisation instructions? If yes, is it correctly set? How many direct identifiers, key variables, sensitive variables
    ## Do we have cleaning instructions? Are they set up for the select_ variable
    ## Do we have disaggregation instructions (yes)? -- Should Are they set up for the select_one variable
    ## Do we have correlate instructions  (yes)? Are they set up for the select_one variable       
    ## Do we have cluster instructions  (yes)? Are they set up for the select_one variable 
    ## Do we have predict instructions  (one unique target, at least 2 predictor)? Are they set up for the select_one variable 
    ## Do we have mappoint, mappoly (yes)? Are they set up for the select_one variable 
    
    
    
  }, error = function(err) {
    print("There was an error in the xlsform preparation step!!! \n\n")
    return(structure(err, class = "try-error"))
  })
  
}

