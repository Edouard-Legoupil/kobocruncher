# WARNING - Generated by {fusen} from /dev/flat_dev.Rmd: do not edit by hand

#' @title Plotting Select one variable with cross tabulation on a second categorical variable
#' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param by_var variable to use for cross tabulation
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @param showcode display the code
#' @export

#' @examples
#' dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
#' datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )
#' 
#' plot_select_one_cross(datalist = datalist,
#'               dico = dico, 
#'               var = "profile.country",
#'               by_var = "profile.occupation",
#'               showcode = TRUE
#'               )
#' ## test if variable are not in the same frame...
#' plot_select_one_cross(datalist = datalist,
#'               dico = dico, 
#'               var = "profile.country",
#'               by_var = "members.sex",
#'               showcode = TRUE
#'               )
#' 
plot_select_one_cross <- function(datalist = datalist,
                            dico = dico,
                            var, 
                            by_var , 
                            datasource = NULL,
                            showcode = FALSE) {
  
  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[3][[1]]$form_title ) }
  
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  
  data2 <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = by_var   )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  rr2 <- mean(!is.na(data2[[by_var]]))
  ## Writing report
  # cat("\n")
 # cat(paste("####", label_varname(var)))
  #cat(paste("#### Variable: ", var))
  
  if ( is.nan(rr) | is.nan(rr2) ) {
    cat(paste0("<strong style=\"color:#0072BC;\">The variable from the form called: ",var," or ", by_var, " could not be identified in the dataset</strong>\n\n"))
  } else if (  ! (identical(data,data2))  ) {
    # nothing to do - the variable are not in the same frame
    } else {
  
  ## Put a condition in case there's no record
  if (rr != 0 & ! (is.nan(rr)) ) { 
    if(by_var != "") {
      if( by_var != var ) {
        
          ## Writing code instruction in report
          if( showcode == TRUE) { 
            cat(paste0( label_varname(dico = dico,
                                                   x = var), "\n",
                                      fontawesome::fa("far fa-copy", fill ="grey"),"  `plot_select_one_cross(datalist = datalist, dico = dico, \"", var, "\",\"", by_var, "\")` \n\n "))}     else {}

      cnts1 <- data |>
        ## keep only the variable we need
        tidyr::drop_na(tidyselect::all_of(c(var,by_var))) 
      
      ## Need to check that there's actually a proper intersection in the response... 
      if(nrow(cnts1) == 0) {
        
         cat(paste0("<strong style=\"color:#0072BC;\">There is not intersection between the answers from the variables from the form called: ",var," or ", by_var, " in the dataset</strong>\n\n"))
      } else {
      
      cnts <- cnts1 |>  
        # Lump together factor levels into "other"
        dplyr::count(x := forcats::fct_lump_n(factor(.data[[var]]), n = 5),
                     y := forcats::fct_lump_n(factor(.data[[by_var]]), n = 5) ) |>
        dplyr::mutate(p = n/sum(n)) |>
        dplyr::group_by(y) |>
        dplyr::mutate(cumsum = max(cumsum(as.numeric(n))),
                      pcum = n / cumsum)  
       
       ## plot
       require(ggplot2)
       p <- ggplot2::ggplot(cnts, 
                  aes(x= pcum, 
                      y = x)) +
        geom_col(fill = "#0072BC") +
        #geom_label(aes(label = scales::label_percent(accuracy = .01)(pcum)), size = 2) +
        ## Position label differently in the bar in white - outside bar in black
        geom_label( data =   function(x) subset(x, pcum < max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = -0.1 ,
                    vjust = 0.5, 
                    colour = "black", 
                    fill = NA, 
                    label.size = NA,
                    size = 5   ) +  
        geom_label( data =   function(x) subset(x, pcum >= max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = 1.1 ,
                    vjust = 0.5, 
                    colour = "white", 
                    fill = NA, 
                    label.size = NA, 
                    size = 5   ) +   
        scale_x_continuous(labels = scales::label_percent()) +
        facet_wrap( ~ y ,  nrow = 3  ,
                      labeller = as_labeller(function(x) label_choiceset(dico = dico,
                                                                      x = by_var)(x))
          ) +
          scale_y_discrete(labels = function(x) {label_choiceset(dico = dico,
                                                            x = var)(x) |>
              stringr::str_wrap(40)}) +
        coord_cartesian(clip = "off") +
        labs(x = NULL, y = NULL,
             title = stringr::str_wrap(label_varname(dico = dico, x = var), 90),
             subtitle = stringr::str_wrap( paste0("Crossed by ", label_varname(dico = dico, x = by_var)), 90),
             caption = glue::glue("Single choice question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
        theme_minimal( base_size = 24) +  
        geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
        theme( panel.grid.major.x  = element_line(color = "#cbcbcb"), 
                 panel.grid.major.y  = element_blank(), 
                 panel.grid.minor = element_blank()    ) +
        theme(plot.title.position = "plot")

       return(p) #  print(p)
      }
      }
    } else { }
  } else { cat(paste0("<strong style=\"color:#0072BC;\"> No recorded answers for the question: </strong>",var,"\n\n")) }
  # cat("\n\n")
  }
}


