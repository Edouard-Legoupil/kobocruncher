---
title: "Developing and documenting all functions"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Data examples to demo the package

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.
-->

```{r development-2}
# Run all this chunk in the console directly
# Create "inst/" directory
#dir.create(here::here("inst"))

# Example dataset
# Make your dataset file available to the current Rmd
pkgload::load_all(path = here::here(), export_all = FALSE)

# You will be able to read your example data file in each of your function examples and tests as follows
datapath <- system.file("data.xlsx", package = "kobocruncher")
form <- system.file("sample_xlsform.xlsx", package = "kobocruncher") 
 
```



# Preparing objects 

## Data loading

```{r function-kobo_data}
#' @title Data loading
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' 
#' #' @return A "datalist" S3 class object (list) formatted to the specifications of "kobocruncher".
#'  
#' @export

kobo_data <- function(datapath) {
   # cat(readxl::excel_sheets(datapath ))
    datalist <- lapply(readxl::excel_sheets(datapath ), function(x) readxl::read_excel(datapath , sheet = x))  
    
    ## In case we do not have the right group separator!
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("/", ".", colnames(y)); y})
    
    ## Recent kobo export append a counter in the export when there's a unique vaiable
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_001", "", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_002", "", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_003", "", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_004", "", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_005", "", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_006", "", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_007", "", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_008", "", colnames(y)); y})
    #names(datalist) <- readxl::excel_sheets(datapath )
    
    class(datalist) <- "datalist" # assigns a "datalist" class to the list. Helpful for later on.
    return(datalist)
}

```


```{r examples-kobo_data}
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )
# MainFrame
datalist[1]
# Second Frame - based on presence of repeat within the form, aka nested or
# hierarchical data structure, etc... 
datalist[2]  
```

```{r tests-kobo_data}
# test_that("kobo_data works", {
# 
# })
```

## Extend the xlsform to add instructions for the analysis plan

Now we can extend the xlsform that was used to document key next steps in the data preparation.

```{r function-kobo_prepare_form}

#' @title Prepare XLSform and review Analysis
#' 
#' @description  Prepare XLSform by adding instructions for the analysis plan and checking that structure and settings are correct.
#' This function open the xlsform - extend if required including the excel formatting, 
#' display the analysis plan summary and resave the file at the end. 
#' 
#'  Once those elements are set up, they will be automatically considered during the automatic crunching phase.
#'  An additional worksheet is also created to document the information required for registration on UNHCR CKAN instance http://ridl.unhcr.org
#'  
#'  1. Configuration of how questions are grouped together in the report:
#'     - chapter: by default the crunching report is presented according to the group. Once set, this will replace the original grouping. Only variable defined within a chapter will be displayed in the crunching report. By dafault chapter will follow the questions sequence - if chapters start with a number that number will overrule the sequence
#'     - subchapter: provides a second level of details below the chapter if subchapters start with a number that number will overrule the sequence
#' 
#'  2. Configuration for data manipulation:
#'     - clean: define what variable shall be re-categorized during cleaning - a local copy of all levels will be locally saved in order to do the mapping in excel. When the mapping is available, it will be automatically applied to the data. Can be useful to reduce the number of categories.
#'     - anonymise: define what variables to consider to statistical disclosure risk measurement and subsequent data treatment
#'  
#'  3. Configuration of specific charts, visualization and analysis: 
#'  
#'     - disaggregation: define variable to use for visual cross tabulation - functions with "_cross"
#'     - correlate: define the variable to use to explore statistical association - works under certain restrictions (i.e. between 2 categorical variables only): kobo_correlate
#'     - cluster: define variable to generate an unsupervised classification (i.e. hierarchical clustering based on multiple correspondance analysis) kobo_cluster
#'     - predict: define variable to use to generate predictive model, ie.e the target variable and the predictors.  kobo_predict
#'     - score: define the different dimensions of a score - and used the score set up for the choice test different aggregation approaches
#'     - mappoint, mappoly: define the variable to use to generate maps - kobo_map
#'  
#' In case if those fields do not yet exist, the function will create dummy column for each one.
#' Also, coloring all rows that have type equal to "begin group", "end group", "begin repeat" or "end repeat" for better legibility
#'
#' @param xlsformpath The full path and filename of the xlsform to be accessed (has to be xlsx file)
#' @param xlsformpathout The full path and filename of the xlsform to be accessed (has to be xlsx file)
#' @param language Optional if the form used multiple languages, indicate the language to use to prepare the analysis plan - check first in your original file -default is  ::english (en)
#' @param ridl If available, it will prefill the RIDL info through what was already recorded there
#'
#' @export 
kobo_prepare_form <- function(xlsformpath,
                              xlsformpathout,
                              language = "",
                              ridl = "") {
  
  # Excel Styling Elements
  # To add filters for sheet, we have to set the range for addAutoFilter() function
  # EX: addAutoFilter(sheet1, "A1:P1") --> add a filter on the 1rd row, columns A:P
  # dfref dataframe allows to find 'P' based on number of columns in the sheet, if number of columns equal to 6 then the range will be A1:dfref[6,] -- A1:F1
  dfref <- data.frame(
    key = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256),
    val = c('A1', 'B1', 'C1', 'D1', 'E1', 'F1', 'G1', 'H1', 'I1', 'J1', 'K1', 'L1', 'M1', 'N1', 'O1', 'P1', 'Q1', 'R1', 'S1', 'T1', 'U1', 'V1', 'W1', 'X1', 'Y1', 'Z1', 'AA1', 'AB1', 'AC1', 'AD1', 'AE1', 'AF1', 'AG1', 'AH1', 'AI1', 'AJ1', 'AK1', 'AL1', 'AM1', 'AN1', 'AO1', 'AP1', 'AQ1', 'AR1', 'AS1', 'AT1', 'AU1', 'AV1', 'AW1', 'AX1', 'AY1', 'AZ1', 'BA1', 'BB1', 'BC1', 'BD1', 'BE1', 'BF1', 'BG1', 'BH1', 'BI1', 'BJ1', 'BK1', 'BL1', 'BM1', 'BN1', 'BO1', 'BP1', 'BQ1', 'BR1', 'BS1', 'BT1', 'BU1', 'BV1', 'BW1', 'BX1', 'BY1', 'BZ1', 'CA1', 'CB1', 'CC1', 'CD1', 'CE1', 'CF1', 'CG1', 'CH1', 'CI1', 'CJ1', 'CK1', 'CL1', 'CM1', 'CN1', 'CO1', 'CP1', 'CQ1', 'CR1', 'CS1', 'CT1', 'CU1', 'CV1', 'CW1', 'CX1', 'CY1', 'CZ1', 'DA1', 'DB1', 'DC1', 'DD1', 'DE1', 'DF1', 'DG1', 'DH1', 'DI1', 'DJ1', 'DK1', 'DL1', 'DM1', 'DN1', 'DO1', 'DP1', 'DQ1', 'DR1', 'DS1', 'DT1', 'DU1', 'DV1', 'DW1', 'DX1', 'DY1', 'DZ1', 'EA1', 'EB1', 'EC1', 'ED1', 'EE1', 'EF1', 'EG1', 'EH1', 'EI1', 'EJ1', 'EK1', 'EL1', 'EM1', 'EN1', 'EO1', 'EP1', 'EQ1', 'ER1', 'ES1', 'ET1', 'EU1', 'EV1', 'EW1', 'EX1', 'EY1', 'EZ1', 'FA1', 'FB1', 'FC1', 'FD1', 'FE1', 'FF1', 'FG1', 'FH1', 'FI1', 'FJ1', 'FK1', 'FL1', 'FM1', 'FN1', 'FO1', 'FP1', 'FQ1', 'FR1', 'FS1', 'FT1', 'FU1', 'FV1', 'FW1', 'FX1', 'FY1', 'FZ1', 'GA1', 'GB1', 'GC1', 'GD1', 'GE1', 'GF1', 'GG1', 'GH1', 'GI1', 'GJ1', 'GK1', 'GL1', 'GM1', 'GN1', 'GO1', 'GP1', 'GQ1', 'GR1', 'GS1', 'GT1', 'GU1', 'GV1', 'GW1', 'GX1', 'GY1', 'GZ1', 'HA1', 'HB1', 'HC1', 'HD1', 'HE1', 'HF1', 'HG1', 'HH1', 'HI1', 'HJ1', 'HK1', 'HL1', 'HM1', 'HN1', 'HO1', 'HP1', 'HQ1', 'HR1', 'HS1', 'HT1', 'HU1', 'HV1', 'HW1', 'HX1', 'HY1', 'HZ1', 'IA1', 'IB1', 'IC1', 'ID1', 'IE1', 'IF1', 'IG1', 'IH1', 'II1', 'IJ1', 'IK1', 'IL1', 'IM1', 'IN1', 'IO1', 'IP1', 'IQ1', 'IR1', 'IS1', 'IT1', 'IU1', 'IV1')
  )
  
  #For better legibility create specific styles for rows that defines header, groups and repeat 
  headerSt <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fontSize = 13, fgFill = "grey50",
                                     border = "TopBottom", borderColour = "grey80", borderStyle = "thin")
  cs1 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "black", fgFill = "orange",
                                border = "TopBottom", borderColour = "orange", borderStyle = "thin")
  cs2 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fgFill = "skyblue",
                                border = "TopBottom", borderColour = "skyblue", borderStyle = "thin")    
  
  
  tryCatch({
    
    ## Create a blank workbook
    wb <- openxlsx::createWorkbook()
    
    ### Survey sheet ######################################
    survey <- tryCatch({
      suppressMessages(
        as.data.frame(readxl::read_excel(xlsformpath, sheet = "survey"),
                      stringsAsFactors = FALSE) #read survey sheet from the form
      ) ## avid all the new names message...
      
    }, error = function(err) {
      data.frame( #if it doesn't exist, we need to create empty dataframe with those fields
        type = character(),
        name = character(),
        label = character(),
        labelQ = character(),
        hint = character(),
        hintQ = character(),
        relevant = character(),
        required = character(),
        constraint = character(),
        repeat_count = character(),
        calculation = character(),
        choice_filter = character(),
        read_only = character(),
        default = character(),
        ## Additional variable for analysis plan
        clean = character(),
        anonymise = character(),
        chapter = character(),
        disaggregation = character(),
        correlate = character(),
        cluster = character(),
        predict = character(),
        mappoint = character(),
        mappoly = character(),
        stringsAsFactors = FALSE,
        check.names = F
      )
    })
    
    ## Remove all na column in case...
    survey <- survey |>
      dplyr::select(where(function(x) any(!is.na(x))))
    
    ## Clean the label and hint in relation with the selected language
    names(survey)[tolower(names(survey)) == tolower(paste0("label",language) )] <- "label"
    names(survey)[tolower(names(survey)) == tolower(paste0("hint",language) )] <- "hint"

    
    ## Adding variable if not present and checking the content of the variable to build up the analysis plan summary... 
    if ("hint" %in% colnames(survey)) {   } else {    survey$hint <- ""   }
    if ("chapter" %in% colnames(survey)) { } else { survey$chapter <- ""   }
    if ("subchapter" %in% colnames(survey)) { } else { survey$subchapter <- ""   }
    if ("correlate" %in% colnames(survey)) {    } else {  survey$correlate <- ""}
    if ("disaggregation" %in% colnames(survey)) { } else { survey$disaggregation <- ""  }
    if ("clean" %in% colnames(survey)) {     } else {  survey$clean <- "" }
    if ("anonymise" %in% colnames(survey)) {     } else {survey$anonymise <- ""}
    if ("cluster" %in% colnames(survey)) { } else { survey$cluster <- ""}
    if ("predict" %in% colnames(survey)) {     } else { survey$predict <- ""  }
    if ("score" %in% colnames(survey)) {     } else { survey$score <- ""  }
    if ("mappoint" %in% colnames(survey)) {    } else { survey$mappoint <- ""}
    if ("mappoly" %in% colnames(survey)) {    } else { survey$mappoly <- ""}
    survey$label.lenght <- nchar(survey$label)
    ## add the full name that will be used by functions
    survey$fullname <- survey |> 
      # capturing repeat
      dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                                    function (repeatvar, type, name) {
                                                      if (type  == "begin_repeat")  c(repeatvar, name)
                                                      else if (type  == "end_repeat") utils::head(repeatvar, -1)
                                                      else repeatvar
                                                    }, .init = character()) |> utils::tail(-1),
                    ##Apply a function to each element of a list 
                    repeatvar = purrr::map_chr(repeatvar,
                                               stringr::str_c, 
                                               collapse = ".") ,
                    name = dplyr::case_when(repeatvar == "" ~ name,
                                            type == "begin_repeat"~ repeatvar,
                                            TRUE ~ stringr::str_c(repeatvar, name, sep = "."))) |>
      
      
      # capturing Group
      dplyr::mutate(scope = purrr::accumulate2(type, name,
                                               function (scope, 
                                                         type, 
                                                         name) {
                                                 if (type == "begin_group") 
                                                   c(scope, name)
                                                 else if (type == "end_group") utils::head(scope, -1)
                                                 else scope
                                               }, .init = character()) |> utils::tail(-1),
                    ##Apply a function to each element of a list 
                    scope = purrr::map_chr(scope, 
                                           stringr::str_c, 
                                           collapse = "."),         
                    
                    name = dplyr::case_when(scope == "" ~ name,
                                            type == "begin_group" ~ scope,
                                            TRUE ~ stringr::str_c(scope, name, sep = "."))) |>
                    dplyr::pull(name)
    if ("labelQ" %in% colnames(survey)) {    } else {  survey$labelQ <- survey$label }
    if ("hintQ" %in% colnames(survey)) {    } else { survey$hintQ <- survey$hint}
    
    ### order in user friendly    way
    namesOfSur <- c( "type", "name", "label", "hint", 
                     "chapter", "subchapter",
                     "anonymise",  "clean"     ,
                     "disaggregation", "correlate",
                     "cluster"  , "predict" ,"score" ,
                     "mappoint",  "mappoly",
                     "label.lenght", "fullname",
                     "labelQ", "hintQ",
                     "required", "relevant",
                     "constraint", "calculation" )
    namesOfSur <- as.data.frame(namesOfSur) |>
      dplyr::filter(namesOfSur %in% colnames(survey)) |>
      dplyr::pull() 
    survey <- survey[ ,namesOfSur]
    ## need to delete empty rows from the form
    survey <- as.data.frame(survey[!is.na(survey$type), ])
    survey[is.na(survey)] <-  ""
    sheetname <- "survey"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, survey, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(survey), widths = "auto")
    openxlsx::setColWidths(wb, sheetname, cols = 2:3, widths = 30)
    all.cols <- 1:ncol(survey)
    hdr.rows <- 1
    group.rows <- which(stringr::str_detect(survey$type, "group"))+1
    repeat.rows <- which(stringr::str_detect(survey$type, "repeat"))+1
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, all.cols, gridExpand = TRUE)
    openxlsx::addStyle(wb, sheetname, cs1, group.rows, all.cols, gridExpand = TRUE)
    openxlsx::addStyle(wb, sheetname, cs2, repeat.rows, all.cols, gridExpand = TRUE)
    
    ### Choices sheet ######################################
    choices <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "choices"),
                    stringsAsFactors = FALSE) #read survey sheet from the form
    }, error = function(err) {
      data.frame( #if it doesn't exist, we need to create empty dataframe with those fields
        list_name = character(),
        name = character(),
        label = character(),
        labelQ = character(),
        order = character(),
        stringsAsFactors = FALSE,
        check.names = F
      )
    }) 
    ## Rename the variable label
    
    ## Rename the variable label based on language
    names(choices)[tolower(names(choices)) == tolower(paste0("label",language) )] <- "label"
    
    namesOfCho <- c("list_name", "name", "label")
    if (sum(namesOfCho %in% colnames(choices)) != length(namesOfCho)) {
      return(structure('Please make sure the choices sheet has at minima the following columns:
                        "list_name", "name" , "label"', class = "try-error"))
    }
    
    choices$label.lenght <- nchar(choices$label)
    choices$labelQ <- choices$label   
    ### add column if not present
    if ("order" %in% colnames(choices)) { } else { choices$order <- ""}
    if ("score" %in% colnames(choices)) {  } else { choices$score <- ""}
    namesOfCho <- c("list_name", "name", "label",  "order", "score","label.lenght","labelQ") 
    namesOfCho <- as.data.frame(namesOfCho) |>
      dplyr::filter(namesOfCho %in% colnames(choices)) |>
      dplyr::pull() 
    choices <- choices[ ,namesOfCho]
    sheetname <- "choices"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, choices, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(choices), widths = "auto")
    openxlsx::setColWidths(wb, sheetname, cols = 2:3, widths = 30)
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(choices), gridExpand = TRUE)
    
    
    ### Settings sheet ######################################
    settings <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "settings"),
                    stringsAsFactors = FALSE)
    }, error = function(err) {
      data.frame(
        form_title  = c("study"),
        form_id  = c("koboID"),
        default_language  = c("::spanish (es)"),
        #form_title = character(),
        #form_id = character(),
        #default_language = character(),
        stringsAsFactors = FALSE
      )
    }) 
    
    if (settings$form_title =="" | is.na(settings$form_title)) { } else {settings$form_title <- "Study"}
    sheetname <- "settings"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, settings, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(settings), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(settings), gridExpand = TRUE)
    
    ### RIDL sheets ######################################
    ridl_schema <- jsonlite::fromJSON("https://raw.githubusercontent.com/okfn/ckanext-unhcr/master/ckanext/unhcr/schemas/dataset.json")
    ridl_dataset_fields <- ridl_schema$dataset_fields # |> tibble::as_tibble()
    ridl_resource_fields <- ridl_schema$resource_fields # |> tibble::as_tibble()
    ridl_choices <-
      ridl_dataset_fields |>
      dplyr::mutate(choices = purrr::map(choices, as.data.frame)) |>
      dplyr::select(field_name, choices) |>
      tidyr::unnest(choices) |>
      dplyr::select(list_name = field_name, name = value, label) |>
      as.data.frame()
    ridl_metadata <-
      ridl_dataset_fields |>
      dplyr::transmute(
        type =
          dplyr::case_when(
            preset == "multiple_select" ~ stringr::str_c("select_multiple", field_name, sep = " "),
            field_name %in% ridl_choices$list_name ~ stringr::str_c("select_one", field_name, sep = " "),
            TRUE ~ "text"),
        name = field_name,
        label,
        required,
        hint = dplyr::if_else(!is.na(help_text), help_text, form_placeholder),
        value = "")
    
    sheetname <- "ridl-metadata"
    if (sheetname %in% readxl::excel_sheets(xlsformpath)) {
      ridl_metadata <-
        ridl_metadata |>
        dplyr::select(-value) |>
        dplyr::left_join(readxl::read_excel(xlsformpath, sheet = sheetname) |> dplyr::select(name, value), by = "name")
    }
    
    sheetname <- "ridl-metadata"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, ridl_metadata, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(ridl_metadata), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(ridl_metadata), gridExpand = TRUE)
    sheetname <- "ridl-choices"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, ridl_choices, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(ridl_choices), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(ridl_choices), gridExpand = TRUE)
    
    
    
    ###  indicator sheet ######################################
    indicator <- tryCatch({
      as.data.frame(readxl::read_excel(form_tmp, sheet = "indicator"),stringsAsFactors = FALSE)
    }, error = function(err) {
      data.frame(
        type = character(),
        name = character(),
        label = character(),
        hint = character(),
        dataframe = character(),
        calculation = character(),
        chapter = character(),
        subchapter = character(),
        disaggregation = character(),
        correlate = character(),
        cluster = character(),
        predict = character(),
        score = character(),
        mappoint = character(),
        mappoly = character(),
        stringsAsFactors = FALSE
      )
     }
    )
        if ("type" %in% colnames(indicator)) {   } else {    indicator$type <- ""   }
        if ("name" %in% colnames(indicator)) {   } else {    indicator$name <- ""   }
        if ("label" %in% colnames(indicator)) {   } else {    indicator$label <- ""   }
        if ("hint" %in% colnames(indicator)) {   } else {    indicator$hint <- ""   }
        if ("dataframe" %in% colnames(indicator)) { } else { indicator$dataframe <- ""   }
        if ("calculation" %in% colnames(indicator)) { } else { indicator$calculation <- ""   }
        if ("chapter" %in% colnames(indicator)) { } else { indicator$chapter <- ""   }
        if ("subchapter" %in% colnames(indicator)) { } else { indicator$subchapter <- ""   }
        if ("correlate" %in% colnames(indicator)) {    } else {  indicator$correlate <- ""}
        if ("disaggregation" %in% colnames(indicator)) { } else { indicator$disaggregation <- ""  }
        if ("cluster" %in% colnames(indicator)) { } else { indicator$cluster <- ""}
        if ("predict" %in% colnames(indicator)) {     } else { indicator$predict <- ""  }
        if ("score" %in% colnames(indicator)) {     } else { indicator$score <- ""  }
        if ("mappoint" %in% colnames(indicator)) {    } else { indicator$mappoint <- ""}
        if ("mappoly" %in% colnames(indicator)) {    } else { indicator$mappoly <- ""}

    indicator <- indicator[ ,c("type","name","label", "hint",
                               "dataframe", "calculation",
                               "chapter","subchapter", "disaggregation", "correlate",
                                "cluster", "predict", "score", "mappoint", "mappoly")]
    sheetname <- "indicator"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, indicator, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(indicator), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(indicator), gridExpand = TRUE)

    
    
    cat("\n******************** Summary of the Analysis Plan *********************\n \n")
    ### Saving final ######################################    
    if (file.exists(xlsformpathout)) file.remove(xlsformpathout)
    openxlsx::saveWorkbook(wb, xlsformpathout)
    
    
    
    
    
    
    
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
    ## get a summary of what we have
    ## Check Variable lenght
    # if( length(survey$label) )
    ## Do we have chapters? If yes how many?
    ## Do we have anonymisation instructions? If yes, is it correctly set? How many direct identifiers, key variables, sensitive variables
    ## Do we have cleaning instructions? Are they set up for the select_ variable
    ## Do we have disaggregation instructions (yes)? -- Should Are they set up for the select_one variable
    ## Do we have correlate instructions  (yes)? Are they set up for the select_one variable       
    ## Do we have cluster instructions  (yes)? Are they set up for the select_one variable 
    ## Do we have predict instructions  (one unique target, at least 2 predictor)? Are they set up for the select_one variable 
    ## Do we have mappoint, mappoly (yes)? Are they set up for the select_one variable 
    
    
    
  }, error = function(err) {
    print("There was an error in the xlsform preparation step!!! \n\n")
    return(structure(err, class = "try-error"))
  })
  
}

```


```{r examples-kobo_prepare_form}
# kobo_prepare_form(xlsformpath = system.file("form.xlsx", package = "kobocruncher"),
#                   xlsformpathout = "form_with_plan.xlsx")
```

```{r tests-kobo_prepare_form}
# test_that("kobo_prepare_form works", {
# 
# })
```


## Prepare data dictionnary

```{r function-kobo_dico}
#' @title Prepare Analysis plan
#' @param xlsformpath path to the (extended) xlsform file used to collect the data
#' 
#' @return A "kobodico" S3 class object (list) formatted to the specifications of "kobocruncher".
#' @export

kobo_dico <- function(xlsformpath) {
   survey <- readxl::read_excel(xlsformpath,   
                                sheet = "survey")
  
   ## variables ###############
  variables <-  survey |>
    ## Rename and use what ever label set is coming first 
    dplyr::rename(label = dplyr::first(tidyselect::starts_with("label")),
                  hint = dplyr::first(tidyselect::starts_with("hint"))) |>
    
    
    # Clean the begin and end in case the _ would be missing...
    dplyr::mutate(type = dplyr::recode(type, 
                                        "begin group" = "begin_group" ,
                                        "end group"   ="end_group",
                                       "begin repeat" = "begin_repeat" ,
                                       "end repeat"   ="end_repeat")) |>
    
    ## spearate the type
    tidyr::separate(type, 
                        into = c("type", "list_name"), 
                        sep = " ",
                        fill = "right")   |>
    
    ## Need to add more cleaning in case...
    #dplyr::filter(!(is.na(name))) |>
    #dplyr::filter(!(is.na(label))) |>
    dplyr::filter(!(is.na(type))) |>
    
    # capturing repeat
    dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                                  function (repeatvar, type, name) {
                                                    if (type  == "begin_repeat")  c(repeatvar, name)
                                                    else if (type  == "end_repeat") utils::head(repeatvar, -1)
                                                    else repeatvar
                                                  }, .init = character()) |> utils::tail(-1),
                  ##Apply a function to each element of a list 
                  repeatvar = purrr::map_chr(repeatvar,
                                             stringr::str_c, 
                                             collapse = ".") ,
                  name = dplyr::case_when(repeatvar == "" ~ name,
                                          type == "begin_repeat"~ repeatvar,
                                          TRUE ~ stringr::str_c(repeatvar, name, sep = "."))) |>
                 
    
      # capturing Group
      dplyr::mutate(scope = purrr::accumulate2(type, name,
                                               function (scope, 
                                                         type, 
                                                         name) {
                                                 if (type == "begin_group") 
                                                    c(scope, name)
                                                    else if (type == "end_group") utils::head(scope, -1)
                                                 else scope
                                               }, .init = character()) |> utils::tail(-1),
                    ##Apply a function to each element of a list 
                    scope = purrr::map_chr(scope, 
                                           stringr::str_c, 
                                           collapse = "."),         
                    
                    name = dplyr::case_when(scope == "" ~ name,
                                            type == "begin_group" ~ scope,
                                            TRUE ~ stringr::str_c(scope, name, sep = "."))) 
  
  
  ## Fix when we have calculate variable - either numeric or select_one
  
  ## Add dataframe number
  ## Counter..
  variables$dataframenew <- 0
  for (i in 2:nrow(variables)){
    #i <- 10
    #cat( variables[i, c("repeatvar")] )
    if (variables[i, c("repeatvar")] != variables[i-1, c("repeatvar")] &
        variables[i, c("repeatvar")] !="" ) {
      variables[i, c("dataframenew")] <- 1
    } else{
      variables[i, c("dataframenew")] <- 0
    }
  }
   ## Counter..
  variables$dataframecount <- 1
  for (i in 2:nrow(variables)){  
    if (variables[i, c("repeatvar")] != "") {
      variables[i, c("dataframecount")] <- variables[i-1, c("dataframecount")] + variables[i, c("dataframenew")]
    } else{
      variables[i, c("dataframecount")] <- variables[i-1, c("dataframecount")]
    }
    
  }
   ## Framenumber
  variables$dataframe <- 1
  for (i in 2:nrow(variables)){  
    if (variables[i, c("repeatvar")] != "") {
          variables[i, c("dataframe")] <- variables[i, c("dataframecount")] 
        } else{
          variables[i, c("dataframe")] <- 1
        }
   }
  variables$dataframecount <- NULL
  variables$dataframenew <- NULL
  
    if ("chapter" %in% colnames(variables)) { } else {  variables$chapter <- NA  }
    if ("subchapter" %in% colnames( variables)) { } else {  variables$subchapter <- NA   }
    if ("disaggregation" %in% colnames(variables)) { } else {  variables$disaggregation <- NA  }
    if ("correlate" %in% colnames( variables)) { } else {  variables$correlate <- NA   }  
  
  # Adding the appearance variable that will be used for likert charts
  # to check and check and remove label appearance 
    if ("appearance" %in% colnames(variables)) {   } else {   variables$appearance <- ""  }
  

     choices <- readxl::read_excel(xlsformpath,   sheet = "choices")  
    if ("order" %in% colnames( choices)) { } else {  choices$order <- NA   }
     modalities <- choices |>
                   dplyr::rename(label = dplyr::first(matches("^label")))
     
     settings <- readxl::read_excel(xlsformpath,   
                                sheet = "settings")
     
     ### Building the plan ######
     ## Build the question order for the crunching report
     if (  nrow(as.data.frame(variables)|> dplyr::filter(! is.na(chapter)))  > 1 ) {
       
       
      ## Reinsert chapter and subchapter as begin_group
       subchapterorder <- as.data.frame(variables) |>
          dplyr::distinct(chapter, subchapter) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::mutate( subchapternum = dplyr::row_number())
        
        plansub  <- as.data.frame(variables) |>
            dplyr::filter(! is.na(chapter) ) |>
           dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
           dplyr::group_by( chapter, subchapter) |>
           dplyr::summarise( type = "begin_group",
                      name =  "labelsub.chapter" ) |>
           dplyr::mutate( label = subchapter) |>
           dplyr::bind_rows(as.data.frame(variables) |>
                              dplyr::filter(! is.na(chapter) ) |>
                              dplyr::filter( ! type  %in% c("begin_group", "end_group") ) ) |>
           dplyr::left_join(subchapterorder, by = c("chapter", "subchapter")) |>
           #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
           dplyr::arrange(subchapternum)  |>
          dplyr::mutate( labelsub.chapter = paste0("labelsub.chapter" , subchapternum ) ) |>
          dplyr::mutate(  name= dplyr::case_when(
              name == "labelsub.chapter" ~ labelsub.chapter ,
              TRUE ~ name) )
        
        chapterorder <- as.data.frame(variables) |>
          dplyr::distinct(chapter) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::mutate( chapternum = dplyr::row_number())
        
        plan  <- as.data.frame(variables) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
          dplyr::group_by( chapter) |>
          dplyr::summarise( type = "begin_group",
                            name = "labelchapter" ) |>
           dplyr::mutate( label = chapter) |>
          dplyr::bind_rows(plansub ) |>
          dplyr::left_join(chapterorder, by = c("chapter" )) |>
          #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
          dplyr::arrange(chapternum) |>
          dplyr::mutate( labelchapter = paste0("labelchapter" , chapternum ) ) |>
          dplyr::mutate(  name= dplyr::case_when(
              name == "labelchapter" ~ labelchapter ,
              TRUE ~ name) ) |>
          dplyr::select( type, label,name)
        
        } else { 
        plan <- as.data.frame(variables) |>
          dplyr::select(type, label,name)|>
          dplyr::filter( ! type  %in% c("note",  "end_group") )
       }
       
     ## adding indicators 
    indicator <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath,   
                                sheet = "indicator"),stringsAsFactors = FALSE)
        }, error = function(err) {
          data.frame(
            type = character(),
            name = character(),
            label = character(),
            hint = character(),
            dataframe = character(),
            calculation = character(),
            chapter = character(),
            subchapter = character(),
            disaggregation = character(),
            correlate = character(),
            cluster = character(),
            predict = character(),
            score = character(),
            mappoint = character(),
            mappoly = character(),
            stringsAsFactors = FALSE
          )
         }
        )
        if ("type" %in% colnames(indicator)) {   } else {    indicator$type <- ""   }
        if ("name" %in% colnames(indicator)) {   } else {    indicator$name <- ""   }
        if ("label" %in% colnames(indicator)) {   } else {    indicator$label <- ""   }
        if ("hint" %in% colnames(indicator)) {   } else {    indicator$hint <- ""   }
        if ("dataframe" %in% colnames(indicator)) { } else { indicator$dataframe <- ""   }
        if ("calculation" %in% colnames(indicator)) { } else { indicator$calculation <- ""   }
        if ("chapter" %in% colnames(indicator)) { } else { indicator$chapter <- ""   }
        if ("subchapter" %in% colnames(indicator)) { } else { indicator$subchapter <- ""   }
        if ("correlate" %in% colnames(indicator)) {    } else {  indicator$correlate <- ""}
        if ("disaggregation" %in% colnames(indicator)) { } else { indicator$disaggregation <- ""  }
        if ("cluster" %in% colnames(indicator)) { } else { indicator$cluster <- ""}
        if ("predict" %in% colnames(indicator)) {     } else { indicator$predict <- ""  }
        if ("score" %in% colnames(indicator)) {     } else { indicator$score <- ""  }
        if ("mappoint" %in% colnames(indicator)) {    } else { indicator$mappoint <- ""}
        if ("mappoly" %in% colnames(indicator)) {    } else { indicator$mappoly <- ""}
    
        indicator <- indicator[ ,c("type","name","label", "hint",
                                   "dataframe", "calculation",
                                   "chapter","subchapter", "disaggregation", "correlate",
                                    "cluster", "predict", "score", "mappoint", "mappoly")]
     
     
     
    dico <- list( variables, 
                  modalities,
                  settings,
                  plan,
                  indicator)
    class(dico) <- "kobodico" # assigns a "kobodico" class to the list. Helpful for later on. 
    ## Build dico object as list with both variables and modalities
    return(dico )
}

```


```{r examples-kobo_dico}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
# Survey
questions <- as.data.frame(dico[1])
knitr::kable(utils::head(questions, 10))
# Choices
responses <- as.data.frame(dico[2])
knitr::kable(utils::head(responses, 10))
# Settings
metadata <- as.data.frame(dico[3])
knitr::kable(utils::head(metadata, 10))
# Report ToC
toc <- as.data.frame(dico[4])
knitr::kable(utils::head(toc, 10))
# Indicator
indicator <- as.data.frame(dico[5])
knitr::kable(utils::head(indicator, 10))
```

# Data Processing

## Cleaning

 to do....


```{r function-kobo_clean}
#' @title Apply cleaning to selected variables within the xlsform
#' 
#' @description Basic data cleaning is often required. This functions covers tow use cases:
#'  Use Case 1 - Need to re-categorize the modalities for a select_one or select_multiple 
#'  Use case 2-  Need to re-encode one variable based on a cleaned open text question
#'  
#'  To address those situation, the kobo_clean function is building, if not set-up,  a cleaning log 
#'  for all the variables where the clean cell is not empty within the extended xlsform.
#'  
#'  The cleaning log has only 3 columns: variable - old value - new value
#'  This cleaning log can be then easily be adjusted in excel and used in the cleaning workflow when 
#'  running the function.
#'  
#'  If the cell `clean` for the variables refers to the name of another variable that is also included
#'  in the cleaning log, then this second variable will be used to clean the first one from the second one. 
#'  This behavior allow to manage the use case 2.  
#'  
#'  Note that this function can also be used to adjust in order to treat the data and reduce data disclosure risk
#'  See kobo_anonymise
#'  
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' 
#' @export

kobo_clean <- function(datalist,
                       dico, 
                       indicatoradd = NULL) {

#   1 - load the variables, 
  var <- as.data.frame(dico[1])  
#   2 - append the one from inidcatoradd if any,
  
#   3 - apply the indicator, i.e. do the calculation,
#   4 - re-save all the working indicator definition within the extended xlsform  
#   5 - bind the new indicators in the dictionary in order to use the kobo_frame() function for further plotting 
#   6 - rebuild the plan if indicators are allocated to chapter, subchapter 
  
  with_clean <- list( datalist, dico)
    
    return(with_clean)
}

```


```{r examples-kobo_clean}
# dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
# datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )
# 
# kobo_clean(datalist = datalist,
#                    dico = dico,
#                 indicatoradd = indicatoradd   )


 
```
 

## Anonymisation

 to do....


```{r function-kobo_anonymise}
#' @title Assess Statistical disclosure risk based on an intrusions scenario
#' 
#' @description  When personal data is being collected, performing basic de-identification (i.e. removal of direct identifiers) and assessing risk of re-identification (i.e. using indirect identifiers to re-identify individuals) is a key sep to perform in order to be able to share the data with multiple analyst.
#' 
#' The initial step consist in defining potential intrusion scenario.
#'  This suppose to document the anonymise cell for each variable
#'
#' \tabular{rrrrrr}{
#'   \strong{Type}    \tab \strong{Description}  \cr
#'   ----------------\tab----------- \cr
#'   \strong{Direct_identifier}     \tab	Can be directly used to identify an individual. E.g. Name, Address, Date of birth, Telephone number, GPS location \cr
#'   \strong{Quasi_identifier}     \tab	Can be used to identify individuals when it is joined with other information. E.g. Age, Salary, Next of kin, School name, Place of work \cr
#'   \strong{Sensitive_information}  \tab & Community identifiable information	Might not identify an individual but could put an individual or group at risk. E.g. Gender, Ethnicity, Religious belief 
#' }
#'
#'  Direct identifiers will be automatically removed from the data.
#'  The function will perform the measurement of various statistical disclosure risk measurement
#'  for the selected quasi_identifier and sensitive_information.
#'  
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @export

kobo_anonymise <- function(datalist,
                       dico, 
                       indicatoradd = NULL) {

#   1 - load the indicators, 
  indicator <- as.data.frame(dico[4])  
#   2 - append the one from inidcatoradd if any,
  
#   3 - apply the indicator, i.e. do the calculation,
#   4 - re-save all the working indicator definition within the extended xlsform  
#   5 - bind the new indicators in the dictionary in order to use the kobo_frame() function for further plotting 
#   6 - rebuild the plan if indicators are allocated to chapter, subchapter 
  
  with_anonymise <- list( datalist, dico)
    
    return(with_anonymise)
}

```


```{r examples-kobo_anonymise}
# dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
# datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )
# 
# kobo_anonymise(datalist = datalist,
#                    dico = dico,
#                 indicatoradd = indicatoradd   )


 
```


## Indicator Calculation

Indicator calculation 


```{r function-kobo_indicator}
#' @title Apply existing documented indicators and add new ones
#' 
#' @description The function goes through steps:
#'   1 - load the indicators, 
#'   2 - append the one from inidcatoradd if any, 
#'   3 - apply the indicator, i.e. do the calculation,
#'   4 - re-save all the working indicator definition within the extended xlsform  
#'   5 - bind the new indicators in the dictionary in order to use the kobo_frame() function for further plotting 
#'   6 - rebuild the plan if indicators are allocated to chapter, subchapter 
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param indicatoradd a list containing all key information to add a calculated indicator within the analysis plan
#' @export

kobo_indicator <- function(datalist,
                       dico, 
                       indicatoradd = NULL) {

#   1 - load the indicators, 
  indicator <- as.data.frame(dico[4])  
#   2 - append the one from inidcatoradd if any,
  
#   3 - apply the indicator, i.e. do the calculation,
#   4 - re-save all the working indicator definition within the extended xlsform  
#   5 - bind the new indicators in the dictionary in order to use the kobo_frame() function for further plotting 
#   6 - rebuild the plan if indicators are allocated to chapter, subchapter 
  
  with_indicator <- list( datalist, dico)
    
    return(with_indicator)
}

```


```{r examples-kobo_indicator}
# dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
# datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )
# 
# indicatoradd <- c(  name =  "has.female.members",
#               type = "select_one",
#               label = "Is ",
#               dataframe = "1",
#               calculation = "")
# 
# kobo_indicator(datalist = datalist,
#                    dico = dico,
#                 indicatoradd = indicatoradd   )


 
```


# Labeling functions

## Get the correct frame for a specific variable

```{r function-kobo_frame}
#' @title get the correct frame for one selected variable - important when having variables within a repeat
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var variable
#' @export

kobo_frame <- function(datalist,
                       dico, 
                       var) {
  
  ## Identify the right frame number
  dataframen <- as.data.frame(dico[1]) |>
                  dplyr::filter(name == var) |>
                  dplyr::pull(dataframe)  
  ## Pull the data
  data  <-  datalist[dataframen] |>
              as.data.frame()
  
## get correct id whether the frmae is nested one or not.. 
if ("_id" %in% colnames(data)) { data$X_id <-  data$`_id` } else {  }
if ("_index" %in% colnames(data)) { data$X_id <-  data$`_index` } else {  }
if ("X_index" %in% colnames(data)) { data$X_id <-  data$X_index  } else { }
if ("X_id" %in% colnames(data)) { data$X_id <-  row.names(data)  } else { }
  
  ## Make sure the data actually contain the variable if not put to null
 if ( var %in% names(data)) {
   data <- data
 }  else {
   data <- data.frame( type = character())
   names(data)[1] <- var  
  
 }
    
    return(data )
}

```


```{r examples-kobo_frame}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = "members.sex"   )
knitr::kable(utils::head(data,5))
 
```

## Get the label for a specific variable

```{r function-label_varname}
#' @title Get the label for a specific variable
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param x character with the variable name
#' @export

label_varname <- function(dico, x) {
  as.data.frame( dico[1]) |>
    dplyr::filter(name == x) |>
    dplyr::pull(label)
}

```

```{r examples-label_varname}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )

label_varname(dico = dico, 
              x ="profile.country")

```

```{r tests-label_varname}
# test_that("label_varname works", {
# 
# })
```

## Get interpretation hint for a specific variable

```{r function-label_varhint}
#' @title Get Interpretation hint for a specific variable
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param x variable
#' @export

label_varhint <- function(dico, x) {
  as.data.frame(dico[1]) |>
    dplyr::filter(name == x) |>
    dplyr::pull(hint)
}

```

```{r examples-label_varhint}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )

label_varhint(dico = dico, 
              x ="profile.country")
```

```{r tests-label_varhint}
# test_that("label_varhintworks", {
# 
# })
```


## Get all the choices labels options for a specific variable

```{r function-label_choiceset}
#' @title Get all the choices labels options for a specific variable if available
#' 
#' @description This labeling function ia function factory - https://adv-r.hadley.nz/function-factories.html
#' The output of this function is actually a function
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param x variable
#' @export

label_choiceset <- function(dico,
                            x) {
  lname <- as.data.frame(dico[1]) |>
    dplyr::filter(name == x) |>
    dplyr::pull(list_name)
  
  dict <- 
    as.data.frame(dico[2]) |>
    dplyr::filter(list_name == lname) |> 
    (\(x) purrr::set_names(x$label, x$name))()
  
#  function(y) { dict[y] |> tidyr::replace_na("Other") }
  function(y) { dplyr::if_else(is.na(dict[y]), y, dict[y]) }

}

```

```{r examples-label_choiceset}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = "profile.country"   )

label_choiceset(dico = dico, 
                x="profile.country")(data$profile.country)

## Test when there's no dictionnary
data$profile.occupation
label_choiceset(dico = dico, 
                x="profile.occupation")(data$profile.occupation)
```

```{r tests-label_choiceset}
# test_that("label_choiceset works", {
# 
# })
```

# Plotting Functions

## Univariate

## Plotting Select one variable

```{r function-plot_select_one}
#' @title Plotting Select one variable
#' @description Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param showcode display the code
#' @export

plot_select_one <- function(datalist  ,
                            dico  ,
                            var,
                            showcode = FALSE) {

  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  ## Get default data source name 
  datasource <- as.character(  dico[3][[1]]$form_title ) 
 
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  
  if ( is.nan(rr)) {
    cat("<strong style=\"color:#0072BC;\">This variable could not be identified in the dataset</strong>\n\n")
  } else {
  
  ## Put a condition in case there's no record
  if (rr != 0  & ! (is.nan(rr)) ) {
  
  cnts <- data |>
    tidyr::drop_na(tidyselect::all_of(var)) |>
    # Lump together factor levels into "other"
    dplyr::count(x := forcats::fct_lump_n(factor(.data[[var]]), n = 5)) |>
    dplyr::mutate(p = n/sum(n))
  
  
  listvar <- as.data.frame(dico[[1]]) |>
             dplyr::filter( name ==var ) |>
             dplyr::pull(list_name)
  
  ## Manage situation if ordinal variable (i.e. order is set in choices)
  if (any(!is.na(dplyr::filter(dico[[2]], list_name == listvar)$order))) {
    cnts <- cnts |>
          dplyr::left_join( dplyr::filter(dico[[2]], list_name == listvar), by = c("x"="name"))|>
          dplyr::mutate(x = forcats::fct_reorder(x, order, as.numeric))
  } else {
    cnts <- cnts |>
      dplyr::mutate(x = forcats::fct_reorder(x, n))
  }
  
  ## Writing code instruction in report
  if( showcode == TRUE) { cat(paste0( label_varname(dico = dico,
                                                   x = var), "\n",
                                      fontawesome::fa("far fa-copy", fill ="grey"),
                                      "`plot_select_one(datalist = datalist, dico = dico, \"", var, "\")` \n\n "))}  else {}
  
    
    ## plot
    require(ggplot2)
    p <- ggplot2::ggplot(cnts, aes(p, x)) +
      geom_col(fill = "#0072BC") +
      
      #geom_label(aes(label = scales::label_percent(accuracy = .01)(p))) +
      ## Position label differently in the bar in white - outside bar in black
      geom_label( data =   function(x) subset(x, p < max(p) / 1.5),
                  aes(label = scales::label_percent(accuracy = .01)(p)),
                  hjust = -0.1 ,
                  vjust = 0.5,
                  colour = "black",
                  fill = NA,
                  label.size = NA,
                  
                  size = 4   ) +
      geom_label( data =   function(x) subset(x, p >= max(p) / 1.5),
                  aes(label = scales::label_percent(accuracy = .01)(p)),
                  hjust = 1.1 ,
                  vjust = 0.5,
                  colour = "white",
                  fill = NA,
                  label.size = NA,
                  
                  size = 4   ) +
      scale_x_continuous(labels = scales::label_percent()) +
      scale_y_discrete(labels = function(x) {label_choiceset(dico = dico, x = var)(x) |>
                      stringr::str_wrap(40)}) +
      coord_cartesian(clip = "off") +
      labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(dico = dico, x = var), 90),
           subtitle = if (!is.na(label_varhint(dico = dico, x= var))){
                      stringr::str_wrap(label_varhint(dico = dico, x= var), 90)} else { ""},
           caption = glue::glue("Single choice question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records. \n Source: {datasource}")) +
      theme_minimal( base_size = 16) +
      geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
      theme( panel.grid.major.x  = element_line(color = "#cbcbcb"),
             panel.grid.major.y  = element_blank(),
             panel.grid.minor = element_blank()    ) +
      theme(plot.title.position = "plot")
    
    print(p)
    
  } else { cat("<strong style=\"color:#0072BC;\"> No recorded answers for this specific question!</strong>\n\n")}
  # cat("\n\n")
  }
}  

```

```{r examples-plot_select_one}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_select_one(datalist = datalist,
              dico = dico, 
              var = "profile.country",
              showcode = TRUE)

plot_select_one(datalist = datalist,
              dico = dico, 
              var = "profile.countryerror",
              showcode = TRUE)
```

```{r tests-plot_select_one}
# test_that("plot_select_one works", {
# 
# })
```


## Plotting Select multiple variable

```{r function-plot_select_multiple}
#' @title Plotting Select multiple variable
#' #' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param showcode display the code
#' @export

plot_select_multiple <- function(datalist = datalist, 
                                 dico = dico,
                                 var, 
                                 showcode = FALSE) {
  
  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  nr <- sum(!is.na(data[[var]]))

  
  if ( is.nan(rr)) {
    cat("<strong style=\"color:#0072BC;\">This variable could not be identified in the dataset</strong>\n\n")
  } else {
  
  ## If not empty
  if (rr != 0 & ! (is.nan(rr)) ) {    
  
  cnts <- data |>
    tidyr::drop_na(tidyselect::all_of(var)) |>
    tidyr::separate_rows(.data[[var]], sep = " ") |>
    ## Check if we have _id -  
    
    # Lump together factor levels into "other"
    dplyr::distinct(`X_id`, !!var := forcats::fct_lump_n(factor(.data[[var]]), n = 5)) |>
    dplyr::count(x := .data[[var]]) |>
    dplyr::mutate(p = n/nr)
  
  ## Manage situation if ordinal variable (i.e. order is set in choices)
  if (any(!is.na(dplyr::filter(dico[[2]], list_name == var)$order))) {
    cnts <- cnts |>
      dplyr::left_join( dplyr::filter(dico[[2]], list_name == listvar), by = c("x"="name"))|>
      dplyr::mutate(x = forcats::fct_reorder(x, order, as.numeric))
  } else {
    cnts <- cnts |>
      dplyr::mutate(x = forcats::fct_reorder(x, n))
  }

    
    ## Writing code instruction in report
    if( showcode == TRUE) {
      cat(paste0(label_varname(dico = dico,
                                                   x = var), "\n",
                                      fontawesome::fa("far fa-copy", fill ="grey"),"  `plot_select_multiple(datalist = datalist, dico = dico, \"", var, "\")` \n\n "))}   else {} 
    
    require(ggplot2)
    ## Plot
     p <- ggplot2::ggplot(cnts, aes(p, x)) +
      geom_col(fill = "#0072BC") +
      #geom_label(aes(label = scales::label_percent(accuracy = .01)(p))) + 
      ## Position label differently in the bar in white - outside bar in black
      geom_label( data =   function(x) subset(x, p < max(p) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(p)),
                    hjust = -0.1 ,
                    vjust = 0.5, 
                    colour = "black", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 4   ) +  
      geom_label( data =   function(x) subset(x, p >= max(p) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(p)),
                    hjust = 1.1 ,
                    vjust = 0.5, 
                    colour = "white", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 4   ) +   
      
      scale_x_continuous(labels = scales::label_percent()) +
      scale_y_discrete(labels = function(x) {label_choiceset(dico = dico,
                                                        x = var)(x) |>
          stringr::str_wrap(40)}) +
      coord_cartesian(clip = "off") +
      labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(dico = dico, x= var), 90),
           subtitle = if (!is.na(label_varhint(dico = dico, x = var))){ 
                     stringr::str_wrap(label_varhint(dico = dico, x = var), 90)} else { ""},
           caption = glue::glue("Multiple choice question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
      theme_minimal( base_size = 16) + 
      geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
      theme( panel.grid.major.x  = element_line(color = "#cbcbcb"), 
             panel.grid.major.y  = element_blank(), 
             panel.grid.minor = element_blank()    ) +
      theme(plot.title.position = "plot")
     
     
    print(p)
    
    #plot_select_multiple_cross(var,   by_var)
    
  } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong> \n\n")}
  # cat("\n\n")
    
  }  
}

```

```{r examples-plot_select_multiple}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )


plot_select_multiple(datalist = datalist,
              dico = dico, 
              var = "profile.reason",
              showcode = TRUE
            )

plot_select_multiple(datalist = datalist,
              dico = dico, 
              var = "profile.reason1",
              showcode = TRUE
            )

```

```{r tests-plot_select_multiple}
# test_that("plot_select_multiple works", {
# 
# })
```


## Plotting Numeric variable

```{r function-plot_integer}
#' @title Plotting numeric variable
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param showcode display the code
#' @export

plot_integer <- function(datalist = datalist, 
                         dico = dico,
                         var, 
                         showcode = FALSE) {
  
  requireNamespace("ggplot2") 
  requireNamespace("dplyr")
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  ## Cast just in case...
  data[[var]] <- as.integer(data[[var]])
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  # cat("---\n")
  # cat("\n\n")
 if ( is.nan(rr)) {
    cat("<strong style=\"color:#0072BC;\">This variable could not be identified in the dataset</strong>\n\n")
  } else {
  
  ## Writing report
  if (rr != 0 & ! (is.nan(rr))  ) { 
      ## Writing code instruction in report
      if( showcode == TRUE) {
        cat(paste0(label_varname(dico = dico,
                                                   x = var), "\n",
                                      fontawesome::fa("far fa-copy", fill ="grey"),"  `plot_integer(datalist = datalist, dico = dico, \"", var, "\")` \n\n "))}    else {}
    
    require(ggplot2)
    p <- ggplot2::ggplot(data) + 
      ggplot2::geom_histogram(aes( x= .data[[var]]), 
                    # bins = nclass.FD(na.omit(data[[var]])),
                     fill = "#0072BC", 
                     color = "white" 
      ) +
      # scale_y_continuous(labels = scales::label_percent()) +
      labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(dico = dico, x = var), 90), 
           subtitle = if (!is.na(label_varhint(dico = dico, x = var))){ 
                     stringr::str_wrap(label_varhint(dico = dico, x = var), 90)} else { ""},
           caption = glue::glue("Numeric response, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
  
      theme_minimal( base_size = 16) +
      geom_hline(yintercept = 0, size = 1.1, colour = "#333333") +
      theme( panel.grid.major.y  = element_line(color = "#cbcbcb"), 
           panel.grid.major.x  = element_blank(), 
           panel.grid.minor = element_blank()    ) +
           theme(plot.title.position = "plot")
    
    print(p)
    
    } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong>\n\n")}
  # cat("\n\n")
  }
}

```

```{r examples-plot_integer}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_integer(datalist = datalist,
              dico = dico, 
              var = "members.age",
              showcode = TRUE)
```

```{r tests-plot_integer}
# test_that("plot_integer works", {
# 
# })
```


## Plotting Open Text variable

```{r function-plot_text}
#' @title Plotting Open Text variables
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param showcode display the code
#' @export

plot_text <- function(datalist = datalist, 
                      dico = dico,
                      var, 
                      showcode = FALSE) {
  
  requireNamespace("dplyr")
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  # cat("---\n")
  # cat("\n\n")
  #cat( stringr::str_wrap(  paste0(  label_varname(var), " (Open Text question)"), 70) )
  # cat(paste("####", label_varname(var)))
  # cat("\n\n")
  #cat("Open Text question\n\n")
  
  rr <- mean(!is.na(data[[var]]))
   if ( is.nan(rr)) {
    cat("<strong style=\"color:#0072BC;\">This variable could not be identified in the dataset</strong>\n\n")
  } else { 
      
  require("tm")
  #Replacing “/”, “@” and “|” with space:
  toSpace <- tm::content_transformer(function (x , pattern ) gsub(pattern, " ", x))  
  # Cleaning the text  #### 
  docs <-  tm::Corpus(tm::VectorSource(data[[var]]))  %>%
            #Text transformation to replace special characters from the text.
            tm::tm_map(., toSpace, "/")  %>%
            tm::tm_map(., toSpace, "@")  %>%
            tm::tm_map(., toSpace, "\\|")  %>%
            # Convert the text to lower case
            tm::tm_map(., content_transformer(tolower))  %>%
            # Remove numbers
            tm::tm_map(., removeNumbers)  %>%
            # Remove punctuations
            tm::tm_map(.,  removePunctuation)  %>%
            # Eliminate extra white spaces
            tm::tm_map(.,  stripWhitespace)  %>%
            # Text stemming - reduces words to their root form.
            tm::tm_map(.,  stemDocument)  %>%
            # Remove common stopwords depending on language
            # The information value of ‘stopwords’ is near zero due to the fact that they 
            # are so common in a language. Removing this kind of words is useful before
            # further analyses. 
            tm::tm_map(., removeWords, stopwords("english"))  %>%
            # Remove your own stop word
            tm::tm_map(., removeWords, c("blabla1", "blabla2")) 
  
    # Step 4 : Build a term-document matrix ####
    # Table containing the frequency of the words. Column names are words and row names are documents. 
    dtm <- tm::TermDocumentMatrix(docs)
    m <- as.matrix(dtm)
    v <- sort(rowSums(m),decreasing=TRUE)
    d <- data.frame(word = names(v),freq=v)
    #head(d, 10)
  
    ## Put a condition in case there's no record
    if(nrow(d) > 0 ) {
      
        ## Writing code instruction in report
        if( showcode == TRUE) {
          cat(paste0(label_varname(dico = dico,
                                                   x = var), "\n",
                                      fontawesome::fa("far fa-copy", fill ="grey"),"  `plot_text(datalist = datalist, dico = dico, \"", var, "\")`  \n\n"))}   else {}
      
      # Step 5 : Generate the Word cloud  ####
      #The importance of words can be illustrated as a word cloud as follow :
      set.seed(1234)
      wordcloud::wordcloud(words = d$word, # words : the words to be plotted
                                freq = d$freq,  # freq : their frequencies
                                min.freq = 1,  # min.freq : words with frequency below min.freq will not be plotted
                                max.words=200, # max.words : maximum number of words to be plotted
                                random.order=FALSE, # random.order : plot words in random order. If false, they will be plotted in decreasing frequency
                                rot.per=0.25,   # rot.per : proportion words with 90 degree rotation (vertical text)
                                colors= RColorBrewer::brewer.pal(8, "Dark2")) # colors : color words from least to most frequent. Use, for example, colors =“black” for single color.
    graphics::title( main = stringr::str_wrap( label_varname(dico = dico, 
                                                  x= var), 90),
           sub = glue::glue("Open Text question \n Source: {datasource}" ))  
    
         
      # p1 <- ggplot2::ggplot(d, 
      #              aes(label = word,
      #                  size = freq,
      #                  color = freq )) +
      #       ggwordcloud::geom_text_wordcloud(area_corr = TRUE,
      #                                        rm_outside = TRUE,
      #                                        eccentricity = 1) +
      #       scale_size_area(max_size = 50) +
      #       # scale_radius(range = c(0, 10),  limits = c(0, NA)) +
      #       scale_color_gradient(low = "darkred", high = "red") +
      #       labs(x = NULL, y = NULL,
      #        title = str_wrap(survey_label(var), 60), 
      #        subtitle = if (!is.na(label_varhint(var))){ 
      #          stringr::str_wrap(label_varhint(var), 70)} else { ""},
      #        caption = glue::glue("Wordcloud displaying an Open Text question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records")) +
      #   
      #       theme_minimal( base_size = 16)  
      # print(p1)
      
    
  } else { cat("<strong style=\"color:#0072BC;\">No significant text for this specific question!</strong>\n\n")}
  
  # cat("\n\n")
  }
}

```

```{r examples-plot_text}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_text(datalist = datalist,
              dico = dico, 
              var = "profile.occupation",
              showcode = TRUE)
```

```{r tests-plot_text}
# test_that("plot_text works", {
# 
# })
```

## Bivariate

## Plotting Select one variable with cross tabulation

```{r function-plot_select_one_cross}
#' @title Plotting Select one variable with cross tabulation on a second categorical variable
#' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param by_var variable to use for cross tabulation
#' @param showcode display the code
#' @export

plot_select_one_cross <- function(datalist = datalist,
                            dico = dico,
                            var, 
                            by_var , 
                            showcode = FALSE) {
  
  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  
  data2 <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = by_var   )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  rr2 <- mean(!is.na(data2[[by_var]]))
  ## Writing report
  # cat("\n")
 # cat(paste("####", label_varname(var)))
  #cat(paste("#### Variable: ", var))
  
  if ( is.nan(rr) | is.nan(rr2) ) {
    cat("<strong style=\"color:#0072BC;\">This variable could not be identified in the dataset</strong>\n\n")
  } else if (  ! (identical(data,data2))  ) {
    # nothing to do - the variable are not in the same frame
    } else {
  
  ## Put a condition in case there's no record
  if (rr != 0 & ! (is.nan(rr)) ) { 
    if(by_var != "") {
      if( by_var != var ) {
        
          ## Writing code instruction in report
          if( showcode == TRUE) { 
            cat(paste0( label_varname(dico = dico,
                                                   x = var), "\n",
                                      fontawesome::fa("far fa-copy", fill ="grey"),"  `plot_select_one_cross(datalist = datalist, dico = dico, \"", var, "\",\"", by_var, "\")` \n\n "))}     else {}

      cnts <- data |>
        ## keep only the variable we need
        tidyr::drop_na(tidyselect::all_of(c(var,by_var))) |>
        # Lump together factor levels into "other"
        dplyr::count(x := forcats::fct_lump_n(factor(.data[[var]]), n = 5),
                     y := forcats::fct_lump_n(factor(.data[[by_var]]), n = 5) ) |>
        dplyr::mutate(p = n/sum(n)) |>
        dplyr::group_by(y) |>
        dplyr::mutate(cumsum = max(cumsum(as.numeric(n))),
                      pcum = n / cumsum)  
       
       ## plot
       require(ggplot2)
       p <- ggplot2::ggplot(cnts, 
                  aes(x= pcum, 
                      y = x)) +
        geom_col(fill = "#0072BC") +
        #geom_label(aes(label = scales::label_percent(accuracy = .01)(pcum)), size = 2) +
        ## Position label differently in the bar in white - outside bar in black
        geom_label( data =   function(x) subset(x, pcum < max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = -0.1 ,
                    vjust = 0.5, 
                    colour = "black", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 3   ) +  
        geom_label( data =   function(x) subset(x, pcum >= max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = 1.1 ,
                    vjust = 0.5, 
                    colour = "white", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 3   ) +   
        scale_x_continuous(labels = scales::label_percent()) +
         
        facet_wrap( ~ y ,  nrow = 3  ,
                      labeller = as_labeller(function(x) label_choiceset(dico = dico,
                                                                      x = by_var)(x))
          ) +
          scale_y_discrete(labels = function(x) {label_choiceset(dico = dico,
                                                            x = var)(x) |>
              stringr::str_wrap(40)}) +
        coord_cartesian(clip = "off") +
        labs(x = NULL, y = NULL,
             title = stringr::str_wrap(label_varname(dico = dico, x = var), 90),
             subtitle = stringr::str_wrap( paste0("Crossed by ", label_varname(dico = dico, x = by_var)), 90),
             caption = glue::glue("Single choice question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
        theme_minimal( base_size = 16) +  
        geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
        theme( panel.grid.major.x  = element_line(color = "#cbcbcb"), 
                 panel.grid.major.y  = element_blank(), 
                 panel.grid.minor = element_blank()    ) +
        theme(plot.title.position = "plot")

        print(p)
    
      }
    } else { }
  } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong> \n\n")}
  # cat("\n\n")
  }
}


```

```{r examples-plot_select_one_cross}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_select_one_cross(datalist = datalist,
              dico = dico, 
              var = "profile.country",
              by_var = "profile.occupation",
              showcode = TRUE
              )
## test if variable are not in the same frame...
plot_select_one_cross(datalist = datalist,
              dico = dico, 
              var = "profile.country",
              by_var = "members.sex",
              showcode = TRUE
              )

```

```{r tests-plot_select_one_cross}
# test_that("plot_select_one_cross works", {
# 
# })
```



## Plotting Select multiple variable with cross-tabulation

```{r function-plot_select_multiple_cross}
#' @title Plotting Select multiple variable with cross tabulation on a second categorical variable
#' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param by_var variable to use for cross tabulation
#' @param showcode display the code
#' @export

plot_select_multiple_cross <- function(datalist = datalist,
                                       dico = dico,
                                       var, 
                                       by_var , 
                                       showcode = FALSE) {
  
  
  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  nr <- sum(!is.na(data[[var]]))
  
   data2 <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = by_var   )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  rr2 <- mean(!is.na(data2[[by_var]]))
  ## Writing report
  # cat("\n")
 # cat(paste("####", label_varname(var)))
  #cat(paste("#### Variable: ", var))
  
  if ( is.nan(rr) | is.nan(rr2) ) {
    cat("<strong style=\"color:#0072BC;\">This variable could not be identified in the dataset</strong>\n\n")
  } else if (  ! (identical(data,data2))  ) {
    # nothing to do - the variable are not in the same frame
    } else {
  
  ## Writing report
  if (rr != 0 & ! (is.nan(rr))  ) { 
    
    if(by_var != "") {
      if( by_var != var ) {
        
          ## Writing code instruction in report
          if( showcode == TRUE) {
             cat(paste0(label_varname(dico = dico,
                                                   x = var), "\n",
                                      fontawesome::fa("far fa-copy", fill ="grey"), "  `plot_select_multiple_cross(datalist = datalist, dico = dico, \"", var, "\",\"", by_var, "\")` \n\n "))}   else {}

        
      cntscross <- data |>
        ## keep only the variable we need 
        tidyr::drop_na( tidyselect::all_of(c(var,by_var))) |>
        ## Separate the var with select_multiple 
        tidyr::separate_rows(.data[[var]], sep = " ") |>
        # Lump together factor levels into "other"
        dplyr::distinct(`X_id`, 
                 !!var := forcats::fct_lump_n(factor(.data[[var]]), n = 5),
                 !!by_var := forcats::fct_lump_n(factor(.data[[by_var]]), n = 5) ) |>
        # Lump together factor levels into "other"
        dplyr::count(x := .data[[var]],
                     y := .data[[by_var]] ) |>
        dplyr::mutate(p = n/sum(n)) |>
        dplyr::group_by(y) |>
        dplyr::mutate(cumsum = max(cumsum(as.numeric(n))),
                      pcum = n / cumsum)  
      ##plot
      
       require(ggplot2)
       p <- ggplot2::ggplot(cntscross, 
                  aes(x= pcum, 
                      y = x)) +
        geom_col(fill = "#0072BC") +
        #geom_label(aes(label = scales::label_percent(accuracy = .01)(pcum)), size = 2) +
        ## Position label differently in the bar in white - outside bar in black
        geom_label( data =   function(x) subset(x, pcum < max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = -0.1 ,
                    vjust = 0.5, 
                    colour = "black", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 3   ) +  
        geom_label( data =   function(x) subset(x, pcum >= max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = 1.1 ,
                    vjust = 0.5, 
                    colour = "white", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 3   ) +   
        scale_x_continuous(labels = scales::label_percent()) +
        facet_wrap( ~ y ,  nrow = 3,
                    labeller = as_labeller(function(x) label_choiceset(dico = dico,
                                                         x= by_var)(x))
                    ) +
        scale_y_discrete(labels = function(x) {label_choiceset(dico = dico,
                                                          x = var)(x) |>
            stringr::str_wrap(40)}) +
        coord_cartesian(clip = "off") +
        labs(x = NULL, y = NULL,
             title = stringr::str_wrap(label_varname(dico = dico, x = var), 90),
             subtitle = stringr::str_wrap( paste0("Crossed by ", label_varname(dico = dico,  x = by_var)), 90),
             caption = glue::glue("Multiple choice question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
        theme_minimal( base_size = 16) +  
        geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
        theme( panel.grid.major.x  = element_line(color = "#cbcbcb"), 
               panel.grid.major.y  = element_blank(), 
               panel.grid.minor = element_blank()    ) +
        theme(plot.title.position = "plot")
      
       print(p)
    }   
    } else { }
  } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong>\n\n")}
  # cat("\n\n")
    
  }
}


```

```{r examples-plot_select_multiple_cross}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_select_multiple_cross(datalist = datalist,
              dico = dico, 
              var = "profile.reason",
              by_var = "location",
              showcode = TRUE)
```

```{r tests-plot_select_multiple_cross}
# test_that("plot_select_multiple_cross works", {
# 
# })
```



## Plotting Numeric variable with cross-tabulation

```{r function-plot_integer_cross}
#' @title Plotting numeric variable
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param by_var variable to use for cross tabulation
#' @param showcode display the code
#' @export

plot_integer_cross <- function(datalist = datalist, 
                         dico = dico,
                         var, 
                         by_var ,
                         showcode = FALSE) {
  
  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  ## Cast just in case...
  data[[var]] <- as.integer(data[[var]])
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  
   data2 <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = by_var   )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  rr2 <- mean(!is.na(data2[[by_var]]))
  ## Writing report
  # cat("\n")
 # cat(paste("####", label_varname(var)))
  #cat(paste("#### Variable: ", var))
  
  if ( is.nan(rr) | is.nan(rr2) ) {
    cat("<strong style=\"color:#0072BC;\">This variable could not be identified in the dataset</strong>\n\n")
  } else if (  ! (identical(data,data2))  ) {
    # nothing to do - the variable are not in the same frame
    } else {
  
  ## Writing report
  if (rr != 0 & ! (is.nan(rr)) ) { 
      ## Writing code instruction in report
      if( showcode == TRUE) {
        cat(paste0(label_varname(dico = dico,
                                                   x = var), "\n",
                                      fontawesome::fa("far fa-copy", fill ="grey"),"  `plot_integer(datalist = datalist, dico = dico, \"", var, "\")` \n\n "))}    else {}
    
    require(ggplot2)
    p <- ggplot2::ggplot(data) + 
      geom_boxplot(aes(x = .data[[var]], y =  .data[[by_var]]), 
                     fill = "#0072BC", 
                     color = "white" 
      ) +
      # scale_y_continuous(labels = scales::label_percent()) +
      labs(x = NULL, y = NULL,
          title = stringr::str_wrap(label_varname(dico = dico, x = var), 90),
          subtitle = stringr::str_wrap( paste0("Crossed by ", label_varname(dico = dico, x = by_var)), 90),
          caption = glue::glue("Numeric response, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
      
      scale_size_area(max_size = 10) +        
      scale_y_discrete(labels = function(x) {label_choiceset(dico = dico,
                                                          x = var)(x) |>
            stringr::str_wrap(40)}) +
      theme_minimal( base_size = 16) +
      geom_hline(yintercept = 0, size = 1.1, colour = "#333333") +
      theme( panel.grid.major.y  = element_line(color = "#cbcbcb"), 
           panel.grid.major.x  = element_blank(), 
           panel.grid.minor = element_blank()    ) +
           theme(plot.title.position = "plot")
    
    print(p)
    
    } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong>\n\n")}
  # cat("\n\n")
  }
}

```

```{r examples-plot_integer_cross}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_integer_cross(datalist = datalist,
              dico = dico, 
              var = "members.age",
              by_var = "members.sex",
              showcode = TRUE)
```

```{r tests-plot_integer_cros}
# test_that("plot_integer_cros works", {
# 
# })
```


## Plotting Correlation

```{r function-plot_correlation}
#' @title Plotting Correlation
#' 
#' @description blbla
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param by_var variable to use for cross tabulation
#' @param showcode display the code
#' @export

plot_correlation <- function(datalist = datalist, 
                      dico = dico,
                      var, 
                      by_var, 
                      showcode = FALSE) {
  
   # ### Testing number of levels for the 2 variables as 'x' and 'y' must have at least 2 levels
   # if ( by_var != var &
   #      (nlevels(as.factor(as.character(formula$target))) > 1 ) &
   #      (nlevels(as.factor(as.character(formula$tested))) > 1 ) &
   #                     
   #      ## If too many levels, the corrogram is not legible...
   #      (nlevels(as.factor(as.character(formula$target))) < 8 ) &
   #      (nlevels(as.factor(as.character(formula$tested))) < 8 ) &
   #      ## May have class with zero value...
   #      n.class == n.class.notnull
   #                     
   #                )
   #                { p.value  <- round(stats::chisq.test(formula$target,formula$tested)$p.value,4)
   #                } else {            }
   #              
   #              ## Subsetting results on test where p-value is below 0.05
   #              chiquare.true <- chiquare.resultall[ chiquare.resultall$p.value <= 0.05, ]
   #              
   #              ### Case there not any positive test
   #              if (p.value <= 0.05 ) {
   #                cat("No significant association found for this question...\n")
   #              } else {
   #                ## now generating correlation plot for each of the dependent.
   # 
   #                 p <-   corrplot::corrplot(stats::chisq.test(
   #                   MainDataFrame$monit.FamiliyLeft,
   #                   MainDataFrame$monit.RouteIncident)$residuals,
   #                is.cor = FALSE, # use for general matrix to convert to Sq form
   #                cl.pos = "n", ## Do not display the color legend
   #                cl.cex = 0.7, # Size of all label
   #                tl.cex = 0.7, # Size of axis label
   #                tl.srt = 45, # string rotation in degrees
   #                tl.col = "black", # color of text label.
   #                addCoef.col = "grey", # add coeff in the chart
   #                number.cex = 3/ncol(stats::chisq.test(MainDataFrame$monit.FamiliyLeft,MainDataFrame$monit.RouteIncident)), # size of coeff
   #                mar = c(0.5,0.5,4, 0.5), ## margin of plots
   #                title = paste0("Correlation between ", , " & ", )) 
   #                 
   #                 print(p)
   # 
   #              }
}

```

```{r examples-plot_correlation}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_correlation(datalist = datalist,
              dico = dico, 
              var = "profile.occupation")
```

```{r tests-plot_correlation}
# test_that("plot_correlation works", {
# 
# })
```

## Multivariate


## Plotting Likert

```{r function-plot_likert}
#' @title Plotting Likert
#' 
#' @description Detect if we have more than 3 questions with the same response options within the same questions group
#' and represent the result using a standard likert plot - build from  https://github.com/jbryer/likert
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @export

#' @title Plotting Likert
#' 
#' @description Detect if we have more than 3 questions with the same response options within the same questions group
#' and represent the result using a standard likert plot - build from  https://github.com/jbryer/likert
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @export

plot_likert <- function(datalist = datalist,
                        dico = dico) {

  require(dplyr)
  require(ggplot2)
  require(likert)
  require(cowplot)
  ## Check the frequency of list_name within each group,
  ## Filter the combination of list and group where we have more than 3 occurrences
  # not taking in account when the appearance is not "label"
  grouplikert <- as.data.frame(dico[1]) |>
    dplyr::filter( type ==  "select_one") |>
    dplyr::filter( appearance !=  "label") |>
    dplyr::group_by( scope, list_name) |>
    dplyr::summarise( cnt= dplyr::n() )|>
    dplyr::filter( cnt >= 2)
  
  if(nrow(grouplikert)  == 0) {
    cat("No potential likert in the form")
    } else {
  

        for (i in 1:nrow(grouplikert)  ) {
          
          ## getting the group and corresponding label
          scopei <-   as.character(grouplikert[i, c("scope")])
          labelgroup <- as.data.frame(dico[1]) |>
            dplyr::filter( name  %in%  c(scopei)) |>
            dplyr::select( label) |>
            dplyr::pull()
          
          ## geting the list_name and corresponding label
          list_namei <- as.character( grouplikert[i, c("list_name")])
          nlevel_likert <- as.data.frame(dico[2]) |>
            dplyr::filter( list_name ==   list_namei) |>
            dplyr::select( name, label)  |>
            dplyr::distinct() 
          labelrecode <- setNames(as.character(nlevel_likert$label), nlevel_likert$name)
          
          ##  Subsetting data - checking levels - and applying label
          var <- as.data.frame(dico[1]) |>
                 dplyr::filter( list_name ==  list_namei &
                                scope == scopei  &
                                appearance !="label" )
          data <-kobo_frame(datalist = datalist, dico = dico, var = var[1, c("name")])
      
          likertframe <- data |>
            ## select only likert variable
            dplyr::select ( tidyselect::any_of( c(var$name)) ) |>
            ## Ensure they all have the same levels as factor
            mutate_all(funs(factor(., levels =c(nlevel_likert$name ))))  |>
            ## Recode variable with the label
            mutate_all(funs(dplyr::recode(., !!!labelrecode)))  |>
            #mutate_all(dplyr::recode( !!!labelrecode)) |>
            ## convert to dataframe to ensure likert() works
            as.data.frame()
          ## Replace with label for the variable 
          names(likertframe) <- var$label
                                        
          # Build likert object
          likertframe.obj <- likert::likert(likertframe)
      
          ## Now generate the plot
        a <- plot(likertframe.obj,
                  #center = 2,
                  wrap= 70) +
          labs(title = labelgroup)+
          # guides(fill=guide_legend(title=NULL),    color=guide_legend(nrow=2, byrow=TRUE))  +
          #unhcrthemes::theme_unhcr(grid="X") +
          theme_minimal( base_size = 16) +
          theme( #plot.title=element_text(size=32, face="bold", color="black"), 
                 #plot.subtitle=element_text(size=19, face="italic", color="black"), 
                #text = element_text(size=22, color = "#333333"), 
                #legend.position="right",legend.direction="vertical"), legend.margin=margin()
                legend.position="bottom",
                legend.box="vertical")
        
        ## Extract the legend to put it fully belwo the main chart
        p1_legend <- cowplot::get_legend(a + 
                                  theme(legend.position="bottom", legend.box="vertical", legend.margin=margin(t = 0, unit='cm')) )
        
        #cowplot::ggdraw(p1_legend)
        print( cowplot::plot_grid(a +  theme(legend.position = 'none'), 
                                  p1_legend ,
                                  nrow = 2, 
                                  rel_heights = c(1, 0.1)))
          
          
        }
    }
}

```

```{r examples-plot_likert}
dicolikert <- kobo_dico( xlsformpath = system.file("form_likert.xlsx", package = "kobocruncher") )
datalistlikert <- kobo_data(datapath = system.file("data_likert.xlsx", package = "kobocruncher") )

plot_likert(datalist = datalistlikert,
              dico = dicolikert)
```

```{r tests-plot_likert}
# test_that("plot_likert works", {
# 
# })
```


## Plotting clusters

 to do....
 
## Plotting prediction

 to do....

## Plotting scores

 to do....


## Plotting Header variable

```{r function-plot_header}
#' @title Output Header
#' 
#' @description Function to add headings within the crunching report - 
#' Headings are by defaults the groups defined in the xlsform - 
#' but can be replaced within the analysis plan by chapter and subchapter
#' 
#' @param dico path to the xlsform file used to colllect the data
#' @param var name of the variable to display
#' @export

plot_header <- function(dico = dico,
                            var) {
  
  requireNamespace("dplyr")
  ## getting header levels
  lvl <- stringr::str_count(var, "\\.")
  
  label <- as.data.frame(dico[1]) |>
           dplyr::filter(name == var) |>
           dplyr::pull(label)

  ## In case the header comes from chapter   
  lbchap <- as.data.frame(dico[4]) |>
            dplyr::filter(name == var) |>
            dplyr::pull(label)

  if(identical(label, character(0)) ) 
    {title <- glue::glue("{lbchap}") } else {
      if(is.na(label)) { title <- glue::glue("({var})") } else 
      { title <- label} 
   } 
  
  # Join multiple strings into a single string.
  hdr <- stringr::str_c(strrep("#", 1+lvl), " ", title, sep = "")
  
  ## Now Printing the headers
  cat("---\n")
  cat("\n\n")
  cat("\n")
  cat(hdr)
  cat("\n\n")
}

```

```{r examples-plot_header}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )

plot_header( dico = dico, 
              var = "profile")
```

```{r tests-plot_header}
# test_that("plot_header works", {
# 
# })
```

# Report generation

## Crunching Variables based on a plan

```{r function-kobo_cruncher}
#' @title Crunch all variables according to the analysis plan 
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico path to the xlsform file used to colllect the data
#' @export
 
kobo_cruncher <- function(datalist = datalist, 
                          dico = dico) {
  
  
  questions <- as.data.frame(dico[4])
  disaggregation <-  c(as.data.frame(dico[1]) |> 
                        dplyr::filter( !(is.na(disaggregation))) |>
                        dplyr::pull(name) )
  
  correlate <-   c(as.data.frame(dico[1]) |> 
                   dplyr::filter( !(is.na(correlate))) |>
                   dplyr::pull(name))
  
  
  ## If disaggregation not included in the function argument then use what's set up in the analysis plan
  if (  length(disaggregation) == 1 ) { 
    if (  disaggregation == "" ) { 
      disaggregation <- as.data.frame(dico[1]) |> 
        dplyr::filter( !(is.na(disaggregation))) |>
        dplyr::pull(name) } }
  

  # If correlate not included in the function argument then use what's set up in the analysis plan
  if (length(correlate) ==1) {
    if (correlate == "") { correlate <- as.data.frame(dico[1])|> 
      dplyr::filter( !(is.na(correlate))) |>
      dplyr::pull(name) }}
  
  ## Looping around the questions as set up in the report plan ###
  for ( i in 1:nrow(questions)) {
      type <-  questions[ i, c("type")]
      name <- questions[ i, c("name")]
      
      ## Univariate analysis ######
      if (type == "begin_group") plot_header(dico = dico, 
                                               var = name)
      
      if (type == "select_one") plot_select_one(datalist = datalist, 
                                                dico = dico,
                                                var = name, 
                                                showcode = TRUE)
      
      if (type == "select_multiple") plot_select_multiple(datalist = datalist,
                                                          dico = dico, 
                                                          var = name, 
                                                          showcode = TRUE)
      
      if (type %in% c("numeric", "integer", "range")) plot_integer(datalist = datalist, 
                                                          dico = dico,
                                                          var = name, 
                                                          showcode = TRUE)
      
      if (type == "text") plot_text(datalist = datalist, 
                                    dico = dico, 
                                    var = name, 
                                    showcode = TRUE)
      
    
       ## Bivariate analysis #####
      if (type == "select_one" &  length(disaggregation)>=1 ) {
        for (disag in disaggregation  ){
          if(disag  != "")
            plot_select_one_cross(datalist = datalist, 
                                  dico = dico,
                                  var = name, 
                                  by_var = disag,
                                  showcode = TRUE) }
      }
      if (type == "select_multiple" &  length(disaggregation)>=1 ) {
        for (disag in disaggregation  ){
          if(disag  != "")
            plot_select_multiple_cross(datalist = datalist, 
                                  dico = dico,
                                  var = name, 
                                  by_var = disag,
                                  showcode = TRUE) }
      }
      if (type %in% c("numeric", "integer") &  length(disaggregation)>=1 ) {
        for (disag in disaggregation  ){
          
          if(disag  != "")
            plot_integer_cross(datalist = datalist, 
                               dico = dico,
                               var = name, 
                               by_var = disag,
                               showcode = TRUE) }
      }
    
    ## Statistical Association  #
      if (type == "select_one" &  length(correlate)>=1 ) {
        for (correl in correlate  ){
          
          if(correl  != "")
            plot_correlation(datalist = datalist, 
                             dico = dico,
                             var = name, 
                             by_var = correl,
                             showcode = TRUE) }
      }
  
  }
}

```

```{r examples-kobo_cruncher}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

kobo_cruncher(datalist = datalist,
              dico = dico)


```

```{r tests-kobo_cruncher}
# test_that("survey_label works", {
# 
# })
```
 

## Report Template A for Automatic Data Exploration

The first RMD template gives an output in HTML for easy navigation - the left menu provides smooth transition.

It includes a function to automatically run throughout all the survey content. During this stage, data cleaning and new variable creation can be performed through iterations

This report also includes each plot syntax so that they can be easily pasted for the second report


```{r template_1_exploration}
#' Initial Template for Automatic Data Exploration
#' The first RMD template gives an output in HTML for easy navigation - the left menu provides smooth transition.
#' It includes a function to automatically run throughout all the survey content. During this stage, data cleaning and new variable creation can be performed through iterations
#'  This report also includes each plot syntax so that they can be easyly pasted for the second report
# usethis::use_rmarkdown_template(
#   template_name = "template_1_exploration",
#   template_dir = NULL,
#   template_description = "Automatic Data Exploration - html",
#   template_create_dir = TRUE
# )


```

## Report Template B for Joint Data Interpretation Session

The second template is used following the systematic data exploration. 
It will generate a powerpoint presentation

See a more detailed presentation of that step here: https://www.youtube.com/watch?v=0jE-Y7g88K4&feature=youtu.be&t=2305 

```{r template_2_interpretation}
#' Second Template to prepare a presentation for the Joint Data Interpretation Session
#' 
# usethis::use_rmarkdown_template(
#   template_name = "template_2_interpretation",
#   template_dir = NULL,
#   template_description = "Joint Data Interpretation",
#   template_create_dir = TRUE
# )

```

## Report Template C for Dissemination and Data Story Telling Template

The last template can be used to take note of the data interpretation session.

It will generate a PDF or an paginated HTML page

```{r template_3_dissemination}
#' Report Template 3 for Dissemination and Data Story Telling Template
#' The last template can be used to take note of the data interpretation session. 
#' It will generate a PDF or an paginated HTML page
# usethis::use_rmarkdown_template(
#   template_name = "template_3_dissemination",
#   template_dir = NULL,
#   template_description = "Data brief and Story Telling",
#   template_create_dir = TRUE
# )



```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_dev.Rmd", vignette_name = "Crunching Function for XlsForm")
```

