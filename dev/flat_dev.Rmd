---
title: "Developing and documenting all functions"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Data examples to demo the package

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.
-->

```{r development-2}
# Run all this chunk in the console directly
# Create "inst/" directory
#dir.create(here::here("inst"))

# Example dataset
# Make your dataset file available to the current Rmd
pkgload::load_all(path = here::here(), export_all = FALSE)

# You will be able to read your example data file in each of your function examples and tests as follows
datapath <- system.file("data.xlsx", package = "kobocruncher")
form <- system.file("sample_xlsform.xlsx", package = "kobocruncher") 
 
```




# Data loading

```{r function-kobo_data}
#' @title Data loading
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @export

kobo_data <- function(datapath) {
   # cat(readxl::excel_sheets(datapath ))
    datalist <- lapply(readxl::excel_sheets(datapath ), function(x) readxl::read_excel(datapath , sheet = x))  
    
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("/", ".", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_001", ".", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_002", ".", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_003", ".", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_004", ".", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_005", ".", colnames(y)); y})
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("_006", ".", colnames(y)); y})
    #names(datalist) <- readxl::excel_sheets(datapath )
    return(datalist)
}

```


```{r examples-kobo_data}
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )
# MainFrame
datalist[1]
# Second Frame
datalist[2]  
```

```{r tests-kobo_data}
# test_that("kobo_data works", {
# 
# })
```

# Extend the xlsform to add instructions for the analysis plan

```{r function-kobo_prepare_form}
#' @name kobo_prepare_form
#' @rdname kobo_prepare_form
#' @title  Prepare XLSform
#'
#' @description  Prepare XLSform by adding instructions for the analysis plan and checking that structure and settings are correct.
#' 
#'  Once those elements are set up, they will be automatically considered during the automatic crunching phase.
#'  An additional worksheet is also created to document the information required for registration on UNHCR CKAN instance http://ridl.unhcr.org
#'  
#'  1. Configuration of how questions are grouped together in the report:
#'     - chapter: by default the crunching report is presented according to the group. Once set, this will replace the original grouping. Only variable defined within a chapter will be displayed in the crunching report.
#' 
#'  2. Configuration for data manipulation:
#'     - clean: define what variable shall be re-categorized during cleaning - a local copy of all levels will be locally saved in order to do the mapping in excel. When the mapping is available, it will be automatically applied to the data. Can be useful to reduce the number of categories.
#'     - anonymise: define what variables to consider to statistical disclosure risk measurement and subsequent data treatment
#'  
#'  3. Configuration of specific charts, visualization and analysis: 
#'  
#'     - disaggregation: define variable to use for visual crosstabulation - functions with "_cross"
#'     - correlate: define the variable to use to explore statistical association - works under certan restrictions (i.e. between 2 categorical variables only): kobo_correlate
#'     - cluster: define variable to generate an unsupervised classification (i.e. hierarchical clustering based on multiple correspondance analysis) kobo_cluster
#'     - predict: define variable to use to generate predictive model, ie.e the target variable and the predictors.  kobo_predict
#'     - mappoint, mappoly: define the variable to use to generate maps - kobo_map
#'  
#' In case if those fields do not yet exist, the function will create dummy column for each one.
#' Also, coloring all rows that have type equal to "begin group", "end group", "begin repeat" or "end repeat" for better legibility
#'
#' @param xlsformpath The full path and filename of the xlsform to be accessed (has to be xlsx file)
#' @param xlsformpathout The full path and filename of the xlsform to be accessed (has to be xlsx file)
#' @param language Optional if the form used multiple languages, indicate the language to use to prepare the analysis plan - check first in your original file -default is  ::english (en)
#'
#' @export 
kobo_prepare_form <- function(xlsformpath,
                              xlsformpathout,
                              language = "::english (en)") {
  
  # Excel Styling Elements
  # To add filters for sheet, we have to set the range for addAutoFilter() function
  # EX: addAutoFilter(sheet1, "A1:P1") --> add a filter on the 1rd row, columns A:P
  # dfref dataframe allows to find 'P' based on number of columns in the sheet, if number of columns equal to 6 then the range will be A1:dfref[6,] -- A1:F1
  dfref <- data.frame(
    key = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256),
    val = c('A1', 'B1', 'C1', 'D1', 'E1', 'F1', 'G1', 'H1', 'I1', 'J1', 'K1', 'L1', 'M1', 'N1', 'O1', 'P1', 'Q1', 'R1', 'S1', 'T1', 'U1', 'V1', 'W1', 'X1', 'Y1', 'Z1', 'AA1', 'AB1', 'AC1', 'AD1', 'AE1', 'AF1', 'AG1', 'AH1', 'AI1', 'AJ1', 'AK1', 'AL1', 'AM1', 'AN1', 'AO1', 'AP1', 'AQ1', 'AR1', 'AS1', 'AT1', 'AU1', 'AV1', 'AW1', 'AX1', 'AY1', 'AZ1', 'BA1', 'BB1', 'BC1', 'BD1', 'BE1', 'BF1', 'BG1', 'BH1', 'BI1', 'BJ1', 'BK1', 'BL1', 'BM1', 'BN1', 'BO1', 'BP1', 'BQ1', 'BR1', 'BS1', 'BT1', 'BU1', 'BV1', 'BW1', 'BX1', 'BY1', 'BZ1', 'CA1', 'CB1', 'CC1', 'CD1', 'CE1', 'CF1', 'CG1', 'CH1', 'CI1', 'CJ1', 'CK1', 'CL1', 'CM1', 'CN1', 'CO1', 'CP1', 'CQ1', 'CR1', 'CS1', 'CT1', 'CU1', 'CV1', 'CW1', 'CX1', 'CY1', 'CZ1', 'DA1', 'DB1', 'DC1', 'DD1', 'DE1', 'DF1', 'DG1', 'DH1', 'DI1', 'DJ1', 'DK1', 'DL1', 'DM1', 'DN1', 'DO1', 'DP1', 'DQ1', 'DR1', 'DS1', 'DT1', 'DU1', 'DV1', 'DW1', 'DX1', 'DY1', 'DZ1', 'EA1', 'EB1', 'EC1', 'ED1', 'EE1', 'EF1', 'EG1', 'EH1', 'EI1', 'EJ1', 'EK1', 'EL1', 'EM1', 'EN1', 'EO1', 'EP1', 'EQ1', 'ER1', 'ES1', 'ET1', 'EU1', 'EV1', 'EW1', 'EX1', 'EY1', 'EZ1', 'FA1', 'FB1', 'FC1', 'FD1', 'FE1', 'FF1', 'FG1', 'FH1', 'FI1', 'FJ1', 'FK1', 'FL1', 'FM1', 'FN1', 'FO1', 'FP1', 'FQ1', 'FR1', 'FS1', 'FT1', 'FU1', 'FV1', 'FW1', 'FX1', 'FY1', 'FZ1', 'GA1', 'GB1', 'GC1', 'GD1', 'GE1', 'GF1', 'GG1', 'GH1', 'GI1', 'GJ1', 'GK1', 'GL1', 'GM1', 'GN1', 'GO1', 'GP1', 'GQ1', 'GR1', 'GS1', 'GT1', 'GU1', 'GV1', 'GW1', 'GX1', 'GY1', 'GZ1', 'HA1', 'HB1', 'HC1', 'HD1', 'HE1', 'HF1', 'HG1', 'HH1', 'HI1', 'HJ1', 'HK1', 'HL1', 'HM1', 'HN1', 'HO1', 'HP1', 'HQ1', 'HR1', 'HS1', 'HT1', 'HU1', 'HV1', 'HW1', 'HX1', 'HY1', 'HZ1', 'IA1', 'IB1', 'IC1', 'ID1', 'IE1', 'IF1', 'IG1', 'IH1', 'II1', 'IJ1', 'IK1', 'IL1', 'IM1', 'IN1', 'IO1', 'IP1', 'IQ1', 'IR1', 'IS1', 'IT1', 'IU1', 'IV1')
  )
  
  #For better legibility create specific styles for rows that defines header, groups and repeat 
  headerSt <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fontSize = 13, fgFill = "grey50",
                                     border = "TopBottom", borderColour = "grey80", borderStyle = "thin")
  cs1 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "black", fgFill = "orange",
                                border = "TopBottom", borderColour = "orange", borderStyle = "thin")
  cs2 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fgFill = "skyblue",
                                border = "TopBottom", borderColour = "skyblue", borderStyle = "thin")    
  
  
  tryCatch({
    
    ## Create a blank workbook
    wb <- openxlsx::createWorkbook()
    
    ### Survey sheet ######################################
    survey <- tryCatch({
      suppressMessages(
        as.data.frame(readxl::read_excel(xlsformpath, sheet = "survey"),
                      stringsAsFactors = FALSE) #read survey sheet from the form
      ) ## avid all the new names message...
      
    }, error = function(err) {
      data.frame( #if it doesn't exist, we need to create empty dataframe with those fields
        type = character(),
        name = character(),
        label = character(),
        labelReport = character(),
        hint = character(),
        hintReport = character(),
        relevant = character(),
        required = character(),
        constraint = character(),
        repeat_count = character(),
        calculation = character(),
        choice_filter = character(),
        read_only = character(),
        default = character(),
        ## Additional variable for analysis plan
        clean = character(),
        anonymise = character(),
        chapter = character(),
        disaggregation = character(),
        correlate = character(),
        cluster = character(),
        predict = character(),
        mappoint = character(),
        mappoly = character(),
        stringsAsFactors = FALSE,
        check.names = F
      )
    })
    
    ## Remove all na column in case...
    survey <- survey |>
      dplyr::select(where(function(x) any(!is.na(x))))
    
    ## Clean the label and hint in relation with the selected language
    names(survey)[tolower(names(survey)) == paste0("label",language )] <- "label"
    names(survey)[tolower(names(survey)) == paste0("hint",language )] <- "hint"
    namesOfSur <- c("type", "name" , "label")
    if (sum(namesOfSur %in% colnames(survey)) != length(namesOfSur)) {
      return(structure('Please make sure the survey sheet haas at minima the following columns: "type", "name" , "label" ', class = "try-error"))
    }
    
    ## Adding variable if not present and checking the content of the variable to build up the analysis plan summary... 
    if ("hint" %in% colnames(survey)) { 
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
    } else {    survey$hint <- ""   }
    if ("chapter" %in% colnames(survey)) { } else { survey$chapter <- ""   }
    if ("correlate" %in% colnames(survey)) {
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
    } else {  survey$correlate <- ""}
    if ("disaggregation" %in% colnames(survey)) { 
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
    } else { survey$disaggregation <- ""  }
    if ("clean" %in% colnames(survey)) { 
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
    } else {  survey$clean <- "" }
    if ("anonymise" %in% colnames(survey)) { 
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
    } else {survey$anonymise <- ""}
    if ("cluster" %in% colnames(survey)) { } else { survey$cluster <- ""}
    if ("predict" %in% colnames(survey)) { 
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
    } else { survey$predict <- ""  }
    if ("mappoint" %in% colnames(survey)) {
      # if(!( levels(as.factor(survey$ )) %in% c(""))) {stop("Not correctly Set up: ")  }
    } else { survey$mappoint <- ""}
    if ("mappoly" %in% colnames(survey)) {    } else { survey$mappoly <- ""}
    
    survey$label.lenght <- nchar(survey$label)
    if ("labelQ" %in% colnames(survey)) {    } else {  survey$labelQ <- survey$label }
    if ("hintQ" %in% colnames(survey)) {    } else { survey$hintQ <- survey$hint}
    
    ### order in user friendly    way
    namesOfSur <- c( "type", "name", "label", "hint", 
                     "chapter",
                     "anonymise",  "clean"     ,
                     "disaggregation", "correlate",
                     "cluster"  , "predict" ,
                     "mappoint",  "mappoly",
                     "label.lenght",
                     "labelQ", "hintQ",
                     "required", "relevant",
                     "constraint", "calculation" )
    namesOfSur <- as.data.frame(namesOfSur) |>
      dplyr::filter(namesOfSur %in% colnames(survey)) |>
      dplyr::pull() 
    survey <- survey[ ,namesOfSur]
    ## need to delete empty rows from the form
    survey <- as.data.frame(survey[!is.na(survey$type), ])
    survey[is.na(survey)] <-  ""
    sheetname <- "survey"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, survey, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(survey), widths = "auto")
    openxlsx::setColWidths(wb, sheetname, cols = 2:3, widths = 30)
    all.cols <- 1:ncol(survey)
    hdr.rows <- 1
    group.rows <- which(stringr::str_detect(survey$type, "group"))+1
    repeat.rows <- which(stringr::str_detect(survey$type, "repeat"))+1
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, all.cols, gridExpand = TRUE)
    openxlsx::addStyle(wb, sheetname, cs1, group.rows, all.cols, gridExpand = TRUE)
    openxlsx::addStyle(wb, sheetname, cs2, repeat.rows, all.cols, gridExpand = TRUE)
    
    ### Choices sheet ######################################
    choices <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "choices"),
                    stringsAsFactors = FALSE) #read survey sheet from the form
    }, error = function(err) {
      data.frame( #if it doesn't exist, we need to create empty dataframe with those fields
        list_name = character(),
        name = character(),
        label = character(),
        labelQ = character(),
        order = character(),
        stringsAsFactors = FALSE,
        check.names = F
      )
    }) 
    ## Rename the variable label
    
    ## Rename the variable label based on language
    names(choices)[tolower(names(choices)) == paste0("label",language )] <- "label"
    
    namesOfCho <- c("list_name", "name", "label")
    if (sum(namesOfCho %in% colnames(choices)) != length(namesOfCho)) {
      return(structure('Please make sure the choices sheet has at minima the following columns:
                        "list_name", "name" , "label"', class = "try-error"))
    }
    choices$labelQ <- choices$label   
    ### add column if not present
    if ("order" %in% colnames(choices)) { } else { choices$order <- ""}
    if ("score" %in% colnames(choices)) {  } else { choices$score <- ""}
    namesOfCho <- c("list_name", "name", "label",  "order", "score","labelQ") 
    namesOfCho <- as.data.frame(namesOfCho) |>
      dplyr::filter(namesOfCho %in% colnames(choices)) |>
      dplyr::pull() 
    choices <- choices[ ,namesOfCho]
    sheetname <- "choices"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, choices, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(choices), widths = "auto")
    openxlsx::setColWidths(wb, sheetname, cols = 2:3, widths = 30)
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(choices), gridExpand = TRUE)
    
    
    ### Settings sheet ######################################
    settings <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "settings"),
                    stringsAsFactors = FALSE)
    }, error = function(err) {
      data.frame(
        form_title  = c("study"),
        form_id  = c("koboID"),
        default_language  = c("::spanish (es)"),
        #form_title = character(),
        #form_id = character(),
        #default_language = character(),
        stringsAsFactors = FALSE
      )
    }) 
    
    if (settings$form_title =="" | is.na(settings$form_title)) { } else {settings$form_title <- "Study"}
    sheetname <- "settings"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, settings, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(settings), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(settings), gridExpand = TRUE)
    
    ### RIDL sheets ######################################
    ridl_schema <- jsonlite::fromJSON("https://raw.githubusercontent.com/okfn/ckanext-unhcr/master/ckanext/unhcr/schemas/dataset.json")
    ridl_dataset_fields <- ridl_schema$dataset_fields # |> tibble::as_tibble()
    ridl_resource_fields <- ridl_schema$resource_fields # |> tibble::as_tibble()
    ridl_choices <-
      ridl_dataset_fields |>
      dplyr::mutate(choices = purrr::map(choices, as.data.frame)) |>
      dplyr::select(field_name, choices) |>
      tidyr::unnest(choices) |>
      dplyr::select(list_name = field_name, name = value, label) |>
      as.data.frame()
    ridl_metadata <-
      ridl_dataset_fields |>
      dplyr::transmute(
        type =
          dplyr::case_when(
            preset == "multiple_select" ~ stringr::str_c("select_multiple", field_name, sep = " "),
            field_name %in% ridl_choices$list_name ~ stringr::str_c("select_one", field_name, sep = " "),
            TRUE ~ "text"),
        name = field_name,
        label,
        required,
        hint = dplyr::if_else(!is.na(help_text), help_text, form_placeholder),
        value = "")
    
    sheetname <- "ridl-metadata"
    if (sheetname %in% readxl::excel_sheets(xlsformpath)) {
      ridl_metadata <-
        ridl_metadata |>
        dplyr::select(-value) |>
        dplyr::left_join(readxl::read_excel(xlsformpath, sheet = sheetname) |> dplyr::select(name, value), by = "name")
    }
    
    sheetname <- "ridl-metadata"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, ridl_metadata, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(ridl_metadata), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(ridl_metadata), gridExpand = TRUE)
    sheetname <- "ridl-choices"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, ridl_choices, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(ridl_choices), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(ridl_choices), gridExpand = TRUE)
    
    ### Saving final ######################################    
    if (file.exists(xlsformpathout)) file.remove(xlsformpathout)
    openxlsx::saveWorkbook(wb, xlsformpathout)
    cat("\n******************** Summary of the Analysis Plan *********************\n \n")
    ## get a summary of what we have
    ## Check Variable lenght
    # if( length(survey$label) )
    ## Do we have chapters? If yes how many?
    ## Do we have anonymisation instructions? If yes, is it correctly set? How many direct identifiers, key variables, sensitive variables
    ## Do we have cleaning instructions? Are they set up for the select_ variable
    ## Do we have disaggregation instructions (yes)? -- Should Are they set up for the select_one variable
    ## Do we have correlate instructions  (yes)? Are they set up for the select_one variable       
    ## Do we have cluster instructions  (yes)? Are they set up for the select_one variable 
    ## Do we have predict instructions  (one unique target, at least 2 predictor)? Are they set up for the select_one variable 
    ## Do we have mappoint, mappoly (yes)? Are they set up for the select_one variable 
    
    
    
  }, error = function(err) {
    print("There was an error in the xlsform preparation step!!! \n\n")
    return(structure(err, class = "try-error"))
  })
  
}

```

```{r tests-kobo_prepare_form}
# test_that("kobo_prepare_form works", {
# 
# })
```






# Prepare data dictionnary

```{r function-kobo_dico}
#' @title Prepare Analysis plan
#' @param xlsformpath path to the xlsform file used to collect the data
#' @export

kobo_dico <- function(xlsformpath) {
   survey <- readxl::read_excel(xlsformpath,   
                                sheet = "survey")
  
  variables <-  survey |>
    ## Rename and use what ever label set is coming first 
    dplyr::rename(label = dplyr::first(starts_with("label")),
                  hint = dplyr::first(starts_with("hint"))) |>
    
    
    # Clean the begin and end in case the _ would be missing...
    dplyr::mutate(type = dplyr::recode(type, 
                                        "begin group" = "begin_group" ,
                                        "end group"   ="end_group",
                                       "begin repeat" = "begin_repeat" ,
                                       "end repeat"   ="end_repeat")) |>
    
    ## spearate the type
    tidyr::separate(type, 
                    into = c("type", "list_name"), 
                    sep = " ") |>
    
    ## Need to add more cleaning in case...
    #dplyr::filter(!(is.na(name))) |>
    #dplyr::filter(!(is.na(label))) |>
    dplyr::filter(!(is.na(type))) |>
    
    # capturing repeat
    dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                                  function (repeatvar, type, name) {
                                                    if (type  == "begin_repeat")  c(repeatvar, name)
                                                    else if (type  == "end_repeat") head(repeatvar, -1)
                                                    else repeatvar
                                                  }, .init = character()) |>tail(-1),
                  ##Apply a function to each element of a list 
                  repeatvar = purrr::map_chr(repeatvar,
                                             stringr::str_c, 
                                             collapse = ".") ,
                  name = dplyr::case_when(repeatvar == "" ~ name,
                                          type == "begin_repeat"~ repeatvar,
                                          TRUE ~ stringr::str_c(repeatvar, name, sep = "."))) |>
                 
    
      # capturing Group
      dplyr::mutate(scope = purrr::accumulate2(type, name,
                                               function (scope, 
                                                         type, 
                                                         name) {
                                                 if (type == "begin_group") 
                                                    c(scope, name)
                                                    else if (type == "end_group") head(scope, -1)
                                                 else scope
                                               }, .init = character()) |> tail(-1),
                    ##Apply a function to each element of a list 
                    scope = purrr::map_chr(scope, 
                                           stringr::str_c, 
                                           collapse = "."),         
                    
                    name = dplyr::case_when(scope == "" ~ name,
                                            type == "begin_group" ~ scope,
                                            TRUE ~ stringr::str_c(scope, name, sep = "."))) 
  
  ## Add dataframe number
  ## Counter..
  variables$dataframenew <- 0
  for (i in 2:nrow(variables)){
    #i <- 10
    #cat( variables[i, c("repeatvar")] )
    if (variables[i, c("repeatvar")] != variables[i-1, c("repeatvar")] &
        variables[i, c("repeatvar")] !="" ) {
      variables[i, c("dataframenew")] <- 1
    } else{
      variables[i, c("dataframenew")] <- 0
    }
  }
   ## Counter..
  variables$dataframecount <- 1
  for (i in 2:nrow(variables)){  
    if (variables[i, c("repeatvar")] != "") {
      variables[i, c("dataframecount")] <- variables[i-1, c("dataframecount")] + variables[i, c("dataframenew")]
    } else{
      variables[i, c("dataframecount")] <- variables[i-1, c("dataframecount")]
    }
    
  }
   ## Framenumber
  variables$dataframe <- 1
  for (i in 2:nrow(variables)){  
    if (variables[i, c("repeatvar")] != "") {
          variables[i, c("dataframe")] <- variables[i, c("dataframecount")] 
        } else{
          variables[i, c("dataframe")] <- 1
        }
   }
  variables$dataframecount <- NULL
  variables$dataframenew <- NULL
  
  

     choices <- readxl::read_excel(xlsformpath,   sheet = "choices")  
     modalities <- choices |>
                   dplyr::rename(label = dplyr::first(matches("^label")))
     
     settings <- readxl::read_excel(xlsformpath,   
                                sheet = "settings")
     
    ## Build dico object as list with both variables and modalities
    return(list( variables, 
                 modalities,
                  settings))
}

```


```{r examples-kobo_dico}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
# Survey
questions <- as.data.frame(dico[1])
knitr::kable(head(questions, 10))
# Choices
responses <- as.data.frame(dico[2])
knitr::kable(head(responses, 10))
# Settings
metadata <- as.data.frame(dico[3])
knitr::kable(head(metadata, 10))
```

# Get frame for a variable

```{r function-kobo_frame}
#' @title get the correct frame for one selected variable - important when havving variables within a repeat
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to collect the data
#' @param var variable
#' @export

kobo_frame <- function(datapath,
                       xlsformpath, 
                       var) {
  
  datalist <- kobo_data(datapath )
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  
  ## Identify the right frame number
  dataframen <- as.data.frame(dico[1]) |>
                  dplyr::filter(name == var) |>
                  dplyr::pull(dataframe)  
  ## Pull the data
  data  <-  datalist[dataframen] |>
              as.data.frame()
  

## get correct id whether the frmae is nested one or not.. 
if ("_id" %in% colnames(data)) { data$X_id <-  data$`_id` } else {  }
if ("_index" %in% colnames(data)) { data$X_id <-  data$`_index` } else {  }
if ("X_index" %in% colnames(data)) { data$X_id <-  data$X_index  } else { }
if ("X_id" %in% colnames(data)) { data$X_id <-  row.names(data)  } else { }
  
  ## Make sure the data actually contain the variable if not put to null
  # if ( var %in% names(data)) {
  #   data <- data
  # }  else {
  #   data <- data.frame()
 # }
    
    return(data )
}

```


```{r examples-kobo_frame}
data <- kobo_frame(datapath = system.file("data.xlsx", package = "kobocruncher"),
                   xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher"),
                   var = "members.sex"   )
knitr::kable(head(data,5))
 
```

# Get the label for a specific variable

```{r function-label_varname}
#' @title Get the label for a specific variable
#' @param xlsformpath path to the xlsform file used to collect the data
#' @param x character with the variable name
#' @export

label_varname <- function(xlsformpath, x) {
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  as.data.frame( dico[1]) |>
    dplyr::filter(name == x) |>
    dplyr::pull(label)
}

```

```{r examples-label_varname}

label_varname(xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              x ="profile.country")

```

```{r tests-label_varname}
# test_that("label_varname works", {
# 
# })
```

# Get interpretation hint for a specific variable

```{r function-label_varhint}
#' @title Get Interpretation hint for a specific variable
#' @param xlsformpath path to the xlsform file used to cole
#' @param x variable
#' @export

label_varhint <- function(xlsformpath, x) {
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  as.data.frame(dico[1]) |>
    dplyr::filter(name == x) |>
    dplyr::pull(hint)
}

```

```{r examples-label_varhint}
label_varhint(xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              x ="profile.country")
```

```{r tests-label_varhint}
# test_that("label_varhintworks", {
# 
# })
```


# Get all the choices labels options for a specific variable

```{r function-label_choiceset}
#' @title Get all the choices labels options for a specific variable
#' @param xlsformpath path to the xlsform file used to cole
#' @param x variable
#' @export

label_choiceset <- function(xlsformpath,
                            x) {
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  lname <- as.data.frame(dico[1]) |>
    dplyr::filter(name == x) |>
    dplyr::pull(list_name)
  
  dict <- 
    as.data.frame(dico[2]) |>
    dplyr::filter(list_name == lname) |> 
    (\(x) purrr::set_names(x$label, x$name))()
  
  function(y) { dict[y] |> tidyr::replace_na("Other") }
}

```

```{r examples-label_choiceset}
label_choiceset(xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
                x="profile.country")
```

```{r tests-label_choiceset}
# test_that("label_choiceset works", {
# 
# })
```

# Get the label for a specific choice if available

```{r function-label_choice}
#' @title Get the label for a specific choice if available
#' @param xlsformpath path to the xlsform file used to cole
#' @param x character with the code for the choice
#' @export

label_choice <- function(xlsformpath, x ) {
   label_choiceset(xlsformpath = xlsformpath, x) %>%
            ## Need to address situation where dictionary is empty
           ## in this case we leave data as is...
          dplyr::mutate( label = dplyr::if_else(is.na(label),name, label) ) %>%
          
          # create a named character object to relabel
          { purrr::set_names(.$label, .$name) } 

}

```

```{r examples-label_choice, eval = FALSE}
label_choice(xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              x = "profile.country")

```

```{r tests-label_choice}
# test_that("label_choice works", {
# 
# })
```




# Plotting Select one variable

```{r function-plot_select_one}
#' @title Plotting Select one variable
#' 
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to cole
#' @param var name of the variable to display
#' @param showcode display the code
#' @export

plot_select_one <- function(datapath  ,
                            xlsformpath  ,
                            var,
                            showcode = FALSE) {

  require("ggplot2")
  
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  ## Get default data source name 
  datasource <- as.character(  dico[3][[1]]$form_title ) 
 
  data <- kobo_frame(datapath = datapath,
                   xlsformpath = xlsformpath,
                   var = var  )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  
  cnts <- data |>
    tidyr::drop_na(tidyselect::all_of(var)) |>
    # Lump together factor levels into "other"
    dplyr::count(x := forcats::fct_lump_n(factor(.data[[var]]), n = 5)) |>
    dplyr::mutate(p = n/sum(n))
  
  ## Manage situation if ordinal variable (i.e. order is set in choices)
  # if (any(!is.na(label_choiceset(xlsformpath = xlsformpath, 
  #                                x = var)$order))) {
  #   cnts <- cnts |>
  #     dplyr::mutate(x = factor(x,
  #                              levels = c(label_choiceset(xlsformpath = xlsformpath,
  #                                                         x  = var)(var), "Other")))
  # } else {
  #   cnts <- cnts |>
  #     dplyr::mutate(x = factor(x,
  #                              levels = x[order(n, decreasing=FALSE)]))
  # }
  
  ## Writing code instruction in report
  if( showcode == TRUE) { cat(paste0( fontawesome::fa_png("far fa-copy", fill ="grey"), "`plot_select_one(datapath = datapath, xlsformpath = xlsformpath, \"", var, "\")` \n\n "))}  else {}
  
  
  ## Put a condition in case there's no record
  if (rr != 0 ) {
    
    ## plot
    require(ggplot2)
    p <- ggplot(cnts, aes(p, x)) +
      geom_col(fill = "#0072BC") +
      
      #geom_label(aes(label = scales::label_percent(accuracy = .01)(p))) +
      ## Position label differently in the bar in white - outside bar in black
      geom_label( data =   function(x) subset(x, p < max(p) / 1.5),
                  aes(label = scales::label_percent(accuracy = .01)(p)),
                  hjust = -0.1 ,
                  vjust = 0.5,
                  colour = "black",
                  fill = NA,
                  label.size = NA,
                  
                  size = 4   ) +
      geom_label( data =   function(x) subset(x, p >= max(p) / 1.5),
                  aes(label = scales::label_percent(accuracy = .01)(p)),
                  hjust = 1.1 ,
                  vjust = 0.5,
                  colour = "white",
                  fill = NA,
                  label.size = NA,
                  
                  size = 4   ) +
      scale_x_continuous(labels = scales::label_percent()) +
      scale_y_discrete(labels = function(x) {label_choiceset(xlsformpath = xlsformpath, x = var)(x) |>
                      stringr::str_wrap(40)}) +
      coord_cartesian(clip = "off") +
      labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(xlsformpath = xlsformpath,
                                                   x = var), 60),
           subtitle = if (!is.na(label_varhint(xlsformpath = xlsformpath,
                                               x= var))){
             stringr::str_wrap(label_varhint(xlsformpath = xlsformpath,
                                             x= var), 70)} else { ""},
           caption = glue::glue("Single choice question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records. \n Source: {datasource}")) +
      theme_minimal( base_size = 15) +
      geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
      theme( panel.grid.major.x  = element_line(color = "#cbcbcb"),
             panel.grid.major.y  = element_blank(),
             panel.grid.minor = element_blank()    ) +
      theme(plot.title.position = "plot")
    
    print(p)
    
  } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong>\n\n")}
  # cat("\n\n")
}

```

```{r examples-plot_select_one}
plot_select_one(datapath = system.file("data.xlsx", package = "kobocruncher"),
              xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              var = "profile.country")
```

```{r tests-plot_select_one}
# test_that("plot_select_one works", {
# 
# })
```


# Plotting Select one variable with Crosstabulation

```{r function-plot_select_one_cross}
#' @title Plotting Select one variable with cross tabulation on a second categorical variable
#' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to cole
#' @param var name of the variable to display
#' @param crosstab variable to use for cross tabulation
#' @param showcode display the code
#' @export

plot_select_one_cross <- function(datapath = datapath,
                            xlsformpath = xlsformpath,
                            var, 
                            crosstab , 
                            showcode = FALSE) {
  
  require("ggplot2")
  
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datapath = datapath,
                   xlsformpath = xlsformpath,
                   var = var  )
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  ## Writing report
  # cat("\n")
 # cat(paste("####", label_varname(var)))
  #cat(paste("#### Variable: ", var))
  ## Put a condition in case there's no record
  if (rr != 0 ) { 
    if(crosstab != "") {
      if( crosstab != var ) {
        
          ## Writing code instruction in report
          if( showcode == TRUE) { 
            cat(paste0( fontawesome::fa_png("far fa-copy", fill ="grey"),"  `plot_select_one_cross(datapath = datapath, xlsformpath = xlsformpath, \"", var, "\",\"", crosstab, "\")` \n\n "))}     else {}

      cnts <- data |>
        ## keep only the variable we need
        tidyr::drop_na(tidyselect::all_of(c(var,crosstab))) |>
        # Lump together factor levels into "other"
        dplyr::count(x := forcats::fct_lump_n(factor(.data[[var]]), n = 5),
                     y := forcats::fct_lump_n(factor(.data[[crosstab]]), n = 5) ) |>
        dplyr::mutate(p = n/sum(n)) |>
        dplyr::group_by(y) |>
        dplyr::mutate(cumsum = max(cumsum(as.numeric(n))),
                      pcum = n / cumsum)  
       
       ## plot
       p <- ggplot(cnts, 
                  aes(x= pcum, 
                      y = x)) +
        geom_col(fill = "#0072BC") +
        #geom_label(aes(label = scales::label_percent(accuracy = .01)(pcum)), size = 2) +
        ## Position label differently in the bar in white - outside bar in black
        geom_label( data =   function(x) subset(x, pcum < max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = -0.1 ,
                    vjust = 0.5, 
                    colour = "black", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 3   ) +  
        geom_label( data =   function(x) subset(x, pcum >= max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = 1.1 ,
                    vjust = 0.5, 
                    colour = "white", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 3   ) +   
        scale_x_continuous(labels = scales::label_percent()) +
         
        facet_wrap( ~ y ,  nrow = 3 # ,
          #             labeller = as_labeller(function(x) label_choice(xlsformpath = xlsformpath, 
          #                                                             choices = choices,
          #                                                             var = crosstab)(x))
          ) +
          # scale_y_discrete(labels = function(x) {label_choice(xlsformpath = xlsformpath, 
          #                                                   choices = choices,
          #                                                   var = var)(x) |>
          #     stringr::str_wrap(40)}) +
        coord_cartesian(clip = "off") +
        labs(x = NULL, y = NULL,
               title = stringr::str_wrap(label_varname(xlsformpath = xlsformpath,
                                                       x = var), 80),
               subtitle = stringr::str_wrap( paste0("Crossed by ", label_varname(xlsformpath = xlsformpath,
                                                                                 x = crosstab)), 80),
               caption = glue::glue("Single choice question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
        theme_minimal( base_size = 13) +  
        geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
        theme( panel.grid.major.x  = element_line(color = "#cbcbcb"), 
                 panel.grid.major.y  = element_blank(), 
                 panel.grid.minor = element_blank()    ) +
        theme(plot.title.position = "plot")

        print(p)
    
      }
    } else { }
  } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong> \n\n")}
  # cat("\n\n")
}


```

```{r examples-plot_select_one_cross}
plot_select_one_cross(datapath = system.file("data.xlsx", package = "kobocruncher"),
              xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              var = "profile.country",
              crosstab = "profile.occupation"
              )
```

```{r tests-plot_select_one_cross}
# test_that("plot_select_one_cross works", {
# 
# })
```



# Plotting Select multiple variable

```{r function-plot_select_multiple}
#' @title Plotting Select multiple variable
#' #' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to cole
#' @param var name of the variable to display
#' @param showcode display the code
#' @export

plot_select_multiple <- function(datapath = datapath, 
                                 xlsformpath = xlsformpath,
                                 var, 
                                 showcode = FALSE) {
  
  require("ggplot2")
  
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datapath = datapath,
                   xlsformpath = xlsformpath,
                   var = var  )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  nr <- sum(!is.na(data[[var]]))
  
  
  cnts <- data |>
    tidyr::drop_na(tidyselect::all_of(var)) |>
    tidyr::separate_rows(.data[[var]], sep = " ") |>
    ## Check if we have _id -  
    
    # Lump together factor levels into "other"
    dplyr::distinct(`X_id`, !!var := forcats::fct_lump_n(factor(.data[[var]]), n = 5)) |>
    dplyr::count(x := .data[[var]]) |>
    dplyr::mutate(p = n/nr)
  
  ## Manage situation if ordinal variable (i.e. order is set in choices)
  # if (any(!is.na(label_choiceset(xlsformpath = xlsformpath,
  #                          x = var)$order))) {
  #   cnts <- cnts |>
  #   dplyr::mutate(x = factor(x, 
  #                            levels = c(label_choiceset(xlsformpath = xlsformpath,
  #                                                         x = var)$name, "Other")))
  #  } else {
  #   cnts <- cnts |>
  #            dplyr::mutate(x = factor(x,  
  #                            levels = x[order(n, decreasing=FALSE)]))
  # }

  ## If not empty
  if (rr != 0 ) {  
    
    ## Writing code instruction in report
    if( showcode == TRUE) {
      cat(paste0(fontawesome::fa_png("far fa-copy", fill ="grey"),"  `plot_select_multiple(datapath = datapath, xlsformpath = xlsformpath, \"", var, "\")` \n\n "))}   else {} 
    
    ## Plot
     p <- ggplot(cnts, aes(p, x)) +
      geom_col(fill = "#0072BC") +
      #geom_label(aes(label = scales::label_percent(accuracy = .01)(p))) + 
      ## Position label differently in the bar in white - outside bar in black
      geom_label( data =   function(x) subset(x, p < max(p) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(p)),
                    hjust = -0.1 ,
                    vjust = 0.5, 
                    colour = "black", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 4   ) +  
      geom_label( data =   function(x) subset(x, p >= max(p) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(p)),
                    hjust = 1.1 ,
                    vjust = 0.5, 
                    colour = "white", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 4   ) +   
      
      scale_x_continuous(labels = scales::label_percent()) +
      # scale_y_discrete(labels = function(x) {label_choice(xlsformpath = xlsformpath,
      #                                                   x = var)(x) |>
      #     stringr::str_wrap(40)}) +
      coord_cartesian(clip = "off") +
      labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(xlsformpath = xlsformpath,
                                                         x= var), 60),
           subtitle = if (!is.na(label_varhint(xlsformpath = xlsformpath,
                                                        x = var))){ 
                     stringr::str_wrap(label_varhint(xlsformpath = xlsformpath,
                                                          x = var), 70)} else { ""},
           caption = glue::glue("Multiple choice question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
      theme_minimal( base_size = 15) + 
      geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
      theme( panel.grid.major.x  = element_line(color = "#cbcbcb"), 
             panel.grid.major.y  = element_blank(), 
             panel.grid.minor = element_blank()    ) +
      theme(plot.title.position = "plot")
     
     
    print(p)
    
    #plot_select_multiple_cross(var,   crosstab)
    
  } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong> \n\n")}
  # cat("\n\n")
}

```

```{r examples-plot_select_multiple}
plot_select_multiple(datapath = system.file("data.xlsx", package = "kobocruncher"),
              xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              var = "profile.reason"
            )
```

```{r tests-plot_select_multiple}
# test_that("plot_select_multiple works", {
# 
# })
```



# Plotting Select multiple variable with cross-tabulation

```{r function-plot_select_multiple_cross}
#' @title Plotting Select multiple variable with cross tabulation on a second categorical variable
#' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to cole
#' @param var name of the variable to display
#' @param crosstab variable to use for cross tabulation
#' @param showcode display the code
#' @export

plot_select_multiple_cross <- function(datapath = datapath,
                                       xlsformpath = xlsformpath,
                                       var, 
                                       crosstab , 
                                       showcode = FALSE) {
  
  
  require("ggplot2")
  
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datapath = datapath,
                   xlsformpath = xlsformpath,
                   var = var  )
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  nr <- sum(!is.na(data[[var]]))
  ## Writing report
  if (rr != 0 ) { 
    
    if(crosstab != "") {
      if( crosstab != var ) {
        
          ## Writing code instruction in report
          if( showcode == TRUE) {
             cat(paste0(fontawesome::fa_png("far fa-copy", fill ="grey"), "  `plot_select_multiple_cross(datapath = datapath, xlsformpath = xlsformpath, \"", var, "\",\"", crosstab, "\")` \n\n "))}   else {}

        
      cntscross <- data |>
        ## keep only the variable we need 
        tidyr::drop_na( tidyselect::all_of(c(var,crosstab))) |>
        ## Separate the var with select_multiple 
        tidyr::separate_rows(.data[[var]], sep = " ") |>
        # Lump together factor levels into "other"
        dplyr::distinct(`X_id`, 
                 !!var := forcats::fct_lump_n(factor(.data[[var]]), n = 5),
                 !!crosstab := forcats::fct_lump_n(factor(.data[[crosstab]]), n = 5) ) |>
        # Lump together factor levels into "other"
        dplyr::count(x := .data[[var]],
                     y := .data[[crosstab]] ) |>
        dplyr::mutate(p = n/sum(n)) |>
        dplyr::group_by(y) |>
        dplyr::mutate(cumsum = max(cumsum(as.numeric(n))),
                      pcum = n / cumsum)  
      ##plot
       p <- ggplot(cntscross, 
                  aes(x= pcum, 
                      y = x)) +
        geom_col(fill = "#0072BC") +
        #geom_label(aes(label = scales::label_percent(accuracy = .01)(pcum)), size = 2) +
        ## Position label differently in the bar in white - outside bar in black
        geom_label( data =   function(x) subset(x, pcum < max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = -0.1 ,
                    vjust = 0.5, 
                    colour = "black", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 3   ) +  
        geom_label( data =   function(x) subset(x, pcum >= max(pcum) / 1.5),
                    aes(label = scales::label_percent(accuracy = .01)(pcum)),
                    hjust = 1.1 ,
                    vjust = 0.5, 
                    colour = "white", 
                    fill = NA, 
                    label.size = NA, 
                     
                    size = 3   ) +   
        scale_x_continuous(labels = scales::label_percent()) +
        facet_wrap( ~ y ,  nrow = 3 #,
                    # labeller = as_labeller(function(x) label_choice(xlsformpath = xlsformpath,
                    #                                      x= crosstab)(x)) 
                    ) +
        # scale_y_discrete(labels = function(x) {label_choice(xlsformpath = xlsformpath,
        #                                                   x = var)(x) |>
        #     stringr::str_wrap(40)}) +
        coord_cartesian(clip = "off") +
        labs(x = NULL, y = NULL,
             title = stringr::str_wrap(label_varname(xlsformpath = xlsformpath, 
                                                         x = var), 80),
             subtitle = stringr::str_wrap( paste0("Crossed by ", label_varname(xlsformpath = xlsformpath,
                                                         x = crosstab)), 80),
             caption = glue::glue("Multiple choice question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
        theme_minimal( base_size = 13) +  
        geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
        theme( panel.grid.major.x  = element_line(color = "#cbcbcb"), 
               panel.grid.major.y  = element_blank(), 
               panel.grid.minor = element_blank()    ) +
        theme(plot.title.position = "plot")
      
       print(p)
    }   
    } else { }
  } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong>\n\n")}
  # cat("\n\n")
}


```

```{r examples-plot_select_multiple_cross}
plot_select_multiple_cross(datapath = system.file("data.xlsx", package = "kobocruncher"),
              xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              var = "profile.reason",
              crosstab = "location")
```

```{r tests-plot_select_multiple_cross}
# test_that("plot_select_multiple_cross works", {
# 
# })
```



# Plotting Numeric variable

```{r function-plot_integer}
#' @title Plotting numeric variable
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to cole
#' @param var name of the variable to display
#' @param showcode display the code
#' @export

plot_integer <- function(datapath = datapath, 
                         xlsformpath = xlsformpath,
                         var, 
                         showcode = FALSE) {
  
  require("ggplot2")
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datapath = datapath,
                   xlsformpath = xlsformpath,
                   var = var  )
  ## Cast just in case...
  data[[var]] <- as.integer(data[[var]])
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  # cat("---\n")
  # cat("\n\n")
  ## Put a condition in case there's no record
  if (rr != 0 ) { 
      ## Writing code instruction in report
      if( showcode == TRUE) {
        cat(paste0(fontawesome::fa_png("far fa-copy", fill ="grey"),"  `plot_integer(datapath = datapath, xlsformpath = xlsformpath, \"", var, "\")` \n\n "))}    else {}
    
    p <- ggplot(data) + 
      geom_histogram(aes(.data[[var]]), 
                     # bins = nclass.FD(na.omit(data[[var]])),
                     fill = "#0072BC", 
                     color = "white" 
      ) +
      # scale_y_continuous(labels = scales::label_percent()) +
      labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(xlsformpath = xlsformpath, 
                                         x = var), 60), 
           subtitle = if (!is.na(label_varhint(xlsformpath = xlsformpath, 
                                                         x = var))){ 
                     stringr::str_wrap(label_varhint(xlsformpath = xlsformpath, 
                                                   x = var), 70)} else { ""},
           caption = glue::glue("Numeric response, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
  
      theme_minimal( base_size = 13) +
      geom_hline(yintercept = 0, size = 1.1, colour = "#333333") +
      theme( panel.grid.major.y  = element_line(color = "#cbcbcb"), 
           panel.grid.major.x  = element_blank(), 
           panel.grid.minor = element_blank()    ) +
           theme(plot.title.position = "plot")
    
    print(p)
    
    } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong>\n\n")}
  # cat("\n\n")
}

```

```{r examples-plot_integer}
plot_integer(datapath = system.file("data.xlsx", package = "kobocruncher"),
              xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              var = "members.age")
```

```{r tests-plot_integer}
# test_that("plot_integer works", {
# 
# })
```


# Plotting Numeric variable with cross-tabulation

```{r function-plot_integer_cross}
#' @title Plotting numeric variable
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to cole
#' @param var name of the variable to display
#' @param crosstab variable to use for cross tabulation
#' @param showcode display the code
#' @export

plot_integer_cross <- function(datapath = datapath, 
                         xlsformpath = xlsformpath,
                         var, 
                         crosstab ,
                         showcode = FALSE) {
  
  require("ggplot2")
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datapath = datapath,
                   xlsformpath = xlsformpath,
                   var = var  )
  ## Cast just in case...
  data[[var]] <- as.integer(data[[var]])
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  # cat("---\n")
  # cat("\n\n")
  ## Put a condition in case there's no record
  if (rr != 0 ) { 
      ## Writing code instruction in report
      if( showcode == TRUE) {
        cat(paste0(fontawesome::fa_png("far fa-copy", fill ="grey"),"  `plot_integer(datapath = datapath, xlsformpath = xlsformpath, \"", var, "\")` \n\n "))}    else {}
    
    p <- ggplot(data) + 
      geom_histogram(aes(.data[[var]]), 
                     # bins = nclass.FD(na.omit(data[[var]])),
                     fill = "#0072BC", 
                     color = "white" 
      ) +
      # scale_y_continuous(labels = scales::label_percent()) +
      labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(xlsformpath = xlsformpath, 
                                         x = var), 60), 
           subtitle = if (!is.na(label_varhint(xlsformpath = xlsformpath, 
                                                         x = var))){ 
                     stringr::str_wrap(label_varhint(xlsformpath = xlsformpath, 
                                                   x = var), 70)} else { ""},
           caption = glue::glue("Numeric response, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
  
      theme_minimal( base_size = 13) +
      geom_hline(yintercept = 0, size = 1.1, colour = "#333333") +
      theme( panel.grid.major.y  = element_line(color = "#cbcbcb"), 
           panel.grid.major.x  = element_blank(), 
           panel.grid.minor = element_blank()    ) +
           theme(plot.title.position = "plot")
    
    print(p)
    
    } else { cat("<strong style=\"color:#0072BC;\">No recorded answers for this specific question!</strong>\n\n")}
  # cat("\n\n")
}

```

```{r examples-plot_integer_cross}
plot_integer_cross(datapath = system.file("data.xlsx", package = "kobocruncher"),
              xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              var = "members.age",
              crosstab = "location")
```

```{r tests-plot_integer_cros}
# test_that("plot_integer_cros works", {
# 
# })
```

# Plotting Open Text variable

```{r function-plot_text}
#' @title Plotting Open Text variables
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to cole
#' @param var name of the variable to display
#' @param showcode display the code
#' @export

plot_text <- function(datapath = datapath, 
                      xlsformpath = xlsformpath,
                      var, 
                      showcode = FALSE) {
  
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  datasource <- as.character(  dico[3][[1]]$form_title ) 
  data <- kobo_frame(datapath = datapath,
                   xlsformpath = xlsformpath,
                   var = var  )
  # cat("---\n")
  # cat("\n\n")
  #cat( stringr::str_wrap(  paste0(  label_varname(var), " (Open Text question)"), 70) )
  # cat(paste("####", label_varname(var)))
  # cat("\n\n")
  #cat("Open Text question\n\n")
  
  rr <- mean(!is.na(data[[var]]))
  require("tm")
  #Replacing /, @ and | with space:
  toSpace <- tm::content_transformer(function (x , pattern ) gsub(pattern, " ", x))  
  # Cleaning the text  #### 
  docs <-  tm::Corpus(tm::VectorSource(data[[var]]))  %>%
            #Text transformation to replace special characters from the text.
            tm::tm_map(., toSpace, "/")  %>%
            tm::tm_map(., toSpace, "@")  %>%
            tm::tm_map(., toSpace, "\\|")  %>%
            # Convert the text to lower case
            tm::tm_map(., content_transformer(tolower))  %>%
            # Remove numbers
            tm::tm_map(., removeNumbers)  %>%
            # Remove punctuations
            tm::tm_map(.,  removePunctuation)  %>%
            # Eliminate extra white spaces
            tm::tm_map(.,  stripWhitespace)  %>%
            # Text stemming - reduces words to their root form.
            tm::tm_map(.,  stemDocument)  %>%
            # Remove common stopwords depending on language
            # The information value of stopwords is near zero due to the fact that they 
            # are so common in a language. Removing this kind of words is useful before
            # further analyses. 
            tm::tm_map(., removeWords, stopwords("english"))  %>%
            # Remove your own stop word
            tm::tm_map(., removeWords, c("blabla1", "blabla2")) 
  
    # Step 4 : Build a term-document matrix ####
    # Table containing the frequency of the words. Column names are words and row names are documents. 
    dtm <- tm::TermDocumentMatrix(docs)
    m <- as.matrix(dtm)
    v <- sort(rowSums(m),decreasing=TRUE)
    d <- data.frame(word = names(v),freq=v)
    #head(d, 10)
  
    ## Put a condition in case there's no record
    if(nrow(d) > 0 ) {
      
        ## Writing code instruction in report
        if( showcode == TRUE) {
          cat(paste0(fontawesome::fa_png("far fa-copy", fill ="grey"),"  `plot_text(datapath = datapath, xlsformpath = xlsformpath, \"", var, "\")`  \n\n"))}   else {}
      
      # Step 5 : Generate the Word cloud  ####
      #The importance of words can be illustrated as a word cloud as follow :
      set.seed(1234)
      wordcloud::wordcloud(words = d$word, # words : the words to be plotted
                                freq = d$freq,  # freq : their frequencies
                                min.freq = 1,  # min.freq : words with frequency below min.freq will not be plotted
                                max.words=200, # max.words : maximum number of words to be plotted
                                random.order=FALSE, # random.order : plot words in random order. If false, they will be plotted in decreasing frequency
                                rot.per=0.25,   # rot.per : proportion words with 90 degree rotation (vertical text)
                                colors= RColorBrewer::brewer.pal(8, "Dark2")) # colors : color words from least to most frequent. Use, for example, colors =black for single color.
    title( main = stringr::str_wrap( label_varname(xlsformpath = xlsformpath, 
                                                  x= var), 70),
           sub = glue::glue("Open Text question \n Source: {datasource}" ))  
    
         
      # p1 <- ggplot(d, 
      #              aes(label = word,
      #                  size = freq,
      #                  color = freq )) +
      #       ggwordcloud::geom_text_wordcloud(area_corr = TRUE,
      #                                        rm_outside = TRUE,
      #                                        eccentricity = 1) +
      #       scale_size_area(max_size = 50) +
      #       # scale_radius(range = c(0, 10),  limits = c(0, NA)) +
      #       scale_color_gradient(low = "darkred", high = "red") +
      #       labs(x = NULL, y = NULL,
      #        title = str_wrap(survey_label(var), 60), 
      #        subtitle = if (!is.na(label_varhint(var))){ 
      #          stringr::str_wrap(label_varhint(var), 70)} else { ""},
      #        caption = glue::glue("Wordcloud displaying an Open Text question, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records")) +
      #   
      #       theme_minimal( base_size = 13)  
      # print(p1)
      
    
  } else { cat("<strong style=\"color:#0072BC;\">No significant text for this specific question!</strong>\n\n")}
  
  # cat("\n\n")
}

```

```{r examples-plot_text}
plot_text(datapath = system.file("data.xlsx", package = "kobocruncher"),
              xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              var = "profile.occupation")
```

```{r tests-plot_text}
# test_that("plot_text works", {
# 
# })
```

# Plotting Correlation

```{r function-plo_correlation}
#' @title Plotting Correlation
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to cole
#' @param var name of the variable to display
#' @param showcode display the code
#' @export

plo_correlation <- function(datapath = datapath, 
                      xlsformpath = xlsformpath,
                      var, 
                      showcode = FALSE) {
  
 
}

```

```{r examples-plo_correlation}
plo_correlation(datapath = system.file("data.xlsx", package = "kobocruncher"),
              xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              var = "profile.occupation")
```

```{r tests-plo_correlation}
# test_that("plo_correlation works", {
# 
# })
```

# Output Header variable

```{r function-output_header}
#' @title Output Header
#' @param xlsformpath path to the xlsform file used to colllect the data
#' @param var name of the variable to display
#' @export

output_header <- function(xlsformpath = xlsformpath,
                            var) {
  dico <-  kobo_dico(xlsformpath = xlsformpath)
  
  ## getting header levels
  lvl <- stringr::str_count(var, "\\.")
  
  label <- as.data.frame(dico[1]) |>
           dplyr::filter(name == var) |>
           dplyr::pull(label)
  title <- if(is.na(label)) glue::glue("({var})") else label
  # Join multiple strings into a single string.
  hdr <- stringr::str_c(strrep("#", 1+lvl), " ", title, sep = "")
  
  ## Now Printing the headers
  cat("---\n")
  cat("\n\n")
  cat("\n")
  cat(hdr)
  cat("\n\n")
}

```

```{r examples-output_header}
output_header( xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              var = "profile")
```

```{r tests-output_header}
# test_that("output_header works", {
# 
# })
```



# Crunching Variable based on type

```{r function-kobo_cruncher}
#' @title Crunch a variable
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' @param xlsformpath path to the xlsform file used to colllect the data
#' @param type type of the variable to display
#' @param name name of the variable to display
#' @param disaggregation vector with the potential variables to use for crosstabulation
#' @param correlate vector with the potential variables to use for testing statistical association
#' @param showcode display the code
#' @export
 
kobo_cruncher <- function(datapath = datapath, 
                          xlsformpath = xlsformpath,
                          type, 
                          name, 
                          disaggregation = "", 
                          correlate = "", 
                          showcode = TRUE) {
  
  if (type == "begin_group") output_header(xlsformpath = xlsformpath, 
                                           var = name)
  
  else if (type == "select_one") plot_select_one(datapath = datapath, 
                                                 xlsformpath = xlsformpath,
                                                 var = name, 
                                                 showcode = TRUE)
  else if (type == "select_multiple") plot_select_multiple(datapath = datapath,
                                                           xlsformpath = xlsformpath, 
                                                           var = name, 
                                                           showcode = TRUE)
  else if (type == "integer") plot_integer(datapath = datapath, 
                                           xlsformpath = xlsformpath,
                                           var = name, 
                                           showcode = TRUE)
  else if (type == "text") plot_text(datapath = datapath, 
                                     xlsformpath = xlsformpath, 
                                     var = name, 
                                     showcode = TRUE)
}

```

```{r examples-kobo_cruncher}
kobo_cruncher(datapath = system.file("data.xlsx", package = "kobocruncher"),
              xlsformpath =  system.file("sample_xlsform.xlsx", package = "kobocruncher"), 
              type = "select_one", 
              name = "profile.country",
              showcode = TRUE)
```

```{r tests-kobo_cruncher}
# test_that("survey_label works", {
# 
# })
```
 

# Report Template 1 for Automatic Data Exploration

The first RMD template gives an output in HTML for easy navigation - the left menu provides smooth transition.

It includes a function to automatically run throughout all the survey content. During this stage, data cleaning and new variable creation can be performed through iterations

This report also includes each plot syntax so that they can be easily pasted for the second report


```{r function-template_1_exploration}
#' Initial Template for Automatic Data Exploration
#' The first RMD template gives an output in HTML for easy navigation - the left menu provides smooth transition.
#' It includes a function to automatically run throughout all the survey content. During this stage, data cleaning and new variable creation can be performed through iterations
#'  This report also includes each plot syntax so that they can be easyly pasted for the second report
#' @importFrom unhcrdesign use_unhcr_bslib
#'
#' @param ... extra parameters to pass to `rmarkdown::html_document`
#' 
#' @return An html report
#'
#' @export

template_1_exploration <- function(...) {
  
  unhcr_theme <- unhcrdesign::use_unhcr_bslib()
  
  rmarkdown::html_document( theme = unhcr_theme,
                            ...)
}

```

# Report Template 2 for Joint Data Interpretation Session

The second template is used following the systematic data exploration. 
It will generate a powerpoint presentation

See a more detailed presentation of that step here: https://www.youtube.com/watch?v=0jE-Y7g88K4&feature=youtu.be&t=2305 

```{r function-template_2_interpretation}
#' Second Template to prepare a presentation for the Joint Data Interpretation Session
#' 
#' See a more detailed presentation of that step here: https://www.youtube.com/watch?v=0jE-Y7g88K4&feature=youtu.be&t=2305  
#'#'
#' @param ... extra parameters to pass to `officedown::rpptx_document`#' 
#' @return A powerpoint report
#'
#' @export

template_2_interpretation <- function(...) {
 # locations of resource files in the package
  pptx_template <- system.file("templates/pptx_template.pptx", package = "kobocruncher")
  officedown::rpptx_document(  reference_doc = pptx_template,  ...  )
}
```

# Report Template 3 for Dissemination and Data Story Telling Template

The last template can be used to take note of the data interpretation session.

It will generate a PDF or an paginated HTML page

```{r function-template_3_dissemination}
#' Report Template 3 for Dissemination and Data Story Telling Template
#' The last template can be used to take note of the data interpretation session. 
#' It will generate a PDF or an paginated HTML page
#' @param back_html Back-cover HTML including contact information
#' @param other_css Add extra css
#' @param number_sections Number section headings
#' @param ... Arguments passed to pagedown::html_paged
#' 
#' @return A pagedown report
#' @export

template_3_dissemination <- function(back_html = TRUE,
                         other_css = NULL,
                         number_sections = FALSE,
                         ...) {
  # base css files
  base_css <- unhcrdesign::use_unhcr_css(c("reset", "color_variables", "fonts"))
  
  # logo css file
  logo_var <- paste0("  --unhcr-logoblue: url(\"", unhcrdesign::use_unhcr_logo(logo = "blue", data_uri = TRUE), "\");")
  logo_css <- tempfile(fileext = ".css")
  writeLines(c(":root {", logo_var, "}"), con = logo_css)

  file.append(base_css, logo_css)

  # specific css files
  paged_base_css <- system.file("css/paged_base.css", package = "kobocruncher")
  paged_simple_css <- system.file("css/paged_simple.css", package = "kobocruncher")

  # html back-cover
  if (back_html) {
    back_html <- system.file("html/back_paged_simple.html", package = "kobocruncher")
  } else {
    back_html <- NULL
  }
  # template
  pagedown::html_paged(
    css = c(base_css, paged_base_css,
            paged_simple_css, other_css),
    includes = list(after_body = back_html),
    number_sections = number_sections,
    ...)
}


```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_dev.Rmd", vignette_name = "Crunching Function for XlsForm")
```

