---
graphics::title: "Developing and documenting all functions"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Data examples to demo the package

<!-- 
 Store your dataset in shiny::a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.
-->

```{r development-2}
# Run all this chunk in the console directly
# Create "inst/" directory
#dir.create(here::here("inst"))

# Example dataset
# Make your dataset file available to the current Rmd
pkgload::load_all(path = here::here(), export_all = FALSE)

# You will be able to read your example data file in each of your function examples and tests as follows
datapath <- system.file("data.xlsx", package = "kobocruncher")
form <- system.file("sample_xlsform.xlsx", package = "kobocruncher") 
 
```



# Preparing objects 

## Data loading

```{r function-kobo_data}
#' @title Data loading
#' @param datapath path to the file with the data format as extracted from kobo with dot as group separator and xml header
#' 
#' @return A "datalist" S3 class object (list) formatted to the specifications of "kobocruncher".
#'  
#' @export
#' @importFrom readxl excel_sheets read_excel
# prefixer::import_from(fun = kobo_data)
  
kobo_data <- function(datapath) {
   # cat(readxl::excel_sheets(datapath ))
  
  datalist <- lapply(readxl::excel_sheets(datapath ), function(x) readxl::read_excel(datapath , sheet = x))  
  
  # Get sheet names
  sheet_names <- readxl::excel_sheets(datapath)  
  ## rename the first sheet as name
  sheet_names[1] <- "main"
  # Rename list elements
  names(datalist) <- sheet_names  
    
    ## In case we do not have the right group separator!
    datalist <- lapply(datalist, function(y) {colnames(y) <- gsub("/", ".", colnames(y)); y})
    
     
    #names(datalist) <- readxl::excel_sheets(datapath )
    
   ## Rebuild  a single key var - parent_index between the main frames and nested ones.. assume a single level of nesting
    datalist[[1]]$parent_index <- datalist[[1]]$'_index'  
    if (length(datalist) >1 ) {
        for (m in 2:length(datalist)) {
        datalist[[m]]$parent_index <- datalist[[m]]$'_parent_index'    }
    }
    class(datalist) <- "datalist" # assigns a "datalist" class to the list. Helpful for later on.
    return(datalist)
}


```


```{r examples-kobo_data}
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )
# MainFrame
datalist[["main"]]
# Second Frame - based on presence of repeat within the form, aka nested or
# hierarchical data structure, etc... 
datalist[["members"]]
```

```{r tests-kobo_data}
# test_that("kobo_data works", {
# 
# })
```

## Extend the xlsform to add instructions for the analysis plan

Now we can extend the xlsform that was used to document key next steps in the data preparation.

```{r function-kobo_prepare_form}

#' @title Prepare XLSform and review Analysis
#' 
#' @description  Prepare XLSform by adding instructions for the analysis plan and checking that structure and settings are correct.
#' This function open the xlsform - extend if required including the excel formatting, 
#' display the analysis plan summary and resave the file at the end. 
#' 
#'  Once those elements are set up, they will be automatically considered during the automatic crunching phase.
#'  An additional worksheet is also created to document the information required for registration on UNHCR CKAN instance http://ridl.unhcr.org
#'  
#'  1. Configuration of how questions are grouped together in the report:
#'     - chapter: by default the crunching report is presented according to the group. Once set, this will replace the original grouping. Only variable defined within a chapter will be displayed in the crunching report. By default chapter will follow the questions sequence - if chapters start with a number that number will overrule the sequence
#'     - subchapter: provides a second level of details below the chapter if sub-chapters start with a number that number will overrule the sequence
#' 
#'  2. Configuration for data manipulation:
#'     - clean: define what variable shall be re-categorized during cleaning - a local copy of all levels will be locally saved in order to do the mapping in excel. When the mapping is available, it will be automatically applied to the data. Can be useful to reduce the number of categories.
#'     - anonymise: define what variables to consider to statistical disclosure risk measurement and subsequent data treatment
#'  
#'  3. Configuration of specific charts, visualization and analysis: 
#'  
#'     - disaggregation: define variable to use for visual cross tabulation - functions with "_cross"
#'     - correlate: define the variable to use to explore statistical association - works under certain restrictions (i.e. between 2 categorical variables only): kobo_correlate
#'     - cluster: define variable to generate an unsupervised classification (i.e. hierarchical clustering based on multiple correspondance analysis) kobo_cluster
#'     - predict: define variable to use to generate predictive model, ie.e the target variable and the predictors.  kobo_predict
#'     - score: define the different dimensions of a score - and used the score set up for the choice test different aggregation approaches
#'     - mappoint, mappoly: define the variable to use to generate maps - kobo_map
#'  
#' In case if those fields do not yet exist, the function will create dummy column for each one.
#' Also, coloring all rows that have type equal to "begin group", "end group", "begin repeat" or "end repeat" for better legibility
#'
#' @param xlsformpath The full path and filename of the xlsform to be accessed (has to be xlsx file)
#' @param xlsformpathout The full path and filename of the xlsform to be accessed (has to be xlsx file)
#' @param label_language Optional if the form used multiple languages, indicate the language to use to prepare the analysis plan - check first in your original file. 
#'    This is strictly based on what is inside your form  for instance `english (en)` , `EspaÃ±ol (es)`, or `spanish (es)`. 
#'    Noe that language encoding description should follow https://xlsform.org/en/#multiple-language-support 
#'    
#'    Do not includ the `::` that comes after the label and that separates it from the language suffix
#'    
#' @param ridl If available, it will pre-fill the RIDL info through what was already recorded there
#' 
#' @importFrom tidyselect where
#' @importFrom dplyr select pull mutate if_else filter transmute case_when left_join
#' @importFrom jsonlite fromJSON
#' @importFrom openxlsx createStyle createWorkbook addWorksheet writeData setColWidths addStyle saveWorkbook
#' @importFrom purrr accumulate2 map_chr map
#' @importFrom readxl read_excel excel_sheets
#' @importFrom stringr str_c str_detect
#' @importFrom tidyr unnest
#' @importFrom utils tail head
#'
#' @export 
#' 
#' 

# prefixer::import_from(fun = kobo_prepare_form)

kobo_prepare_form <- function(xlsformpath,
                              xlsformpathout,
                              label_language = "",
                              ridl = "") {
  
  # Excel Styling Elements
  # To add filters for sheet, we have to set the range for addAutoFilter() function
  # EX: addAutoFilter(sheet1, "A1:P1") --> add a filter on the 1rd row, columns A:P
  # dfref dataframe allows to find 'P' based on number of columns in the sheet, if number of columns equal to 6 then the range will be A1:dfref[6,] -- A1:F1
  dfref <- data.frame(
    key = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256),
    val = c('A1', 'B1', 'C1', 'D1', 'E1', 'F1', 'G1', 'H1', 'I1', 'J1', 'K1', 'L1', 'M1', 'N1', 'O1', 'P1', 'Q1', 'R1', 'S1', 'T1', 'U1', 'V1', 'W1', 'X1', 'Y1', 'Z1', 'AA1', 'AB1', 'AC1', 'AD1', 'AE1', 'AF1', 'AG1', 'AH1', 'AI1', 'AJ1', 'AK1', 'AL1', 'AM1', 'AN1', 'AO1', 'AP1', 'AQ1', 'AR1', 'AS1', 'AT1', 'AU1', 'AV1', 'AW1', 'AX1', 'AY1', 'AZ1', 'BA1', 'BB1', 'BC1', 'BD1', 'BE1', 'BF1', 'BG1', 'BH1', 'BI1', 'BJ1', 'BK1', 'BL1', 'BM1', 'BN1', 'BO1', 'BP1', 'BQ1', 'BR1', 'BS1', 'BT1', 'BU1', 'BV1', 'BW1', 'BX1', 'BY1', 'BZ1', 'CA1', 'CB1', 'CC1', 'CD1', 'CE1', 'CF1', 'CG1', 'CH1', 'CI1', 'CJ1', 'CK1', 'CL1', 'CM1', 'CN1', 'CO1', 'CP1', 'CQ1', 'CR1', 'CS1', 'CT1', 'CU1', 'CV1', 'CW1', 'CX1', 'CY1', 'CZ1', 'DA1', 'DB1', 'DC1', 'DD1', 'DE1', 'DF1', 'DG1', 'DH1', 'DI1', 'DJ1', 'DK1', 'DL1', 'DM1', 'DN1', 'DO1', 'DP1', 'DQ1', 'DR1', 'DS1', 'DT1', 'DU1', 'DV1', 'DW1', 'DX1', 'DY1', 'DZ1', 'EA1', 'EB1', 'EC1', 'ED1', 'EE1', 'EF1', 'EG1', 'EH1', 'EI1', 'EJ1', 'EK1', 'EL1', 'EM1', 'EN1', 'EO1', 'EP1', 'EQ1', 'ER1', 'ES1', 'ET1', 'EU1', 'EV1', 'EW1', 'EX1', 'EY1', 'EZ1', 'FA1', 'FB1', 'FC1', 'FD1', 'FE1', 'FF1', 'FG1', 'FH1', 'FI1', 'FJ1', 'FK1', 'FL1', 'FM1', 'FN1', 'FO1', 'FP1', 'FQ1', 'FR1', 'FS1', 'FT1', 'FU1', 'FV1', 'FW1', 'FX1', 'FY1', 'FZ1', 'GA1', 'GB1', 'GC1', 'GD1', 'GE1', 'GF1', 'GG1', 'GH1', 'GI1', 'GJ1', 'GK1', 'GL1', 'GM1', 'GN1', 'GO1', 'GP1', 'GQ1', 'GR1', 'GS1', 'GT1', 'GU1', 'GV1', 'GW1', 'GX1', 'GY1', 'GZ1', 'HA1', 'HB1', 'HC1', 'HD1', 'HE1', 'HF1', 'HG1', 'HH1', 'HI1', 'HJ1', 'HK1', 'HL1', 'HM1', 'HN1', 'HO1', 'HP1', 'HQ1', 'HR1', 'HS1', 'HT1', 'HU1', 'HV1', 'HW1', 'HX1', 'HY1', 'HZ1', 'IA1', 'IB1', 'IC1', 'ID1', 'IE1', 'IF1', 'IG1', 'IH1', 'II1', 'IJ1', 'IK1', 'IL1', 'IM1', 'IN1', 'IO1', 'IP1', 'IQ1', 'IR1', 'IS1', 'IT1', 'IU1', 'IV1')
  )
  
  #For better legibility create specific styles for rows that defines header
  headerSt <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fontSize = 13, fgFill = "grey50",
                                     border = "TopBottom", borderColour = "grey80", borderStyle = "thin")
  #For better legibility create specific styles for rows that defines groups 
  cs1 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "black", fgFill = "orange",
                                border = "TopBottom", borderColour = "orange", borderStyle = "thin")
  #For better legibility create specific styles for rows that defines repeat 
  cs2 <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fgFill = "skyblue",
                                border = "TopBottom", borderColour = "skyblue", borderStyle = "thin")    
  
  
  tryCatch({
    
    ## Create a blank workbook
    wb <- openxlsx::createWorkbook()
    
        
    ### Settings sheet ----------------------------------->
    settings <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "settings"),
                    stringsAsFactors = FALSE)
    }, error = function(err) {
      data.frame(
        form_title  = c("study"),
        form_id  = c("koboID"),
        default_language  = c("::spanish (es)"),
        #form_title = character(),
        #form_id = character(),
        #default_language = character(),
        stringsAsFactors = FALSE
      )
    }) 
        
    settings <- readxl::read_excel(xlsformpath,  sheet = "settings")
    #form_instance <- as.character(settings$form_title)
    if ("form_title" %in% colnames(settings)) {   } else {   settings$form_title <- ""   }
  
    ## Check if a default language is set up in the settings - and add the correct separator
    # for test settings$default_language <- NULL
    label_language <- ifelse( is.null(label_language),
                              ifelse( is.null(settings$default_language),
                                      label_language,
                                      paste0("::",settings$default_language)),
                              paste0("::",label_language))
    if (settings$form_title =="" | is.na(settings$form_title)) { } else {settings$form_title <- "Study"}

    
    
    ### Survey sheet  ----------------------------------->
    survey <- tryCatch({
      suppressMessages(
        as.data.frame(readxl::read_excel(xlsformpath, sheet = "survey"),
                      stringsAsFactors = FALSE) #read survey sheet from the form
      ) ## avid all the new names message...
      
    }, error = function(err) {
      data.frame( #if it doesn't exist, we need to create empty dataframe with those fields
        type = character(),
        name = character(),
        label = character(),
        labelQ = character(),
        hint = character(),
        hintQ = character(),
        relevant = character(),
        required = character(),
        constraint = character(),
        appareance = character(),
        repeat_count = character(),
        calculation = character(),
        choice_filter = character(),
        read_only = character(),
        default = character(),
        ## Additional variable for analysis plan
        clean = character(),
        anonymise = character(),
        chapter = character(),
        disaggregation = character(),
        correlate = character(),
        cluster = character(),
        predict = character(),
        mappoint = character(),
        mappoly = character(),
        stringsAsFactors = FALSE,
        check.names = F
      )
    })
    

    
    
    ## Remove all na column in case...
    survey <- survey |>
      dplyr::select(where(function(x) any(!is.na(x))))
    
    ## Clean the label and hint in relation with the selected language
    names(survey)[tolower(names(survey)) == tolower(paste0("label",label_language) )] <- "label"
    names(survey)[tolower(names(survey)) == tolower(paste0("hint",label_language) )] <- "hint"

    
    ## Adding variable if not present and checking the content of the variable to build up the analysis plan summary... 
    if ("hint" %in% colnames(survey)) {   } else {    survey$hint <- ""   }
    if ("appareance" %in% colnames(survey)) {   } else {    survey$appareance <- ""   }
    if ("chapter" %in% colnames(survey)) { } else { survey$chapter <- ""   }
    if ("subchapter" %in% colnames(survey)) { } else { survey$subchapter <- ""   }
    if ("correlate" %in% colnames(survey)) {    } else {  survey$correlate <- ""}
    if ("disaggregation" %in% colnames(survey)) { } else { survey$disaggregation <- ""  }
    if ("clean" %in% colnames(survey)) {     } else {  survey$clean <- "" }
    if ("anonymise" %in% colnames(survey)) {     } else {survey$anonymise <- ""}
    if ("cluster" %in% colnames(survey)) { } else { survey$cluster <- ""}
    if ("predict" %in% colnames(survey)) {     } else { survey$predict <- ""  }
    if ("score" %in% colnames(survey)) {     } else { survey$score <- ""  }
    if ("mappoint" %in% colnames(survey)) {    } else { survey$mappoint <- ""}
    if ("mappoly" %in% colnames(survey)) {    } else { survey$mappoly <- ""}
    survey$label.lenght <- nchar(survey$label)
    ## add the full name that will be used by functions
    survey$fullname <- survey |> 
       # capturing repeat, group and rebuilding full name
          dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                                        function (repeatvar, type, name) {
                                                          if (type  == "begin_repeat")  c(repeatvar, name)
                                                          else if (type  == "end_repeat") utils::head(repeatvar, -1)
                                                          else repeatvar
                                                        }, .init = character()) |> utils::tail(-1) ,  
                        ##Apply a function to each element of a list 
                        repeatvar = purrr::map_chr(repeatvar,
                                                   stringr::str_c, 
                                                   collapse = ".") ,
                        
                        ## Build the scope
                        scope = purrr::accumulate2(type, name,
                                                   function (scope, 
                                                             type, 
                                                             name ) {
                                                     
                          ## Rebuild variable name based potential combination of sequence   
                          if (type == "begin_group")  c(scope, name )
                          else if (type == "begin_repeat")  c(scope, name )
                          else if (type  == "end_group") utils::head(scope, -1)
                          else if (type  == "end_repeat") utils::head(scope, -1)
                          else scope
                               }, .init = character()) |> 
                            utils::tail(-1) ,
                        ##Apply a function to each element of a list 
                        scope = purrr::map_chr(scope,
                                               stringr::str_c,
                                               collapse = ".") ,
                        name =  dplyr::if_else(scope == "", name, paste0(scope,".",name)  ) ,
                        repeatvar = dplyr::if_else(repeatvar == "", "main", repeatvar  ))  |>
                    dplyr::pull(name)
    if ("labelQ" %in% colnames(survey)) {    } else {  survey$labelQ <- survey$label }
    if ("hintQ" %in% colnames(survey)) {    } else { survey$hintQ <- survey$hint}
    
    ### order in user friendly    way
    namesOfSur <- c( "type", "name", "label", "hint", 
                     "chapter", "subchapter",
                     "anonymise",  "clean"     ,
                     "disaggregation", "correlate",
                     "cluster"  , "predict" ,"score" ,
                     "mappoint",  "mappoly",
                     "label.lenght", "fullname",
                     "labelQ", "hintQ",
                     "required", "relevant",
                     "constraint", "calculation","appareance" )
    namesOfSur <- as.data.frame(namesOfSur) |>
      dplyr::filter(namesOfSur %in% colnames(survey)) |>
      dplyr::pull() 
    survey <- survey[ ,namesOfSur]
    ## need to delete empty rows from the form
    survey <- as.data.frame(survey[!is.na(survey$type), ])
    survey[is.na(survey)] <-  ""
    sheetname <- "survey"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, survey, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(survey), widths = "auto")
    openxlsx::setColWidths(wb, sheetname, cols = 2:3, widths = 30)
    all.cols <- 1:ncol(survey)
    hdr.rows <- 1
    group.rows <- which(stringr::str_detect(survey$type, "group"))+1
    repeat.rows <- which(stringr::str_detect(survey$type, "repeat"))+1
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, all.cols, gridExpand = TRUE)
    openxlsx::addStyle(wb, sheetname, cs1, group.rows, all.cols, gridExpand = TRUE)
    openxlsx::addStyle(wb, sheetname, cs2, repeat.rows, all.cols, gridExpand = TRUE)
    
    ### Choices sheet ----------------------------------->
    choices <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "choices"),
                    stringsAsFactors = FALSE) #read survey sheet from the form
    }, error = function(err) {
      data.frame( #if it doesn't exist, we need to create empty dataframe with those fields
        list_name = character(),
        name = character(),
        label = character(),
        labelQ = character(),
        order = character(),
        stringsAsFactors = FALSE,
        check.names = F
      )
    }) 
    ## Rename the variable label
    
    ## Rename the variable label based on language
    names(choices)[tolower(names(choices)) == tolower(paste0("label",label_language) )] <- "label"
    
    namesOfCho <- c("list_name", "name", "label")
    if (sum(namesOfCho %in% colnames(choices)) != length(namesOfCho)) {
      return(structure('Please make sure the choices sheet has at minima the following columns:
                        "list_name", "name" , "label"', class = "try-error"))
    }
    
    choices$label.lenght <- nchar(choices$label)
    choices$labelQ <- choices$label   
    ### add column if not present
    if ("order" %in% colnames(choices)) { } else { choices$order <- ""}
    if ("score" %in% colnames(choices)) {  } else { choices$score <- ""}
    namesOfCho <- c("list_name", "name", "label",  "order", "score","label.lenght","labelQ") 
    namesOfCho <- as.data.frame(namesOfCho) |>
      dplyr::filter(namesOfCho %in% colnames(choices)) |>
      dplyr::pull() 
    choices <- choices[ ,namesOfCho]
    sheetname <- "choices"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, choices, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(choices), widths = "auto")
    openxlsx::setColWidths(wb, sheetname, cols = 2:3, widths = 30)
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(choices), gridExpand = TRUE)
    
     ### settings sheets ----------------------------------->
    sheetname <- "settings"
    all.cols <- 1:ncol(settings)
    hdr.rows <- 1
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, settings, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(settings), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(settings), gridExpand = TRUE)
    
    ### RIDL sheets ----------------------------------->
    ridl_schema <- jsonlite::fromJSON("https://raw.githubusercontent.com/okfn/ckanext-unhcr/master/ckanext/unhcr/schemas/dataset.json")
    ridl_dataset_fields <- ridl_schema$dataset_fields # |> tibble::as_tibble()
    ridl_resource_fields <- ridl_schema$resource_fields # |> tibble::as_tibble()
    ridl_choices <-
      ridl_dataset_fields |>
      dplyr::mutate(choices = purrr::map(choices, as.data.frame)) |>
      dplyr::select(field_name, choices) |>
      tidyr::unnest(choices) |>
      dplyr::select(list_name = field_name, name = value, label) |>
      as.data.frame()
    ridl_metadata <-
      ridl_dataset_fields |>
      dplyr::transmute(
        type =
          dplyr::case_when(
            preset == "multiple_select" ~ stringr::str_c("select_multiple", field_name, sep = " "),
            field_name %in% ridl_choices$list_name ~ stringr::str_c("select_one", field_name, sep = " "),
            TRUE ~ "text"),
        name = field_name,
        label,
        required,
        hint = dplyr::if_else(!is.na(help_text), help_text, form_placeholder),
        value = "")
    
    sheetname <- "ridl-metadata"
    if (sheetname %in% readxl::excel_sheets(xlsformpath)) {
      ridl_metadata <-
        ridl_metadata |>
        dplyr::select(-value) |>
        dplyr::left_join(readxl::read_excel(xlsformpath, sheet = sheetname) |> dplyr::select(name, value), by = "name")
    }
    
    sheetname <- "ridl-metadata"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, ridl_metadata, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(ridl_metadata), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(ridl_metadata), gridExpand = TRUE)
    sheetname <- "ridl-choices"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, ridl_choices, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(ridl_choices), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(ridl_choices), gridExpand = TRUE)
    
    
    
    ###  indicator sheet  ----------------------------------->
    indicator <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath, sheet = "indicator"),stringsAsFactors = FALSE)
    }, error = function(err) {
      data.frame(
        type = character(),
        name = character(),
        label = character(),
        list_name = character(),
        hint = character(),
        repeatvar = character(),
        calculation = character(),
        chapter = character(),
        subchapter = character(),
        disaggregation = character(),
        correlate = character(),
        cluster = character(),
        predict = character(),
        score = character(),
        mappoint = character(),
        mappoly = character(),
        stringsAsFactors = FALSE
      )
     }
    )
        if ("type" %in% colnames(indicator)) {   } else {    indicator$type <- ""   }
        if ("name" %in% colnames(indicator)) {   } else {    indicator$name <- ""   }
        if ("label" %in% colnames(indicator)) {   } else {    indicator$label <- ""   }
        if ("list_name" %in% colnames(indicator)) {   } else {    indicator$list_name <- ""   }
        if ("hint" %in% colnames(indicator)) {   } else {    indicator$hint <- ""   }
        if ("repeatvar" %in% colnames(indicator)) { } else { indicator$repeatvar <- ""   }
        if ("calculation" %in% colnames(indicator)) { } else { indicator$calculation <- ""   }
        if ("chapter" %in% colnames(indicator)) { } else { indicator$chapter <- ""   }
        if ("subchapter" %in% colnames(indicator)) { } else { indicator$subchapter <- ""   }
        if ("correlate" %in% colnames(indicator)) {    } else {  indicator$correlate <- ""}
        if ("disaggregation" %in% colnames(indicator)) { } else { indicator$disaggregation <- ""  }
        if ("cluster" %in% colnames(indicator)) { } else { indicator$cluster <- ""}
        if ("predict" %in% colnames(indicator)) {     } else { indicator$predict <- ""  }
        if ("score" %in% colnames(indicator)) {     } else { indicator$score <- ""  }
        if ("mappoint" %in% colnames(indicator)) {    } else { indicator$mappoint <- ""}
        if ("mappoly" %in% colnames(indicator)) {    } else { indicator$mappoly <- ""}

    indicator <- indicator[ ,c("type","name","label", "list_name", "hint",
                               "repeatvar", "calculation",
                               "chapter","subchapter", "disaggregation", "correlate",
                                "cluster", "predict", "score", "mappoint", "mappoly")]
    sheetname <- "indicator"
    openxlsx::addWorksheet(wb, sheetname)
    openxlsx::writeData(wb, sheetname, indicator, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(indicator), widths = "auto")
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(indicator), gridExpand = TRUE)

    
    
    ### Saving final ######################################    
    if (file.exists(xlsformpathout)) file.remove(xlsformpathout)
    openxlsx::saveWorkbook(wb, xlsformpathout)
    
    
    
    
    

    
    
    
  }, error = function(err) {
    print("There was an error in the xlsform preparation step!!! \n\n")
    return(structure(err, class = "try-error"))
  })
  
}

```

```{r examples-kobo_prepare_form}
# kobo_prepare_form(xlsformpath = system.file("form.xlsx", package = "kobocruncher"),
#                   xlsformpathout = "form_with_plan.xlsx",
#                   label_language = "")
```

```{r tests-kobo_prepare_form}
# test_that("kobo_prepare_form works", {
# 
# })
```

## Prepare data dictionnary

```{r function-kobo_dico}
#' @title Prepare Analysis plan
#' @param xlsformpath path to the (extended) xlsform file used to collect the data
#' 
#' @importFrom dplyr mutate filter rename first recode if_else matches distinct row_number arrange left_join bind_rows summarise group_by case_when select
#' @importFrom purrr accumulate2 map_chr
#' @importFrom readxl read_excel
#' @importFrom stringr str_c
#' @importFrom tidyr separate
#' @importFrom tidyselect starts_with matches
#' @importFrom utils tail head
#' 
#' @return A "kobodico" S3 class object (list) formatted to the specifications of "kobocruncher".
#' @export


# prefixer::import_from(fun = kobo_dico)

kobo_dico <- function(xlsformpath) {
   survey <- readxl::read_excel(xlsformpath,   
                                sheet = "survey")
  
   ## variables  ----------------------------------->
  variables <-  survey |>
    ## Rename and use what ever label set is coming first 
    dplyr::rename(label = dplyr::first(tidyselect::starts_with("label")),
                  hint = dplyr::first(tidyselect::starts_with("hint"))) |>
    
    
    # Clean the begin and end in case the _ would be missing...
    dplyr::mutate(type = dplyr::recode(type, 
                                        "begin group" = "begin_group" ,
                                        "end group"   ="end_group",
                                       "begin repeat" = "begin_repeat" ,
                                       "end repeat"   ="end_repeat")) |>
    
    ## separate the type
    tidyr::separate(type, 
                        into = c("type", "list_name"), 
                        sep = " ",
                        fill = "right")   |>
    
    ## Need to add more cleaning in case...
    #dplyr::filter(!(is.na(name))) |>
    #dplyr::filter(!(is.na(label))) |>
    dplyr::filter(!(is.na(type))) |>
    
   # capturing repeat, group and rebuilding full name
    dplyr::mutate(repeatvar  = purrr::accumulate2(type, name,
                                                  function (repeatvar, type, name) {
                                                    if (type  == "begin_repeat")  c(repeatvar, name)
                                                    else if (type  == "end_repeat") utils::head(repeatvar, -1)
                                                    else repeatvar
                                                  }, .init = character()) |> utils::tail(-1) ,  
                  ##Apply a function to each element of a list 
                  repeatvar = purrr::map_chr(repeatvar,
                                             stringr::str_c, 
                                             collapse = ".") ,
                  
                  ## Build the scope
                  scope = purrr::accumulate2(type, name,
                                             function (scope, 
                                                       type, 
                                                       name ) {
                                               
                    ## Rebuild variable name based potential combination of sequence   
                    if (type == "begin_group")  c(scope, name )
                    else if (type == "begin_repeat")  c(scope, name )
                    else if (type  == "end_group") utils::head(scope, -1)
                    else if (type  == "end_repeat") utils::head(scope, -1)
                    else scope
                         }, .init = character()) |> 
                      utils::tail(-1) ,
                  ##Apply a function to each element of a list 
                  scope = purrr::map_chr(scope,
                                         stringr::str_c,
                                         collapse = ".") ,
                  name =  dplyr::if_else(scope == "", name, paste0(scope,".",name)  ) ,
                  repeatvar = dplyr::if_else(repeatvar == "", "main", repeatvar  )) 
  
  
  ## Fix when we have calculate variable - either numeric or select_one
  
  
  
    if ("chapter" %in% colnames(variables)) { } else {  variables$chapter <- NA  }
    if ("subchapter" %in% colnames( variables)) { } else {  variables$subchapter <- NA   }
    if ("disaggregation" %in% colnames(variables)) { } else {  variables$disaggregation <- NA  }
    if ("correlate" %in% colnames( variables)) { } else {  variables$correlate <- NA   }  
  
  # Adding the appearance variable that will be used for likert charts
  # to check and check and remove label appearance 
    if ("appearance" %in% colnames(variables)) {   } else {   variables$appearance <- ""  }
  

     choices <- readxl::read_excel(xlsformpath,   sheet = "choices")  
    if ("order" %in% colnames( choices)) { } else {  choices$order <- NA   }
     modalities <- choices |>
                   dplyr::rename(label = dplyr::first(dplyr::matches("^label")))
     
     settings <- readxl::read_excel(xlsformpath,   
                                sheet = "settings")
     
     ### Building the plan ######
     ## Build the question order for the crunching report
     if (  nrow(as.data.frame(variables)|> dplyr::filter(! is.na(chapter)))  > 1 ) {
       
       
      ## Reinsert chapter and subchapter as begin_group
       subchapterorder <- as.data.frame(variables) |>
          dplyr::distinct(chapter, subchapter) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::mutate( subchapternum = dplyr::row_number())
        
        plansub  <- as.data.frame(variables) |>
            dplyr::filter(! is.na(chapter) ) |>
           dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
           dplyr::group_by( chapter, subchapter) |>
           dplyr::summarise( type = "begin_group",
                      name =  "labelsub.chapter" ) |>
           dplyr::mutate( label = subchapter) |>
           dplyr::bind_rows(as.data.frame(variables) |>
                              dplyr::filter(! is.na(chapter) ) |>
                              dplyr::filter( ! type  %in% c("begin_group", "end_group") ) ) |>
           dplyr::left_join(subchapterorder, by = c("chapter", "subchapter")) |>
           #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
           dplyr::arrange(subchapternum)  |>
          dplyr::mutate( labelsub.chapter = paste0("labelsub.chapter" , subchapternum ) ) |>
          dplyr::mutate(  name= dplyr::case_when(
              name == "labelsub.chapter" ~ labelsub.chapter ,
              TRUE ~ name) )
        
        chapterorder <- as.data.frame(variables) |>
          dplyr::distinct(chapter) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::mutate( chapternum = dplyr::row_number())
        
        plan  <- as.data.frame(variables) |>
          dplyr::filter(! is.na(chapter) ) |>
          dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
          dplyr::group_by( chapter) |>
          dplyr::summarise( type = "begin_group",
                            name = "labelchapter" ) |>
           dplyr::mutate( label = chapter) |>
          dplyr::bind_rows(plansub ) |>
          dplyr::left_join(chapterorder, by = c("chapter" )) |>
          #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
          dplyr::arrange(chapternum) |>
          dplyr::mutate( labelchapter = paste0("labelchapter" , chapternum ) ) |>
          dplyr::mutate(  name= dplyr::case_when(
              name == "labelchapter" ~ labelchapter ,
              TRUE ~ name) ) |>
          dplyr::select( type, label,name) |>
          ## Remove all componnnents without label in case subchapter are not defined
          dplyr::filter( ! (is.na(label)))
        
        } else { 
        plan <- as.data.frame(variables) |>
          dplyr::select(type, label,name)|>
          dplyr::filter( ! type  %in% c("note",  "end_group") )
       }
       
     ## adding indicators  ----------------------------------->
    indicator <- tryCatch({
      as.data.frame(readxl::read_excel(xlsformpath,   
                                sheet = "indicator"),stringsAsFactors = FALSE)
        }, error = function(err) {
          data.frame(
            type = character(),
            name = character(),
            label = character(),
            list_name = character(),
            hint = character(),
            repeatvar = character(),
            calculation = character(),
            chapter = character(),
            subchapter = character(),
            disaggregation = character(),
            correlate = character(),
            cluster = character(),
            predict = character(),
            score = character(),
            mappoint = character(),
            mappoly = character(),
            stringsAsFactors = FALSE
          )
         }
        )
        if ("type" %in% colnames(indicator)) {   } else {    indicator$type <- ""   }
        if ("name" %in% colnames(indicator)) {   } else {    indicator$name <- ""   }
        if ("label" %in% colnames(indicator)) {   } else {    indicator$label <- ""   }
        if ("list_name" %in% colnames(indicator)) {   } else {    indicator$list_name <- ""   }
        if ("hint" %in% colnames(indicator)) {   } else {    indicator$hint <- ""   }
        if ("repeatvar" %in% colnames(indicator)) { } else { indicator$repeatvar <- ""   }
        if ("calculation" %in% colnames(indicator)) { } else { indicator$calculation <- ""   }
        if ("chapter" %in% colnames(indicator)) { } else { indicator$chapter <- ""   }
        if ("subchapter" %in% colnames(indicator)) { } else { indicator$subchapter <- ""   }
        if ("correlate" %in% colnames(indicator)) {    } else {  indicator$correlate <- ""}
        if ("disaggregation" %in% colnames(indicator)) { } else { indicator$disaggregation <- ""  }
        if ("cluster" %in% colnames(indicator)) { } else { indicator$cluster <- ""}
        if ("predict" %in% colnames(indicator)) {     } else { indicator$predict <- ""  }
        if ("score" %in% colnames(indicator)) {     } else { indicator$score <- ""  }
        if ("mappoint" %in% colnames(indicator)) {    } else { indicator$mappoint <- ""}
        if ("mappoly" %in% colnames(indicator)) {    } else { indicator$mappoly <- ""}
    
        indicator <- indicator[ ,c("type","name","label", "list_name", "hint",
                                   "repeatvar", "calculation",
                                   "chapter","subchapter", "disaggregation", "correlate",
                                    "cluster", "predict", "score", "mappoint", "mappoly")]
     
     
     
    dico <- list( variables = variables, 
                  modalities = modalities,
                  settings = settings,
                  plan = plan,
                  indicator = indicator)
    class(dico) <- "kobodico" # assigns a "kobodico" class to the list. Helpful for later on. 
    ## Build dico object as list with both variables and modalities
    
     
    #cat("\n******************** Summary of the Analysis Plan *********************\n \n")
    ## get a summary of what we have to inform user
    ## Check Variable lenght
    # if( length(survey$label) )
    ## Do we have chapters? If yes how many?
    ## Do we have anonymisation instructions? If yes, is it correctly set? How many direct identifiers, key variables, sensitive variables
    ## Do we have cleaning instructions? Are they set up for the select_ variable
    ## Do we have disaggregation instructions (yes)? -- Should Are they set up for the select_one variable
    ## Do we have correlate instructions  (yes)? Are they set up for the select_one variable       
    ## Do we have cluster instructions  (yes)? Are they set up for the select_one variable 
    ## Do we have predict instructions  (one unique target, at least 2 predictor)? Are they set up for the select_one variable 
    ## Do we have mappoint, mappoly (yes)? Are they set up for the select_one variable 
    
    
    
    return(dico )
}

```

```{r examples-kobo_dico}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
# Survey
questions <- as.data.frame(dico[["variables"]])
knitr::kable(utils::head(questions, 10))
# Choices
responses <- as.data.frame(dico[["modalities"]])
knitr::kable(utils::head(responses, 10))
# Settings
metadata <- as.data.frame(dico[["settings"]])
knitr::kable(utils::head(metadata, 10))
# Report ToC
toc <- as.data.frame(dico[["plan"]])
knitr::kable(utils::head(toc, 10))
# Indicator
indicator <- as.data.frame(dico[["indicator"]])
knitr::kable(utils::head(indicator, 10))
```

# Data Processing

## Indicator Calculation

Indicator calculation 

```{r function-kobo_indicator}
#' @title Apply existing documented indicators and add new ones
#' 
#' @description The function goes through steps:
#'   1 - load the indicators, 
#'   2 - append the one from inidcatoradd if any, 
#'   3 - apply the indicator, i.e. do the calculation,
#'   4 - re-save all the working indicator definition within the extended xlsform  
#'   5 - bind the new indicators in the dictionary in order to use the
#'        kobo_frame() function for further plotting 
#'   6 - rebuild the plan if indicators are allocated to chapter, subchapter 
#'   
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param indicatoradd a list containing all key information to add a calculated 
#'                indicator within the analysis plan
#' @param xlsformpath path to the (extended) xlsform file used to collect the data
#' @param xlsformpathout path to save the xlsform file with newly added indicators
#' @param showcode display the code
#' 
#' @importFrom purrr modify_at
#' @importFrom dplyr mutate distinct filter
#' @importFrom tidyselect everything 
#' 
#' @return expanded object that includes both the expanded dico and datalist
#' 
#' @export  

kobo_indicator <- function(datalist,
                       dico, 
                       xlsformpath,
                       xlsformpathout,
                       indicatoradd = NULL,
                        showcode = FALSE) {

#   1 - load the indicators ---->
indicator <- as.data.frame(dico[["indicator"]])  
if(!'type' %in% names(indicator)) indicator <- indicator |> tibble::add_column(type = NA)
if(!'name' %in% names(indicator)) indicator <- indicator |> tibble::add_column(name = NA)
if(!'label' %in% names(indicator)) indicator <- indicator |> tibble::add_column(label = NA)
if(!'list_name' %in% names(indicator)) indicator <- indicator |> tibble::add_column(list_name = NA)
if(!'hint' %in% names(indicator)) indicator <- indicator |> tibble::add_column(hint = NA)
if(!'repeatvar' %in% names(indicator)) indicator <- indicator |> tibble::add_column(repeatvar = NA)
if(!'calculation' %in% names(indicator)) indicator <- indicator |> tibble::add_column(calculation = NA)
if(!'chapter' %in% names(indicator)) indicator <- indicator |> tibble::add_column(chapter = NA)
if(!'subchapter' %in% names(indicator)) indicator <- indicator |> tibble::add_column(subchapter = NA)
if(!'correlate' %in% names(indicator)) indicator <- indicator |> tibble::add_column(correlate  = NA)
if(!'disaggregation' %in% names(indicator)) indicator <- indicator |> tibble::add_column(disaggregation = NA)
if(!'cluster' %in% names(indicator)) indicator <- indicator |> tibble::add_column(cluster  = NA)
if(!'predict' %in% names(indicator)) indicator <- indicator |> tibble::add_column(predict = NA)
if(!'score' %in% names(indicator)) indicator <- indicator |> tibble::add_column(score = NA)
if(!'mappoint' %in% names(indicator)) indicator <- indicator |> tibble::add_column(mappoint  = NA)
if(!'mappoly' %in% names(indicator)) indicator <- indicator |> tibble::add_column(mappoly  = NA)
    
indicator <- indicator[ ,c("type","name","label", "list_name", "hint",
                               "repeatvar", "calculation",
                               "chapter","subchapter", "disaggregation", "correlate",
                               "cluster", "predict", "score", "mappoint", "mappoly")] %>%
            dplyr::mutate(dplyr::across(tidyselect::everything(), as.character))
    
  #   2 - append the one from inidicatoradd if any---->
  if( ! (is.null(indicatoradd) )) {
    
  ## todo check the structure of indicatoradd...  
    
    ## If only one indicator got added
    if (class(indicatoradd ) ==  "character") {
       indicatoradded <- as.data.frame(t(indicatoradd)) |> 
                         dplyr::select ( - tidyselect::starts_with("labels.") ) }
    
    
    ## If multiples indicators got added  
    if (class(indicatoradd ) ==  "list") {
        indicatoradded <- as.data.frame(t(indicatoradd[[1]])) |> 
                         dplyr::select ( - tidyselect::starts_with("labels.") ) 
        for (i in 2:length(indicatoradd)) {
          #print(indicatoradd[[i]])
          indicatoradded <- dplyr::bind_rows(indicatoradded,
                                             as.data.frame(t(indicatoradd[[i]] )) |> 
                                  dplyr::select ( - tidyselect::starts_with("labels.") ))  }
       }
    
    ## Now get everything together - the one from the log and the new one..
    if( nrow(indicatoradded)>0) {
      indicator <-  dplyr::bind_rows(indicator, indicatoradded )
        }
      }
  
    ## To do get the modalities variable aka labels.. to add in the dico modalites for relabeling...


    ### Remove duplicate in case a user add an indicator that was already in the xlsform
     indicator  <- indicator |>
                    dplyr::distinct()
  
    #   3 - apply all the indicators, i.e. do the calculation ---->
  if(nrow(indicator) == 0 ){
    
     cat("no calculated indicators has been defined... \n") 
    } else {
      
    for (i in 1:nrow(indicator)) {
      # i <- 1
      var_name <- paste0(indicator[i, "name"])    
      
      ## Sanitize indicator name in case there's a pb and inform the user...
      indicator[i, "name"] <- gsub( "\\.|/|\\-|\\(|\\)|\"|\\s" , "" , var_name )
      if(var_name != paste0(indicator[i, "name"]) ){ cat( paste0("The indicator name got sanitized from ", 
                                                                  var_name , " to ", 
                                                                  paste0(indicator[i, "name"])  ))}
      
      var_name <- paste0(indicator[i, "name"]) 
      label_name <- paste0(indicator[i, "label"])
      repeatvar_name <- paste0(indicator[i, "repeatvar"])
      
      ## Bug fix specific to window - linebreak are not well recognised..
      # calc_name <- paste0(indicator[i, "calculation"])
      calc_name <-stringr::str_replace_all( paste0(indicator[i, "calculation"]), "[\r\n]" , "\n")
      
      
     # cat( paste0(var_name, " - frame: ", frame_name," - calc: ", calc_name, "\n"))
      indicrun <- parse(text=paste0("datalist[[\"",
                                    repeatvar_name ,
                                    "\"]]$",
                                    var_name, " <- ",
                                    calc_name, "") )
      
        ## Writing code instruction in report
       if( showcode == TRUE) { 
         cat(paste0("\n ### Executing Command for: ",label_name," \n", indicrun, "\n"))}  else {}
  
      ## Will throw and error in case of pb -- to do - add bettter error catching to inform users.. 
      eval(indicrun)
    }

# 4 - Now re-save all the working indicator definition within the extended xlsform  ---->
    wb <- openxlsx::loadWorkbook(xlsformpath)
    sheetname <- "indicator"
    ## In case the indicator worksheet has not been added, do it now
    if ( !("indicator" %in% openxlsx::getSheetNames(xlsformpath)) ) {   openxlsx::addWorksheet(wb, sheetname) }
    openxlsx::writeData(wb, sheetname, indicator, withFilter = TRUE)
    openxlsx::setColWidths(wb, sheetname, cols = 1:ncol(indicator), widths = "auto")
    
    #For better legibility create specific styles for rows that defines header
    headerSt <- openxlsx::createStyle( textDecoration = "bold", fontColour = "white", fontSize = 13, fgFill = "grey50",
                                       border = "TopBottom", borderColour = "grey80", borderStyle = "thin")
    
    hdr.rows <- 1
    openxlsx::addStyle(wb, sheetname, headerSt, hdr.rows, 1:ncol(indicator), gridExpand = TRUE) 
    if (file.exists(xlsformpathout)) file.remove(xlsformpathout)
        openxlsx::saveWorkbook(wb, xlsformpathout)

# 5 - bind the new indicators in the dictionary in order to use the kobo_frame() function for further plotting ---->
    dico <- dico |>
          purrr::modify_at(1, ~ dplyr::bind_rows(dico[["variables"]], indicator ))
    
    # avoid duplicate 
    dico[["variables"]] <- dico[["variables"]]  |> dplyr::distinct()
    ## and also replace the indicator registry...
    dico[["indicator"]] <- indicator
   #View( dico1[[1]])
    
    
# 6 - rebuild the plan if indicators are allocated to chapter, subchapter ---->
    variables <- as.data.frame(dico[["variables"]])
    if (  nrow(as.data.frame(variables)|> dplyr::filter(! is.na(chapter)))  > 1 ) {
      
      
      ## Reinsert chapter and subchapter as begin_group
      subchapterorder <- as.data.frame(variables) |>
        dplyr::distinct(chapter, subchapter) |>
        dplyr::filter(! is.na(chapter) ) |>
        dplyr::mutate( subchapternum = dplyr::row_number())
      
      plansub  <- as.data.frame(variables) |>
        dplyr::filter(! is.na(chapter) ) |>
        dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
        dplyr::group_by( chapter, subchapter) |>
        dplyr::summarise( type = "begin_group",
                          name =  "labelsub.chapter" ) |>
        dplyr::mutate( label = subchapter) |>
        dplyr::bind_rows(as.data.frame(variables) |>
                           dplyr::filter(! is.na(chapter) ) |>
                           dplyr::filter( ! type  %in% c("begin_group", "end_group") ) ) |>
        dplyr::left_join(subchapterorder, by = c("chapter", "subchapter")) |>
        #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
        dplyr::arrange(subchapternum)  |>
        dplyr::mutate( labelsub.chapter = paste0("labelsub.chapter" , subchapternum ) ) |>
        dplyr::mutate(  name= dplyr::case_when(
          name == "labelsub.chapter" ~ labelsub.chapter ,
          TRUE ~ name) )
      
      chapterorder <- as.data.frame(variables) |>
        dplyr::distinct(chapter) |>
        dplyr::filter(! is.na(chapter) ) |>
        dplyr::mutate( chapternum = dplyr::row_number())
      
      dico <- dico |>
        purrr::modify_at(4, ~ as.data.frame(variables) |>
        dplyr::filter(! is.na(chapter) ) |>
        dplyr::filter( ! type  %in% c("begin_group", "end_group") )  |>
        dplyr::group_by( chapter) |>
        dplyr::summarise( type = "begin_group",
                          name = "labelchapter" ) |>
        dplyr::mutate( label = chapter) |>
        dplyr::bind_rows(plansub ) |>
        dplyr::left_join(chapterorder, by = c("chapter" )) |>
        #dplyr::mutate_at(vars( ), ~replace(., is.na(.) , '')) %>%
        dplyr::arrange(chapternum) |>
        dplyr::mutate( labelchapter = paste0("labelchapter" , chapternum ) ) |>
        dplyr::mutate(  name= dplyr::case_when(
          name == "labelchapter" ~ labelchapter ,
          TRUE ~ name) ) |>
        dplyr::select( type, label,name) ) 
      
    } else { 
      dico <- dico |>
        purrr::modify_at(4, ~  as.data.frame(variables) |>
        dplyr::select(type, label,name)|>
        dplyr::filter( ! type  %in% c("note",  "end_group") )) 
    }
    
    dico[["plan"]]  <- dico[["plan"]]    |>
          ## Remove all components without label in case subchapter are not defined
          dplyr::filter( ! (is.na(label)))
    
    }
    
  return(expanded <- list (dico= dico, 
                           datalist= datalist))
}

```

```{r examples-kobo_indicator}
xlsformpath <- system.file("sample_xlsform.xlsx", package = "kobocruncher")
xlsformpathout <- "sample_xlsform_withindic.xlsx"

dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

## Check if we add no indicator
expanded  <- kobo_indicator(datalist = datalist,
                            dico = dico,
                            indicatoradd = NULL ,
                            xlsformpath = xlsformpath,
                            xlsformpathout = xlsformpathout)


## Example 1: Simple dummy filter
indicatoradd <- c(  name =  "inColombia",
                    type = "select_one",
                    label = "Is from Colombia",
                    repeatvar = "main",
                    calculation = "dplyr::if_else(datalist[[\"main\"]]$profile.country ==\"COL\", \"yes\",\"no\")")

expanded  <- kobo_indicator(datalist = datalist,
                    dico = dico,
                 indicatoradd = indicatoradd ,
                 xlsformpath = xlsformpath,
                 xlsformpathout = xlsformpathout)
## Replace existing
dico <- expanded[["dico"]]
datalist <- expanded[["datalist"]]

## Check my new indicator
table(datalist[[1]]$inColombia, useNA = "ifany")



## Example 2: calculation on nested elements and build an indicator list
indicatoradd2 <- c(  name =  "hasfemalemembers",
              type = "select_one",
              label = "HH has female members ",
              repeatvar = "main",
              calculation = "datalist[[\"members\"]] |>
                            dplyr::select( members.sex, parent_index) |>
                            tidyr::gather(  parent_index, members.sex) |>
                            dplyr::count(parent_index, members.sex) |>
                            tidyr::spread(members.sex, n, fill = 0)  |>
                           dplyr::select( female)")

indicatorall <- list(indicatoradd, indicatoradd2  ) 

expanded  <- kobo_indicator(datalist = datalist,
                    dico = dico,
                 indicatoradd = indicatorall ,
                 xlsformpath = xlsformpath,
                 xlsformpathout = xlsformpathout)
## Replace existing
dico <- expanded[["dico"]]
datalist <- expanded[["datalist"]]


## Check my new indicator
table(datalist[[1]]$hasfemalemembers, useNA = "ifany")

#   Example of calculations:
#   
#   1. Create a filters on specific criteria
#   'dplyr::if_else(datalist[["main"]]$variable =="criteria", "yes","no")'
#   
#   
#   2. Ratio between 2 numeric variable
#   'datalist[["main"]]$varnum1 / datalist[["main"]]$varnum2'
#   
#   
#   3. Calculation on date - month between data and now calculated in months
#   'lubridate::interval( datalist[["main"]]$datetocheck, 
#                         lubridate::today()) %/%  months(1)'
#   
#   4. Discretization of numeric variable according to quintile
#   'Hmisc::cut2(datalist[["main"]]$varnum, g =5)'
#   
#   5. Discretization of numeric variable according to fixed break - 
#   for instance case size from integer to categoric
#   'cut(datalist[["main"]]$casesize, breaks = c(0, 1, 2, 3,5,30), 
#   labels = c("Case.size.1", "Case.size.2", "Case.size.3", 
#   "Case.size.4.5", "Case.size.6.or.more" ), include.lowest=TRUE)'
#   
#   6. Aggregate variable from nested frame (aka within repeat) to parent table
#   'datalist[["members"]] |>
#       dplyr::select( members.sex, parent_index) |>
#       tidyr::gather(  parent_index, members.sex) |>
#       dplyr::count(parent_index, members.sex) |>
#       tidyr::spread(members.sex, n, fill = 0)  |>
#       dplyr::select( female)'
 
```

## Weight the dataset
    
```{r function-kobo_weight}
#' Weight the dataset
#' 
#' In the absence of  survey data weighting, there's a risk over or under-represent certain demographic segments compared to their true level in the whole population.
#' 
#' The use of weights in survey analysis compensates for this differential representation, thus producing estimates that relate to the target population.
#' Weights vary due to differential sampling rates because of oversampling and because response and coverage rates vary across sub populations (specifically hard-to-reach demographic groups). The term weighting refers to the  different amounts of load or emphasis we give to each individual survey response. Responses from a type of person who is very rare will get greater emphasis in the final results. In contrast, respondents who represent common types of people will be de-emphasized. 
#' Weighting are also important for the anonymization process
#' 
#' This functions perform the following:
#'  * look for element in the dico object that starts with weight_
#'  * Check the structure of this weight and identify what type of weight it is
#'    (cluster or strata)
#'  * transform each related frame into a survey object  
#'  * inform user about the weighting that is applied
#'  
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' 
#' @return datalist with applied weight
#' 
#' @export
# kobo_weight <- function(){
#     
# }
```
  
```{r example-kobo_weight}
#kobo_weight()
```
  
```{r tests-kobo_weight}
#test_that("kobo_weight works", {   expect_true(inherits(kobo_weight, "function")) })
```

## Assess Disclosure Risk

to do....

```{r function-kobo_anonymise}
#' @title Assess Statistical disclosure risk based on an intrusions scenario
#' 
#' @description  When personal data is being collected, performing basic de-identification (i.e. removal of direct identifiers) and assessing risk of re-identification (i.e. using indirect identifiers to re-identify individuals) is a key sep to perform in order to be able to share the data with multiple analyst.
#' 
#' The initial step consist in defining potential intrusion scenario.
#'  This suppose to document the anonymise cell for each variable
#'
#' \tabular{rrrrrr}{
#'   \strong{Type}    \tab \strong{Description}  \cr
#'   ----------------\tab----------- \cr
#'   \strong{Direct_identifier}     \tab	Can be directly used to identify an individual. E.g. Name, Address, Date of birth, Telephone number, GPS location \cr
#'   \strong{Quasi_identifier}     \tab	Can be used to identify individuals when it is joined with other information. E.g. Age, Salary, Next of kin, School name, Place of work \cr
#'   \strong{Sensitive_information}  \tab & Community identifiable information	Might not identify an individual but could put an individual or group at risk. E.g. Gender, Ethnicity, Religious belief 
#' }
#'
#'  Direct identifiers will be automatically removed from the data.
#'  The function will perform the measurement of various statistical disclosure risk measurement
#'  for the selected quasi_identifier and sensitive_information.
#'  
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @export

kobo_anonymise <- function(datalist,
                       dico) {

#   1 - load the indicators, 
  indicator <- as.data.frame(dico[[4]])  
#   2 - append the one from inidcatoradd if any,
  
#   3 - apply the indicator, i.e. do the calculation,
#   4 - re-save all the working indicator definition within the extended xlsform  
#   5 - bind the new indicators in the dictionary in order to use the kobo_frame() function for further plotting 
#   6 - rebuild the plan if indicators are allocated to chapter, subchapter 
  
  with_anonymise <- list( datalist, dico)
    
    return(with_anonymise)
}

```


```{r examples-kobo_anonymise}
# dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
# datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )
# 
# kobo_anonymise(datalist = datalist,
#                    dico = dico,
#                 indicatoradd = indicatoradd   )


 
```

# Labeling functions

## Get the correct frame for a specific variable

```{r function-kobo_frame}
#' @title get the correct frame for one selected variable - important when having variables within a repeat
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var variable
#' @export
# prefixer::import_from(fun = kobo_dico)

kobo_frame <- function(datalist,
                       dico, 
                       var) {
  
  ## Identify the right frame number
  dataframen <- as.data.frame(dico[["variables"]]) |>
                  dplyr::filter(name == var) |>
                  dplyr::pull(repeatvar) 
  
  # if (nrow(dataframen) > 1) { 
  #   cat( paste0( "It seems the variable name: ",
  #                         var, 
  #                         " is duplicated. Check your indicator calculation.\n")
  #                )
  #   } else {
          
         # dataframe <- dataframen |>
          #        dplyr::pull(repeatvar) 
          
          
          ## Pull the data
          data  <-  datalist[[dataframen]] |>
                      as.data.frame()
          
        ## get correct id whether the frame is nested one or not.. 
        if ("_id" %in% colnames(data)) { data$X_id <-  data$`_id` } else {  }
        if ("_index" %in% colnames(data)) { data$X_id <-  data$`_index` } else {  }
        if ("X_index" %in% colnames(data)) { data$X_id <-  data$X_index  } else { }
        if ("X_id" %in% colnames(data)) { data$X_id <-  row.names(data)  } else { }
          
          ## Make sure the data actually contain the variable if not put to null
         if ( var %in% names(data)) {
           data <- data
         }  else {
           data <- data.frame( type = character())
           names(data)[1] <- var  
          
         }
            
            return(data )
   # }      
}



```

```{r examples-kobo_frame}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = "members.sex"   )
knitr::kable(utils::head(data,5))
 
```


```{r tests-kobo_frame}
# Unit test for kobo_frame()

# context("kobo_frame()")
# 
# test_that("kobo_frame() should return a data frame", {
#   expect_is(kobo_frame(datalist, dico, var), "data.frame") 
# })
# 
# test_that("kobo_frame() should contain the variable specified", {
#   expect_true(var %in% names(kobo_frame(datalist, dico, var)))
# })
# 
# test_that("kobo_frame() should contain an X_id column", {
#   expect_true("X_id" %in% names(kobo_frame(datalist, dico, var)))
# })

```


## Get the label for a specific variable

```{r function-label_varname}
#' @title Get the label for a specific variable
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param x character with the variable name
#' @export

# prefixer::import_from(fun = kobo_dico)


label_varname <- function(dico, x) {
  as.data.frame( dico[["variables"]]) |>
    dplyr::filter(name == x) |>
    dplyr::pull(label)
}




```

```{r examples-label_varname}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )

label_varname(dico = dico, 
              x ="profile.country")

```

```{r tests-label_varname}

# # Unit Test
# 
# test_that("label_varname() returns the correct label for a given variable name", {
#   # Create a test dictionary
#   dico <- list(variables = data_frame(name = c("var1", "var2"),
#                                       label = c("Variable 1", "Variable 2")))
#   
#   # Test that label_varname() returns the correct label
#   expect_equal(label_varname(dico, "var1"), "Variable 1")
#   expect_equal(label_varname(dico, "var2"), "Variable 2")
# })

# test_that("label_varname works", {
# 
# })
```

## Get interpretation hint for a specific variable

```{r function-label_varhint}
#' @title Get Interpretation hint for a specific variable
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param x variable
#' @export

# prefixer::import_from(fun = kobo_dico)
label_varhint <- function(dico, x) {
  as.data.frame(dico[["variables"]]) |>
    dplyr::filter(name == x) |>
    dplyr::pull(hint)
}



```

```{r examples-label_varhint}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )

label_varhint(dico = dico, 
              x ="profile.country")
```

```{r tests-label_varhint}

# # Unit Test
# context("label_varhint")
# test_that("label_varhint returns the correct hint for a given variable", {
#   dico <- list(variables = data.frame(name = c("x", "y"), hint = c("This is x", "This is y")))
#   expect_equal(label_varhint(dico, "x"), "This is x")
# })

# test_that("label_varhintworks", {
# 
# })
```

## Get all the choices labels options for a specific variable

```{r function-label_choiceset}
#' @title Get all the choices labels options for a specific variable if available
#' 
#' @description This labeling function ia function factory - https://adv-r.hadley.nz/function-factories.html
#' The output of this function is actually a function
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param x variable
#' @export

# prefixer::import_from(fun = kobo_dico)


label_choiceset <- function(dico,
                            x) {
  lname <- as.data.frame(dico[["variables"]]) |>
    dplyr::filter(name == x) |>
    dplyr::pull(list_name)
  
  dict <- 
    as.data.frame(dico[[2]]) |>
    dplyr::filter(list_name == lname) |> 
    (\(x) purrr::set_names(x$label, x$name))()
  
#  function(y) { dict[y] |> tidyr::replace_na("Other") }
 # function(y) { dplyr::if_else(is.na(dict[y]), y, dict[y]) }
  function(y) { ifelse(is.na(dict[y]), y, dict[y]) }

}



```

```{r examples-label_choiceset}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = "profile.country"   )

label_choiceset(dico = dico, 
                x="profile.country")(data$profile.country)

## Test when there's no dictionnary
data$profile.occupation
label_choiceset(dico = dico, 
                x="profile.occupation")(data$profile.occupation)


label_choiceset(dico = dico, 
                x="profile.occupation")(data$profile.occupation)

```

```{r tests-label_choiceset}

# # Unit test for label_choiceset
# 
# context("label_choiceset")
# 
# test_that("label_choiceset returns the correct labels", {
#   dico <- list(variables = data.frame(name = c("x"),
#                                       list_name = "list"),
#                list = data.frame(name = c("a", "b"),
#                                  label = c("apple", "banana"),
#                                  list_name = "list"))
#   expect_equal(label_choiceset(dico, "x")("a"), "apple")
#   expect_equal(label_choiceset(dico, "x")("b"), "banana")
#   expect_equal(label_choiceset(dico, "x")("c"), "c")
# })

# test_that("label_choiceset works", {
# 
# })
```

# Plotting Functions

## Univariate

## Plotting Select one variable

```{r function-plot_select_one}
#' @title Plotting Select one variable
#' @description Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @param n if not NULL, lumps all levels except for the n most frequent (or least frequent if n < 0) - cf
#'            forcats::fct_lump_n()
#' @param showcode display the code
#' 
#' @importFrom ggplot2 aes  geom_col geom_label scale_x_continuous scale_y_discrete coord_cartesian labs theme_minimal geom_vline theme element_line element_blank
#' @importFrom data.table := 
#' 
#' @export
# prefixer::import_from(fun = kobo_dico)

plot_select_one <- function(datalist  ,
                            dico  ,
                            var,
                            datasource = NULL,
                            n = NULL, 
                            showcode = FALSE) {

  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[[3]]$form_title ) }
  
 
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  ## get number of non NA response
  nr <- sum(!is.na(data[[var]]))
  
  if ( is.nan(rr)) {
    cat(paste0("\n <strong style=\"color:#0072BC;\">The variable from the form called: ",var," could not be identified in the dataset</strong>\n\n"))
   # return(invisible(NULL))
     return(invisible())
    
  } else {
  
  ## Put a condition in case there's no record
  if (rr != 0  & ! (is.nan(rr)) ) {
    
  
  ## Count number of levels   
  nlev <-  nlevels( as.factor(data[[var]]) )  
  ## Set the value for n if not set up -
  if( is.null(n)) { n1 = nlev } else { n1 = n}
  
  cnts <- data |>
    tidyr::drop_na(tidyselect::all_of(var)) |>
    dplyr::group_by(.data[[var]]) |>
    #dplyr::summarise(n = dplyr::n()) |>
    dplyr::count(x := .data[[var]]) |>
    dplyr::mutate(p = n/nr) |>
    # Lump together factor levels into "other"
    dplyr::mutate(x = forcats::fct_lump_n( as.factor(x),    
                                         n = as.integer(n1),
                                         w = p,
                     other_level = paste0("Other ",
                              nlev  - n1,
                              " response options automatically lumped") )) |>
    dplyr::group_by(x) |>
    dplyr::summarise( n = sum(n, na.rm = TRUE),
                      p = n/nr)
  
  
  
  listvar <- as.data.frame(dico[["variables"]]) |>
             dplyr::filter( name ==var ) |>
             dplyr::pull(list_name)
  
  ## Manage situation if ordinal variable (i.e. order is set in choices)
  if (any(!is.na(dplyr::filter(dico[[2]], list_name == listvar)$order))) {
    
    
    ## case there are duplicated answers options - for instance if allow_choice_duplicates = yes
    ll <- dplyr::filter(dico[[2]], list_name == listvar) |>
          dplyr::group_by(name) |> 
          dplyr::slice_head(n = 1)|>
          ## Fix in case some orders are empty... 
          dplyr::mutate( order = ifelse(is.na(order),1, order))
    
    cnts <- cnts |>
          dplyr::left_join( ll, by = c("x"="name"))|>
          dplyr::mutate(x = forcats::fct_reorder(x, order, as.numeric))
  } else {
    cnts <- cnts |>
      dplyr::mutate(x = forcats::fct_reorder(x, n))
  }
  
  ## Writing code instruction in report
  if( showcode == TRUE) { cat(paste0("\n", label_varname(dico = dico,
                                                   x = var), "\n",
                                      
     "`plot_select_one(datalist, dico, \"", var, "\", datasource = params$datasource, n = ",n1, ")` \n\n ")) }  else {}
  
    
    ## plot
    require(ggplot2)
    p <- ggplot2::ggplot(cnts, ggplot2::aes(p, x)) +
      ggplot2::geom_col(fill = "#0072BC") +
      
      #geom_label(aes(label = scales::label_percent(accuracy = .01)(p))) +
      ## Position label differently in the bar in white - outside bar in black
      ggplot2::geom_label( data =   function(x) subset(x, p < max(p) / 1.5),
                  ggplot2::aes(label = scales::label_percent(accuracy = .01)(p)),
                  hjust = -0.1 ,
                  vjust = 0.5,
                  colour = "black",
                  fill = NA,
                  label.size = NA,
                  size = 6   ) +
      ggplot2::geom_label( data =   function(x) subset(x, p >= max(p) / 1.5),
                  ggplot2::aes(label = scales::label_percent(accuracy = .01)(p)),
                  hjust = 1.1 ,
                  vjust = 0.5,
                  colour = "white",
                  fill = NA,
                  label.size = NA,
                  size = 6   ) +
      ggplot2::scale_x_continuous(labels = scales::label_percent()) +
      ggplot2::scale_y_discrete(labels = function(x) {label_choiceset(dico = dico, x = var)(x) |>
                      stringr::str_wrap(40)}) +
      ggplot2::coord_cartesian(clip = "off") +
      ggplot2::labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(dico = dico, x = var), 90),
           subtitle = if (!is.na(label_varhint(dico = dico, x= var))){
                      stringr::str_wrap(label_varhint(dico = dico, x= var), 90)} else { ""},
           caption = glue::glue("Single choice, Response rate = {scales::label_percent(accuracy = .01)(rr)}  on a total of {nrow(data)} records. \n Source: {datasource}")) +
      ggplot2::theme_minimal( base_size = 24) +
      ggplot2::geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
      ggplot2::theme( panel.grid.major.x  = ggplot2::element_line(color = "#cbcbcb"),
             panel.grid.major.y  = ggplot2::element_blank(),
             panel.grid.minor = ggplot2::element_blank()    ) +
      ggplot2::theme(plot.title.position = "plot")
    
   return(p) #  print(p)
    
  } else { 
    cat(paste0("<strong style=\"color:#0072BC;\"> No recorded answers for the question: </strong>",var,"\n\n")) 
      #return(invisible(NULL))
      return(invisible())
    }
  # cat("\n\n")
  }
}  



```

```{r examples-plot_select_one}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_select_one(datalist = datalist,
              dico = dico, 
              var = "profile.country",
              showcode = TRUE)
## Exmaple with lumping
plot_select_one(datalist = datalist,
              dico = dico, 
              var = "profile.country",
              n = 1,
              showcode = TRUE)

# plot_select_one(datalist = datalist,
#               dico = dico, 
#               var = "profile.countryerror",
#               showcode = TRUE)
```

```{r tests-plot_select_one}

# Unit test

# context("Test plot_select_one()")
# 
# test_that("plot_select_one() produces a plot object", {
#   expect_is(plot_select_one(datalist = NULL, dico = NULL, var = NULL), "gg")
# })
# 
# test_that("plot_select_one() requires three arguments", {
#   expect_error(plot_select_one(), "argument 'datalist' is missing")
#   expect_error(plot_select_one(datalist = NULL), "argument 'dico' is missing")
#   expect_error(plot_select_one(datalist = NULL, dico = NULL), "argument 'var' is missing")
# })


# test_that("plot_select_one works", {
# 
# })
```


## Plotting Select multiple variable

```{r function-plot_select_multiple}
#' @title Plotting Select multiple variable
#' #' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @param n if not NULL, lumps all levels except for the n most frequent (or least frequent if n < 0) - cf
#'            forcats::fct_lump_n()
#' @param showcode display the code
#' 
#' @importFrom ggplot2 aes  geom_col geom_label scale_x_continuous scale_y_discrete coord_cartesian labs theme_minimal geom_vline theme element_line element_blank
#' @importFrom tidyr separate_rows  drop_na
#' 
#' @importFrom data.table :=  
#' @export
# prefixer::import_from(fun = kobo_dico)

plot_select_multiple <- function(datalist = datalist, 
                                 dico = dico,
                                 var, 
                                 datasource = NULL,
                                 n = NULL,
                                 showcode = FALSE) {
  
  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  
  ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[[3]]$form_title ) }
  
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  nr <- sum(!is.na(data[[var]]))

  
  if ( is.nan(rr)) {
    cat(paste0("<strong style=\"color:#0072BC;\">The variable from the form called: ",var," could not be identified in the dataset</strong>\n\n"))
    #return(invisible(NULL))
      return(invisible())
    
  } else {
  
  ## If not empty
  if (rr != 0 & ! (is.nan(rr)) ) {    
  
  ## Count number of levels 
  nlev <-  nrow(dplyr::distinct(tidyr::separate_rows(as.data.frame(data[[var]]), `data[[var]]`, sep = " ")))
  ##  Set the value for n if not set up -
  if( is.null(n)) { n1 = nlev } else { n1 = n} 
  
    
  cnts <- data |>
    tidyr::drop_na(tidyselect::all_of(var)) |>
    tidyr::separate_rows(.data[[var]], sep = " ") |>
    dplyr::count(x := .data[[var]]) |>
    dplyr::mutate(p = n/nr) |> 
    # Lump together factor levels into "other"
    dplyr::mutate(x = forcats::fct_lump_n( as.factor(x),    
                                         n = as.integer(n1),
                                         w = p,
                     other_level = paste0("Other ",
                              nlev  - n1,
                              " response options automatically lumped") )) |>
    dplyr::group_by(x) |>
    dplyr::summarise( n = sum(n, na.rm = TRUE),
                      p = n/nr)
  
  ## Manage situation if ordinal variable (i.e. order is set in choices)
  if (any(!is.na(dplyr::filter(dico[[2]], list_name == var)$order))) {
    
    ## case there are duplicated answers options - for instance if allow_choice_duplicates = yes
    ll <- dplyr::filter(dico[[2]], list_name == listvar) |>
          dplyr::group_by(name) |> 
          dplyr::slice_head(n = 1)|>
          ## Fix in case some orders are empty... 
          dplyr::mutate( order = ifelse(is.na(order),1, order))
    
    cnts <- cnts |>
      dplyr::left_join( dplyr::filter(ll), by = c("x"="name"))|>
      dplyr::mutate(x = forcats::fct_reorder(x, order, as.numeric))
  } else {
    cnts <- cnts |>
      dplyr::mutate(x = forcats::fct_reorder(x, n))
  }

    
    ## Writing code instruction in report
    if( showcode == TRUE) {
      cat(paste0(label_varname(dico = dico, x = var),
                 "\n",
        "`plot_select_multiple(datalist, dico, \"", var, "\", datasource=params$datasource, n=",n1, ")` \n\n "))  }   else {} 
    
    require(ggplot2)
    ## Plot
     p <- ggplot2::ggplot(cnts, ggplot2::aes(p, x)) +
      ggplot2::geom_col(fill = "#0072BC") +
      #geom_label(aes(label = scales::label_percent(accuracy = .01)(p))) + 
      ## Position label differently in the bar in white - outside bar in black
      ggplot2::geom_label( data =   function(x) subset(x, p < max(p) / 1.5),
                    ggplot2::aes(label = scales::label_percent(accuracy = .01)(p)),
                    hjust = -0.1 ,
                    vjust = 0.5, 
                    colour = "black", 
                    fill = NA, 
                    label.size = NA, 
                    size = 6   ) +  
      ggplot2::geom_label( data =   function(x) subset(x, p >= max(p) / 1.5),
                    ggplot2::aes(label = scales::label_percent(accuracy = .01)(p)),
                    hjust = 1.1 ,
                    vjust = 0.5, 
                    colour = "white", 
                    fill = NA, 
                    label.size = NA,
                    size = 6   ) +   
      
      ggplot2::scale_x_continuous(labels = scales::label_percent()) +
      ggplot2::scale_y_discrete(labels = function(x) {label_choiceset(dico = dico,
                                                        x = var)(x) |>
          stringr::str_wrap(40)}) +
      ggplot2::coord_cartesian(clip = "off") +
      ggplot2::labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(dico = dico, x= var), 90),
           subtitle = if (!is.na(label_varhint(dico = dico, x = var))){ 
                     stringr::str_wrap(label_varhint(dico = dico, x = var), 90)} else { ""},
           caption = glue::glue("Multiple choice, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
      ggplot2::theme_minimal( base_size = 24) + 
      ggplot2::geom_vline(xintercept = 0, size = 1.1, colour = "#333333") +
      ggplot2::theme( panel.grid.major.x  = ggplot2::element_line(color = "#cbcbcb"), 
             panel.grid.major.y  = ggplot2::element_blank(), 
             panel.grid.minor = ggplot2::element_blank()    ) +
      ggplot2::theme(plot.title.position = "plot")
     
     
   return(p) #  print(p)
    
    #plot_select_multiple_cross(var,   by_var)
    
  } else { 
    cat(paste0("<strong style=\"color:#0072BC;\"> No recorded answers for the question: </strong>",var,"\n\n")) 
      return(invisible())
    #return(invisible(NULL))
    }
  # cat("\n\n")
    
  }  
}



```

```{r examples-plot_select_multiple}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )


plot_select_multiple(datalist = datalist,
              dico = dico, 
              var = "profile.reason",
              datasource = NULL,
              showcode = TRUE
            )

## Displaying the usage of the lumping option..
plot_select_multiple(datalist = datalist,
              dico = dico, 
              var = "profile.reason",
              n = 5,
             datasource = NULL,
              showcode = TRUE
            )

# plot_select_multiple(datalist = datalist,
#               dico = dico, 
#               var = "profile.reason1",
#               showcode = TRUE
#             )

```

```{r tests-plot_select_multiple}


# # Unit test
# context("plot_select_multiple()")
# 
# test_that("plot_select_multiple() returns a ggplot object", {
#   expect_true(inherits(plot_select_multiple(datalist = datalist, dico = dico, var = "var1"), "gg"))
# })
# 
# test_that("plot_select_multiple() returns an invisible object when rr = 0", {
#   expect_true(invisible(plot_select_multiple(datalist = datalist, dico = dico, var = "var2")))
# })

# test_that("plot_select_multiple works", {
# 
# })
```


## Plotting Numeric variable

```{r function-plot_integer}
#' @title Plotting numeric variable
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @param showcode display the code
#' 
#' @importFrom   ggplot2 theme element_line element_blank element_text aes labs
#'             theme_minimal geom_hline
#' @importFrom datawizard skewness kurtosis
#' @importFrom stats IQR   
# prefixer::import_from(fun = kobo_dico)          
#' 
#' @export

plot_integer <- function(datalist = datalist, 
                         dico = dico,
                         var, 
                         datasource = NULL,
                         showcode = FALSE) {
  
  requireNamespace("ggplot2") 
  requireNamespace("dplyr")
  ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[[3]]$form_title ) }
   
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  ## Cast just in case...
  data[[var]] <- as.numeric(data[[var]])
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  # cat("---\n")
  # cat("\n\n")
 if ( is.nan(rr)) {
    cat(paste0("<strong style=\"color:#0072BC;\">The variable from the form called: ",var," could not be identified in the dataset</strong>\n\n"))
      return(invisible())
     #return(invisible(NULL))
  } else {
  
  ## Writing report
  if (rr != 0 & ! (is.nan(rr))  ) { 
      ## Writing code instruction in report
      if( showcode == TRUE) {
        cat(paste0(label_varname(dico = dico,
                                                   x = var), "\n",
    "`plot_integer(datalist, dico, \"", var, "\", datasource=params$datasource)` \n\n "))  }   else {}  
    
    
     info <- paste0("Mean: ", round(mean(data[[var]]),2) ,
                    ", Standard Deviation: ",round(stats::sd(data[[var]]),2) ,
                    ", Coefficient of Variation: ",round( stats::sd(data[[var]]) / mean(data[[var]]) * 100 ,2) ,
                    ", Skewness: ",round(datawizard::skewness(data[[var]]),2) ,
                    " and Kurtosis: ",round(datawizard::kurtosis(data[[var]]),2), ".")
     ## Detect potential outliers based on Interquartile Range
     iqr <- stats::IQR(data[[var]], na.rm = T)
     infoIQR <- dplyr::if_else ( iqr >= 1.349,
        paste0("Interquartile Range is ", round(iqr,2), " which suggests that there is no outlier"),
        paste0("Interquartile Range is ", round(iqr,2), " which suggests that there are outliers"))
                 
    
    require(ggplot2)
    p <- ggplot2::ggplot(data) + 
      ggplot2::geom_histogram(ggplot2::aes( x= .data[[var]]), 
                    # bins = nclass.FD(na.omit(data[[var]])),
                     fill = "#0072BC", 
                     color = "white" 
      ) +
      # scale_y_continuous(labels = scales::label_percent()) +
      ggplot2::labs(x = NULL, y = NULL,
           title = stringr::str_wrap(label_varname(dico = dico, x = var), 90), 
           subtitle = if (!is.na(label_varhint(dico = dico, x = var))){ 
                     stringr::str_wrap(label_varhint(dico = dico, x = var), 90)} else { ""},
           caption = stringr::str_wrap(glue::glue("Numeric, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource} - {info} - {infoIQR}")), 100) +
  
      ggplot2::theme_minimal( base_size = 24) +
     # geom_hline(yintercept = 0, size = 1.1, colour = "#333333") +
      ggplot2::theme( panel.grid.major.y  = ggplot2::element_line(color = "#cbcbcb"), 
           panel.grid.major.x  = ggplot2::element_blank(), 
           panel.grid.minor = ggplot2::element_blank()    ) +
           ggplot2::theme(plot.title.position = "plot")
    
   return(p) #  print(p)
    
  } else { 
    cat(paste0("<strong style=\"color:#0072BC;\"> No recorded answers for the question: </strong>",var,"\n\n"))
      return(invisible())
    #return(invisible(NULL))  
    }
  # cat("\n\n")
  }
}



```

```{r examples-plot_integer}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_integer(datalist = datalist,
              dico = dico, 
              var = "members.age",
              showcode = TRUE)
```

```{r tests-plot_integer}

# Unit test for plot_integer function

# context("plot_integer function")
# 
# test_that("plot_integer function returns a plot", {
#   expect_true(is.ggplot(plot_integer(datalist = datalist, 
#                          dico = dico,
#                          var, 
#                          datasource = NULL,
#                          showcode = FALSE)))
# })
# 
# test_that("plot_integer function returns an invisible object when there is no recorded answer", {
#   expect_true(identical(invisible(plot_integer(datalist = datalist, 
#                          dico = dico,
#                          var, 
#                          datasource = NULL,
#                          showcode = FALSE)),invisible()))
# })
# test_that("plot_integer works", {
# 
# })
```


## Plotting Open Text variable

```{r function-plot_text}
#' @title Plotting Open Text variables
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @param showcode display the code
#' 
#' 
#' @importFrom glue glue
#' @importFrom scales label_percent
#' @importFrom stringr str_wrap
#' @importFrom tm content_transformer Corpus VectorSource tm_map removeNumbers removePunctuation stripWhitespace stemDocument removeWords stopwords TermDocumentMatrix  tm_map Corpus content_transformer
#'              TermDocumentMatrix stopwords
#' @importFrom ggwordcloud geom_text_wordcloud  
#' @importFrom ggplot2 labs theme_minimal aes scale_size_area scale_color_gradient labs theme_minimal
#' @importFrom SnowballC wordStem
#' 
#' 
#' @export
#' 
# prefixer::import_from(fun = plot_text)

plot_text <- function(datalist = datalist, 
                      dico = dico,
                      var, 
                      datasource = NULL,
                      showcode = FALSE) {
  
  requireNamespace("dplyr")
  requireNamespace("SnowballC")
  requireNamespace("ggplot2")
 # require("ggplot2")
  ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[[3]]$form_title ) }
  
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  # cat("---\n")
  # cat("\n\n")
  #cat( stringr::str_wrap(  paste0(  label_varname(var), " (Open Text question)"), 70) )
  # cat(paste("####", label_varname(var)))
  # cat("\n\n")
  #cat("Open Text question\n\n")
  
  rr <- mean(!is.na(data[[var]]))
   if ( is.nan(rr)) {
    cat(paste0("\n <strong style=\"color:#0072BC;\">The variable from the form called: ",var," could not be identified in the dataset</strong>\n\n"))
     #return(as.character(""))
     return(invisible())
     
  } else { 
      
  require("tm")
  #Replacing â/â, â@â and â|â with space:
  toSpace <- tm::content_transformer(function (x , pattern ) gsub(pattern, " ", x))  
  # Cleaning the text  #### 
  docs <-  tm::Corpus(tm::VectorSource(data[[var]]))  %>%
            #Text transformation to replace special characters from the text.
            tm::tm_map(., toSpace, "/")  %>%
            tm::tm_map(., toSpace, "@")  %>%
            tm::tm_map(., toSpace, "\\|")  %>%
            # Convert the text to lower case
            tm::tm_map(., tm::content_transformer(tolower))  %>%
            # Remove numbers
            tm::tm_map(., tm::removeNumbers)  %>%
            # Remove punctuations
            tm::tm_map(.,  tm::removePunctuation)  %>%
            # Eliminate extra white spaces
            tm::tm_map(.,  tm::stripWhitespace)  %>%
            # Text stemming - reduces words to their root form.
            tm::tm_map(.,  tm::stemDocument)  %>%
            # Remove common stopwords depending on language
            # The information value of âstopwordsâ is near zero due to the fact that they 
            # are so common in a language. Removing this kind of words is useful before
            # further analyses. 
            tm::tm_map(., tm::removeWords, tm::stopwords("english"))  %>%
            # Remove your own stop word
            tm::tm_map(., tm::removeWords, c("blabla1", "blabla2")) 
  
    # Step 4 : Build a term-document matrix ####
    # Table containing the frequency of the words. Column names are words and row names are documents. 
    dtm <- tm::TermDocumentMatrix(docs)
    m <- as.matrix(dtm)
    v <- sort(rowSums(m),decreasing=TRUE)
    d <- data.frame(word = names(v),freq=v)
    #head(d, 10)
  
    ## Put a condition in case there's no record
    if(nrow(d) > 0 ) {
      
        ## Writing code instruction in report
        if( showcode == TRUE) {
          cat(paste0("\n", label_varname(dico = dico,
                                                   x = var), "\n",
    " `plot_text(datalist, dico, \"", var, "\", datasource=params$datasource)` \n\n "))  }   else {} 
      
      # Step 5 : Generate the Word cloud  ####
      #The importance of words can be illustrated as a word cloud as follow :
      #set.seed(1234)
      
      ## Chart option 1
     # p <-  wordcloud::wordcloud(words = d$word, # words : the words to be plotted
     #            freq = d$freq,  # freq : their frequencies
     #            min.freq = 1,  # min.freq : words with frequency below min.freq will not be plotted
     #            max.words=200, # max.words : maximum number of words to be plotted
     #            random.order=FALSE, # random.order : plot words in random order. If false, they will be plotted in decreasing frequency
     #            rot.per=0.25,   # rot.per : proportion words with 90 degree rotation (vertical text)
     #            colors= RColorBrewer::brewer.pal(8, "Dark2")) # colors : color words from least to most frequent. Use, for example, colors =âblackâ for single color.
     #      graphics::title( main = stringr::str_wrap( label_varname(dico = dico, x= var), 90),
     #                 sub = glue::glue("Open Text question \n Source: {datasource}" ))  
     # 
     # return(p)  
      
      
      ## Chart option 2        
      p1 <- ggplot2::ggplot(d,
                   ggplot2::aes(label = word,
                       size = freq,
                       color = freq )) +
            ggwordcloud::geom_text_wordcloud(area_corr = TRUE,
                                             rm_outside = TRUE,
                                             eccentricity = 1) +
            ggplot2::scale_size_area(max_size = 50) +
            # scale_radius(range = c(0, 10),  limits = c(0, NA)) +
            ggplot2::scale_color_gradient(low = "darkred", high = "red") +
            ggplot2::labs(x = NULL, y = NULL,
                 title = stringr::str_wrap(label_varname(dico = dico, x = var), 90), 
                 subtitle = if (!is.na(label_varhint(dico = dico, x = var))){ 
                     stringr::str_wrap(label_varhint(dico = dico, x = var), 90)} else { ""},
                 caption = glue::glue("Wordcloud displaying an Open Text, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records")) +

            ggplot2::theme_minimal( base_size = 24)
      return(p1)
      
    
    } else { 
      cat(paste0("<strong style=\"color:#0072BC;\">No significant text for the  question: </strong>\n\n", var))}
      return(invisible())
      #return(invisible(NULL))
  
  # cat("\n\n")
  }
}




```

```{r examples-plot_text}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_text(datalist = datalist,
              dico = dico, 
              var = "profile.occupation",
              showcode = TRUE)
```

```{r tests-plot_text}
# Unit Test

# context("plot_text()")
# 
# test_that("plot_text() returns a valid ggplot object", {
#   expect_is(plot_text(), "ggplot")
# })
# 
# test_that("plot_text() returns an empty plot when there is no text", {
#   expect_equal(plot_text(), ggplot2::ggplot() + ggplot2::theme_void())
# })
# test_that("plot_text works", {
# 
# })
```

## Bivariate

## Plotting Select one variable with cross tabulation

```{r function-plot_select_one_cross}
#' @title Plotting Select one variable with cross tabulation on a second categorical variable
#' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param by_var variable to use for cross tabulation
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @param n if not NULL, lumps all levels except for the n most frequent (or least frequent if n < 0) - cf
#'            forcats::fct_lump_n()
#' @param n_by if not NULL, lumps all levels for the cross tabulation variable except for the n_by most frequent (or least frequent if n < 0) - cf
#'            forcats::fct_lump_n()
#' @param showcode display the code
#' 
#' @importFrom ggplot2 aes  geom_col geom_label 
#'             scale_x_continuous scale_y_discrete 
#'             coord_cartesian labs theme_minimal 
#'             geom_vline theme element_line element_blank
#'             as_labeller facet_wrap
#' @importFrom data.table :=  
#' @export

# prefixer::import_from(fun = plot_select_one_cross)



plot_select_one_cross <- function(datalist = datalist,
                            dico = dico,
                            var, 
                            by_var , 
                            datasource = NULL,
                            n = NULL,
                            n_by = NULL,
                            showcode = FALSE) {
  
  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  ## Get default data source name
  if (is.null(datasource)) {
    datasource <- as.character(dico[[3]]$form_title)
  }
  
  data <- kobo_frame(datalist = datalist,
                     dico = dico,
                     var = var)
  
  data2 <- kobo_frame(datalist = datalist,
                      dico = dico,
                      var = by_var)
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  rr2 <- mean(!is.na(data2[[by_var]]))
  
  
  nr <- sum(!is.na(data[[var]]))
  nr2 <- sum(!is.na(data2[[by_var]]))
  
  ## Writing report
  # cat("\n")
  # cat(paste("####", label_varname(var)))
  #cat(paste("#### Variable: ", var))
  
  if (is.nan(rr) | is.nan(rr2)) {
    cat(
      paste0(
        "<strong style=\"color:#0072BC;\">The variable from the form called: ",
        var,
        " or ",
        by_var,
        " could not be identified in the dataset</strong>\n\n"
      )
    )
      return(invisible())
    #return(invisible(NULL))
    
  } else if (!(identical(data, data2))) {
    # nothing to do - the variable are not in the same frame
     cat("")
      return(invisible())
     #return(invisible(NULL))
  } else {
    ## Put a condition in case there's no record
    if (rr != 0 & !(is.nan(rr))) {
      if (by_var != "") {
        if (by_var != var) {
          cnts1 <- data |>
            ## keep only the variable we need
            #tidyselect::all_of(c(var, by_var)) |>
            tidyr::drop_na(tidyselect::all_of(c(var, by_var)))

          ## Need to check that there's actually a proper intersection in the response...
          if (nrow(cnts1) == 0) {
            cat(
              paste0(
                "<strong style=\"color:#0072BC;\">There is not intersection between the answers from the variables from the form called: ",
                var,
                " or ",
                by_var,
                " in the dataset</strong>\n\n"
              )
            )
          } else {
              ## Set the value for n if not set up -
              if( is.null(n)) { n1 = nlevels( as.factor(data[[var]]) )} else { n1 = n} 
              ## Set the value for n_by if not set up -
              if( is.null(n_by)) { n_by1 = nlevels( as.factor(data[[by_var]]) )} else { n_by1 = n_by} 
            
             cnts <- cnts1 |> 
              dplyr::group_by(.data[[var]], .data[[by_var]] ) |>
              dplyr::summarise(n = dplyr::n()) |>
              dplyr::mutate(p = n/nr) |>
              # Lump together factor levels into "other"
              dplyr::mutate(
                x = as.character(forcats::fct_lump_n( as.factor(.data[[var]]), 
                                         n = n1,
                                         w = p,
                                         other_level = paste0("Other ",
                                    nlevels( as.factor(data[[var]]))-n1,
                                    " response options automatically lumped")) ),
                y = as.character(forcats::fct_lump_n( as.factor(.data[[by_var]]), 
                                         n = n_by1,
                                         w = p,
                                         other_level = paste0("Other ",
                                    nlevels( as.factor(data[[by_var]]))-n_by1,
                                    " response options automatically lumped")))
              ) |>
              ## let's summarize again after lumping 
              dplyr::group_by(x, y ) |>
              dplyr::summarise(n = sum(n, na.rm = TRUE)) |>
              dplyr::mutate(p = n/nr) |>
               
              ## Now  counting records per facet..
              dplyr::group_by(y) |>
              dplyr::mutate(cumsum = max(cumsum(as.numeric(n))),
                            pcum = n / cumsum) |>
              ## Relabel
              dplyr::mutate( y0 = label_choiceset(dico = dico, x= by_var)(y) ) |>
              ## Create better label for the facet
              dplyr::mutate( y1 = paste0(y0, " (",cumsum, " records)") )
             
             
          ## Writing code instruction in report
          if (showcode == TRUE) {
            cat( paste0( label_varname(dico = dico, x = var),  "\n",
       "`plot_select_one_cross(datalist, dico, var=\"", var, "\", by_var=\"", by_var, "\",datasource=params$datasource, n=", n1, ",n_by=",n_by1, " )` \n\n "))  }   else {} 
             
            
            ## plot
            require(ggplot2)
            p <- ggplot2::ggplot(cnts, ggplot2::aes(x = pcum,  y = x)) +
              ggplot2::geom_col(fill = "#0072BC") +
              ggplot2::geom_label(
                data =   function(x)  subset(x, pcum < max(pcum) / 1.5),
                ggplot2::aes(label = scales::label_percent(accuracy = .01)(pcum)),
                hjust = -0.1 , vjust = 0.5,
                colour = "black", fill = NA,
                label.size = NA, size = 5 ) +
              ggplot2::geom_label( data =   function(x)subset(x, pcum >= max(pcum) / 1.5),
                ggplot2::aes(label = scales::label_percent(accuracy = .01)(pcum)),
                hjust = 1.1 ,  vjust = 0.5,
                colour = "white", fill = NA,
                label.size = NA,  size = 5  ) +
              ggplot2::scale_x_continuous(labels = scales::label_percent()) +
              ggplot2::facet_wrap(~ y1 , nrow = 3 # ,
                         # labeller = #glue::glue('{
                         #   as_labeller(function(x)
                         #   label_choiceset(dico = dico,
                         #                   x = by_var)(x) ) 
                         # #  } ')
                         ) +
              ggplot2::scale_y_discrete(
                labels = function(x) {
                  label_choiceset(dico = dico,
                                  x = var)(x) |>
                    stringr::str_wrap(40)
                }
              ) +
              ggplot2::coord_cartesian(clip = "off") +
              ggplot2::labs(
                x = NULL,
                y = NULL,
                title = stringr::str_wrap(label_varname(dico = dico, x = var), 90),
                subtitle = stringr::str_wrap(paste0(
                  "Crossed by ", label_varname(dico = dico, x = by_var)
                ), 90),
                caption = glue::glue(
                  "Single choice, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}"
                )
              ) +
              ggplot2::theme_minimal(base_size = 24) +
              ggplot2::geom_vline(xintercept = 0,
                         size = 1.1,
                         colour = "#333333") +
              ggplot2::theme(
                panel.grid.major.x  = ggplot2::element_line(color = "#cbcbcb"),
                panel.grid.major.y  = ggplot2::element_blank(),
                panel.grid.minor = ggplot2::element_blank()
              ) +
              ggplot2::theme(plot.title.position = "plot")
            
            return(p) #  print(p)
          }
        }
      } else {
         cat("")
         #return(invisible(NULL))
         return(invisible())
      }
    } else {
      cat(paste0("<strong style=\"color:#0072BC;\"> No recorded answers for the question: </strong>", var,  "\n\n" ) )
      return(invisible())
    }
    # cat("\n\n")
  }
}




```

```{r examples-plot_select_one_cross}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_select_one_cross(datalist = datalist,
              dico = dico, 
              var = "profile.country",
              by_var = "profile.occupation",
              showcode = TRUE
              )
## test if variable are not in the same frame...
plot_select_one_cross(datalist = datalist,
              dico = dico, 
              var = "profile.country",
              by_var = "members.sex",
              n = 5,
              n_by = 5,
              showcode = TRUE
              )

```

```{r tests-plot_select_one_cross}

# # Unit test
# context("plot_select_one_cross()")
# 
# test_that("plot_select_one_cross() produces a plot when all the arguments are provided", {
#   expect_true(!is.null(plot_select_one_cross(datalist = datalist,
#                             dico = dico,
#                             var = "age", 
#                             by_var = "gender",
#                             datasource = NULL,
#                             n = NULL,
#                             n_by = NULL,
#                             showcode = FALSE)))
# })

# test_that("plot_select_one_cross works", {
# 
# })
```



## Plotting Select multiple variable with cross-tabulation

```{r function-plot_select_multiple_cross}
#' @title Plotting Select multiple variable with cross tabulation on a second categorical variable
#' @description
#' Note that if the column order is set in the xlsform choice part, the variable will be de factor considered as ordinal and the default ordering will not be done based on frequency
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param by_var variable to use for cross tabulation
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform
#' @param n if not NULL, lumps all levels except for the n most frequent (or least frequent if n < 0) - cf
#'            forcats::fct_lump_n()
#' @param n_by if not NULL, lumps all levels for the cross tabulation variable except for the n_by most frequent (or least frequent if n < 0) - cf
#'            forcats::fct_lump_n()
#' @param showcode display the code
#' 
#' @importFrom ggplot2 aes  geom_col geom_label scale_x_continuous
#'            scale_y_discrete coord_cartesian labs theme_minimal 
#'            geom_vline theme element_line element_blank facet_wrap as_labeller 
#' @importFrom tidyr separate_rows drop_na          
#' @importFrom data.table :=  
#' 
#' @export

# prefixer::import_from(fun = plot_select_multiple_cross)



plot_select_multiple_cross <- function(datalist = datalist,
                                       dico = dico,
                                       var, 
                                       by_var , 
                                       datasource = NULL,
                                       n = NULL,
                                       n_by = NULL,
                                       showcode = FALSE) {

  ## Get default data source name
  if (is.null(datasource)) {
    datasource <- as.character(dico[[3]]$form_title)
  }
  
  data <- kobo_frame(datalist = datalist,
                     dico = dico,
                     var = var)
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  nr <- sum(!is.na(data[[var]]))
  
  data2 <- kobo_frame(datalist = datalist,
                      dico = dico,
                      var = by_var)
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  rr2 <- mean(!is.na(data2[[by_var]])) 
  ## Writing report
  # cat("\n")
  # cat(paste("####", label_varname(var)))
  #cat(paste("#### Variable: ", var))
  
  if (is.nan(rr) | is.nan(rr2)) {
    cat(
      paste0(
        "<strong style=\"color:#0072BC;\">The variables from the form called: ",
        var,
        " or ",
        by_var,
        " could not be identified in the dataset</strong>\n\n"
      )
    )
  } else if (!(identical(data, data2))) {
    # nothing to do - the variable are not in the same frame
    cat("")
    return(invisible())
    
  } else {
    ## Writing report
    if (rr != 0 & !(is.nan(rr))) {
      if (by_var != "") {
        if (by_var != var) {
          
          cntscross1 <- data |>
            ## keep only the variable we need
            tidyr::drop_na(tidyselect::all_of(c(var, by_var)))
          
         ## Apply the labels  
         cntscross1[,by_var] <- label_choiceset(dico = dico, x = by_var)(cntscross1[,by_var] )
          
          ## Need to check that there's actually a proper intersection in the response...
          if (nrow(cntscross1) == 0) {
            cat(
              paste0(
                "<strong style=\"color:#0072BC;\">There is not intersection between the answers from the variables from the form called: ",
                var,
                " or ",
                by_var,
                " in the dataset</strong>\n\n"
              )
            )
          } else {
             ## Lumping 
            nlev <-  nrow(dplyr::distinct(tidyr::separate_rows(as.data.frame(data[[var]]), `data[[var]]`, sep = " ")))
             ## Set the value for n if not set up -
             if( is.null(n)) { n1 = nlev}  else { n1 = n} 
            
            ## the by_var is a simple select_one
            nlev_by <-  nlevels( as.factor(data[[by_var]]) )
             ## Set the value for n_by if not set up -
             if( is.null(n_by)) { n_by1 = nlev_by}  else { n_by1 = n_by} 
            
           ## Compute tabulation
          cntscross <- cntscross1 |>
            ## Separate the var with select_multiple
            tidyr::separate_rows(.data[[var]], sep = " ") |>
            dplyr::group_by(.data[[var]], .data[[by_var]], X_id ) |>
            dplyr::summarise(n = dplyr::n()) |>
            dplyr::mutate(p = n/nr)  |>
            ## Lump together factor levels into "other"
            dplyr::mutate(x = forcats::fct_lump_n( as.factor(.data[[var]]) ,
                                                   n = as.integer(n1),
                                                   w = p,
                                                   other_level = paste0("Other ",
                                                                        nlev  - n1,
                                                                        " response options automatically lumped") )) |>
            ## Lump together factor levels into "other"
            dplyr::mutate(y = forcats::fct_lump_n( as.factor(.data[[by_var]] ),
                                                   n = as.integer(n_by1),
                                                   w = p,
                                                   other_level = paste0("Other ",
                                                                        nlev_by  - n_by1,
                                                                        " response options automatically lumped") )) |>
            ## let's summarize again after lumping
            dplyr::group_by(x, y , X_id) |>
            dplyr::summarise(n = sum(n, na.rm = TRUE)) |>
            dplyr::mutate(p = n/nr)  |>
            ## Now adding numbers by facet
            dplyr::group_by(y) |>
            dplyr::mutate(rec = dplyr::n_distinct(X_id) ) |>
            ## Relabel
            dplyr::mutate( y0 = label_choiceset(dico = dico,x= by_var)(y) ) |>
            ## Create better label for the facet
            dplyr::mutate( y1 = paste0(y0, " (", rec , " records)") ) |>
            ## let's summarize again
            dplyr::group_by(x, y1, rec) |>
            dplyr::summarise(n = sum(n, na.rm = TRUE)) |>
            dplyr::mutate(pcum = n / rec  )
            
          ## Writing code instruction in report
          if (showcode == TRUE) {
            cat( paste0( label_varname(dico = dico,  x = var), "\n",
     "`plot_select_multiple_cross(datalist, dico, var=\"", var, "\", by_var=\"", by_var, "\", datasource=params$datasource, n=", n1, ", n_by=",n_by1, " )` \n\n "))  }   else {} 
            ##plot
            require(ggplot2)
            p <- ggplot2::ggplot(cntscross,
                                 ggplot2::aes(x = pcum,
                                     y = x)) +
              ggplot2::geom_col(fill = "#0072BC") +
              #geom_label(aes(label = scales::label_percent(accuracy = .01)(pcum)), size = 2) +
              ## Position label differently in the bar in white - outside bar in black
              ggplot2::geom_label(
                data =   function(x)
                  subset(x, pcum < max(pcum) / 1.5),
                ggplot2::aes(label = scales::label_percent(accuracy = .01)(pcum)),
                hjust = -0.1 ,
                vjust = 0.5,
                colour = "black",
                fill = NA,
                label.size = NA,
                size = 5
              ) +
              ggplot2::geom_label(
                data =   function(x)
                  subset(x, pcum >= max(pcum) / 1.5),
                ggplot2::aes(label = scales::label_percent(accuracy = .01)(pcum)),
                hjust = 1.1 ,
                vjust = 0.5,
                colour = "white",
                fill = NA,
                label.size = NA,
                size = 5
              ) +
              ggplot2::scale_x_continuous(labels = scales::label_percent()) +
              ggplot2::facet_wrap(~ y1 ,
                         nrow = 3,
                         # labeller = as_labeller(function(x)
                         #   label_choiceset(dico = dico,
                         #                   x = by_var)(x))
                         ) +
              ggplot2::scale_y_discrete(
                labels = function(x) {
                  label_choiceset(dico = dico,
                                  x = var)(x) |>
                    stringr::str_wrap(40)
                }
              ) +
              ggplot2::coord_cartesian(clip = "off") +
              ggplot2::labs(
                x = NULL,
                y = NULL,
                title = stringr::str_wrap(label_varname(dico = dico, x = var), 90),
                subtitle = stringr::str_wrap(paste0(
                  "Crossed by ", label_varname(dico = dico,  x = by_var)
                ), 90),
                caption = glue::glue(
                  "Multiple choice, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}"
                )
              ) +
              ggplot2::theme_minimal(base_size = 24) +
              ggplot2::geom_vline(xintercept = 0,
                         size = 1.1,
                         colour = "#333333") +
              ggplot2::theme(
                panel.grid.major.x  = ggplot2::element_line(color = "#cbcbcb"),
                panel.grid.major.y  = ggplot2::element_blank(),
                panel.grid.minor = ggplot2::element_blank(),
                axis.title.y = ggplot2::element_text( size = 8)
              ) +
              ggplot2::theme(plot.title.position = "plot")
            
            return(p) #  print(p)
          }
          
        }
      } else {
        
          return(invisible())
      }
    } else {
      cat( paste0( "<strong style=\"color:#0072BC;\"> No recorded answers for the question: </strong>",var,"\n\n"))
      return(invisible())
    }
    # cat("\n\n")
    
  }
}



```

```{r examples-plot_select_multiple_cross}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )
plot_select_multiple_cross(datalist = datalist,
              dico = dico, 
              var = "profile.reason",
              by_var = "location",
              showcode = TRUE)

## test lumping
plot_select_multiple_cross(datalist = datalist,
              dico = dico, 
              var = "profile.reason",
              by_var = "location",
              n = 4, 
              showcode = TRUE)
```

```{r tests-plot_select_multiple_cross}


# 
# # Unit test
# context("Testing the plot_select_multiple_cross function")
# 
# # Create a mock dataset
# datalist <- list(
#   data1 = list(
#     data1_var1 = c("A", "B", "C"),
#     data1_var2 = c("A", "B", NA)
#   ),
#   data2 = list(
#     data2_var1 = c("A", "B", "C"),
#     data2_var2 = c("A", "B", NA)
#   )
# )
# 
# # Create a mock dictionary
# dico <- list(
#   data1_var1 = list(
#     type = "select_multiple",
#     label = "Var1",
#     labelset = c("A", "B", "C")
#   ),
#   data1_var2 = list(
#     type = "select_one",
#     label = "Var2",
#     labelset = c("A", "B")
#   ),
#   form_title = "Data1"
# )
# 
# # Test that the function returns an invisible object when there is no intersection between the answers from the variables
# test_that("The function returns an invisible object when there is no intersection between the answers from the variables", {
#   expect_invisible(plot_select_multiple_cross(datalist = datalist, dico = dico, var = "data1_var1", by_var = "data1_var2"))
# })

# test_that("plot_select_multiple_cross works", {
# 
# })
```



## Plotting Numeric variable with cross-tabulation

```{r function-plot_integer_cross}
#' @title Plotting numeric variable
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param by_var variable to use for cross tabulation
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @param showcode display the code
#' 
#' @importFrom   ggplot2 theme element_line element_blank element_text aes labs
#'             theme_minimal geom_hline geom_boxplot scale_size_area 
#'              scale_y_discrete theme_minimal
#' @export

# prefixer::import_from(fun = plot_integer_cross)



plot_integer_cross <- function(datalist = datalist, 
                         dico = dico,
                         var, 
                         by_var ,
                         datasource = NULL,
                         showcode = FALSE) {
  
  requireNamespace("ggplot2")
  requireNamespace("dplyr")
  ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[[3]]$form_title ) }
  
  data <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = var  )
  ## Cast just in case...
  data[[var]] <- as.integer(data[[var]])
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  
   data2 <- kobo_frame(datalist = datalist,
                   dico = dico,
                   var = by_var   )
  
  ## get response rate: rr
  rr <- mean(!is.na(data[[var]]))
  rr2 <- mean(!is.na(data2[[by_var]]))
  ## Writing report
  # cat("\n")
 # cat(paste("####", label_varname(var)))
  #cat(paste("#### Variable: ", var))
  
  if ( is.nan(rr) | is.nan(rr2) ) {
    cat(paste0("<strong style=\"color:#0072BC;\">The variable from the form called: ",var," or ", by_var, " could not be identified in the dataset</strong>\n\n"))
    return(invisible())
    
  } else if (  ! (identical(data,data2))  ) {
    # nothing to do - the variable are not in the same frame
    return(invisible())
    
    } else {
  
  ## Writing report
  if (rr != 0 & ! (is.nan(rr)) ) { 
      ## Writing code instruction in report
      if( showcode == TRUE) {
        cat(paste0(label_varname(dico = dico, x = var), "\n",
      "`plot_integer_cross(datalist, dico, var=\"", var, "\", by_var=\"", by_var, "\", datasource=params$datasource)` \n\n "))  }   else {} 
    
    require(ggplot2)
    p <- ggplot2::ggplot(data) + 
      ggplot2::geom_boxplot(ggplot2::aes(x = .data[[var]], y =  .data[[by_var]]), 
                     fill = "#0072BC", 
                     color = "white" 
      ) +
      # scale_y_continuous(labels = scales::label_percent()) +
      ggplot2::labs(x = NULL, y = NULL,
          title = stringr::str_wrap(label_varname(dico = dico, x = var), 90),
          subtitle = stringr::str_wrap( paste0("Crossed by ", label_varname(dico = dico, x = by_var)), 90),
          caption = glue::glue("Numeric, Response rate = {scales::label_percent(accuracy = .01)(rr)} on a total of {nrow(data)} records \n Source: {datasource}")) +
      
      ggplot2::scale_size_area(max_size = 10) +        
      ggplot2::scale_y_discrete(labels = function(x) {label_choiceset(dico = dico,
                                                          x = var)(x) |>
            stringr::str_wrap(40)}) +
      ggplot2::theme_minimal( base_size = 24) +
      ggplot2::geom_hline(yintercept = 0, size = 1.1, colour = "#333333") +
      ggplot2::theme( panel.grid.major.y  = ggplot2::element_line(color = "#cbcbcb"), 
           panel.grid.major.x  = ggplot2::element_blank(), 
           panel.grid.minor = ggplot2::element_blank()    ) +
           ggplot2::theme(plot.title.position = "plot")
    
   return(p) #  print(p)
    
  } else { 
    cat(paste0("<strong style=\"color:#0072BC;\"> No recorded answers for the question: </strong>",var,"\n\n"))
    return(invisible())}
  # cat("\n\n")
  }
}

```

```{r examples-plot_integer_cross}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_integer_cross(datalist = datalist,
              dico = dico, 
              var = "members.age",
              by_var = "members.sex",
              showcode = TRUE)
```

```{r tests-plot_integer_cros}
# test_that("plot_integer_cros works", {
# 
# })
```


## Plotting Correlation

```{r function-plot_correlation}
#' @title Plotting Correlation
#' 
#' @description  Perform chisquare test and display results if significant
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param var name of the variable to display
#' @param by_var variable to use for cross tabulation
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @param showcode display the code
#' 
#' @importFrom tidyselect all_of
#' @importFrom ggplot2 theme element_line element_blank element_text
#' 
#' @export

# prefixer::import_from(fun = plot_correlation)



plot_correlation <- function(datalist = datalist, 
                             dico = dico,
                             var, 
                             by_var, 
                             datasource = NULL,
                             showcode = FALSE) {
  
  ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[[3]]$form_title ) }
  
  ## verify they are in the same frame
  frame1 <- kobo_frame(datalist = datalist,
                            dico = dico,
                            var = var) 
  frame2 <- kobo_frame(datalist = datalist,
                            dico = dico,
                            var = by_var ) 
       
  if(by_var == var  ) {
       #  cat(paste0("The two variables ",var , " &  ", by_var ,"are identical \n"))
    } else if( !( identical(frame1, frame2)) ) {
       #  cat(paste0("The two variables: ",var , " &  ", by_var ," are not in the same data frame \n"))
    } else  {
         formula <- frame1 |>
                  dplyr::select( dplyr::all_of(var), dplyr::all_of(by_var)) 
         names(formula)[1] <- "target"
         names(formula)[2] <- "tested"
    
         ## Apply the labels  
         formula[,1] <- label_choiceset(dico = dico, x = var)(formula[,1])
         formula[,2] <- label_choiceset(dico = dico, x = by_var)(formula[,2])
    
         ## Check that each class is represented
         check.class <- as.data.frame(table(formula$target,formula$tested))
         n.class <- nrow(check.class)
         n.class.notnull <- nrow(check.class[check.class$Freq > 0, ])
        
        ### Testing necessary condition to perform the correlation test
        if(n.class == 0) {
          cat(paste0("\n There is no data recorded. \n")) 
          } else if ( nlevels(as.factor(as.character(check.class |> dplyr::filter(Freq >= 1) |> dplyr::select(Var1) |> dplyr::pull() )))  < 2) {
            # cat(paste0("There is only one single response option recorded on ",var , " to assess correlation. \n"))
          } else if( nlevels(as.factor(as.character(check.class |> dplyr::filter(Freq >= 1) |> dplyr::select(Var2) |> dplyr::pull()  )))  < 2) {
            # cat(paste0("There is only one single response option recorded on ",by_var , " to assess correlation. \n")) 
          } else if( nlevels(as.factor(as.character(check.class |> dplyr::filter(Freq >= 1) |> dplyr::select(Var1)  |> dplyr::pull() )))  > 7) {
             cat(paste0("\n There are too many response options recorded on ", var , " to assess correlation. You may consider some data cleaning. \n"))
          } else if ( nlevels(as.factor(as.character(check.class |> dplyr::filter(Freq >= 1) |> dplyr::select(Var2) |> dplyr::pull()  )))  > 7) {
            cat(paste0("\n There  are too many response options recorded on ", by_var , " to assess correlation. You may consider some data cleaning. \n")) 
          } else if ( nrow(check.class[check.class$Freq > 0, ]) == 0 ) {
            cat(paste0("\n There is no sufficient cross records  to assess correlation between ",var , " &  ", by_var ,". \n")) 
          } else {
          
          p.value  <- round(stats::chisq.test(formula$target,formula$tested)$p.value,4)   ### Case there not any positive test
          if (p.value > 0.05 ) {
            cat(paste0("\n No significant association found between ",var , " &  ", by_var ," (p.value :",p.value  , ").\n")) } 
          else {
            
            ## Writing code instruction in report
            if( showcode == TRUE) {
              cat(paste0("\n ", label_varname(dico = dico, x = var), "\n", 
           " `plot_correlation(datalist = datalist, dico = dico, \"", var, "\",\"", by_var, "\",datasource=params$datasource)` \n\n "))} else {}
              


                 ## plotting the residuals... 
                 cormat <- as.data.frame(stats::chisq.test(formula$target,
                                                          formula$tested)$residuals) |>
                                dplyr::mutate(direction =   ifelse(Freq < 0, "negative","positive"))|>
                                dplyr::mutate(intense =  abs(Freq))
                 maxcor <- max( abs(cormat$Freq)) + 40
                 mincor <- min( abs(cormat$Freq))
                 
                 p <- ggplot2::ggplot(
                      data = cormat,
                      mapping = ggplot2::aes_string(x = "formula.target",
                                                    y = "formula.tested",
                                                    fill = "direction")) +
                    ggplot2::geom_point(
                     # color = outline.color,
                      alpha=0.7,
                      shape = 21,
                      ggplot2::aes_string(size = "intense")
                    ) +
                
                    ggplot2::geom_text(ggplot2::aes(label = round(Freq),3), 
                              colour = "white", 
                              size = 3)    +
                    #ggplot2::scale_size(range = c(mincor, maxcor)) +
                    ggplot2::scale_size_area(max_size = maxcor) +
                    #ggplot2::guides(size = FALSE)+
                    ggplot2::scale_fill_manual(values=c(positive="steelblue",
                                                        negative="firebrick1")) +
                    ggplot2::labs(x = NULL, y = NULL,
                      title = stringr::str_wrap(paste0("A Significant Statistical Association was identified between: \n ",
                                                       label_varname(dico = dico,  x = var),
                                                       "[row] & ",
                                                       label_varname(dico = dico, x = by_var), "[col]" ), 100),
                      subtitle = stringr::str_wrap(paste0("(p:",p.value,"). Correlogram Interpretation hint: the size of the dots indicates the strenght of association, the color indicates its type (positive/attraction=blue, negative/repulsion= red) "), 110),
                      caption = glue::glue("Source: {datasource}")) +
                    ggplot2::theme_minimal( base_size = 24) +
                    ggplot2::theme( panel.grid.major.x  = ggplot2::element_line(color = "#cbcbcb", size =0.3, linetype = "dotted"), #element_blank(),
                           panel.grid.major.y  = ggplot2::element_line(color = "#cbcbcb", size =0.3, linetype = "dotted"), #element_blank(),
                           panel.grid.minor = ggplot2::element_blank() ,
                           legend.position = 'none',
                           axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust = 1)) +
                    ggplot2::theme(plot.title.position = "plot")
                 
                return(p) #  print(p)
              } 
         }  
    }     
} # end function
  
  
                ## now generating correlation plot 
                # corrplot::corrplot(stats::chisq.test(formula$target,formula$tested)$residuals,
                #                    is.cor = FALSE, # use for general matrix to convert to Sq form
                #                    cl.pos = "n", ## Do not display the color legend
                #                    cl.cex = 0.7, # Size of all label
                #                    tl.cex = 0.7, # Size of axis label
                #                    tl.srt = 45, # string rotation in degrees
                #                    tl.col = "black", # color of text label.
                #                    addCoef.col = "grey", # add coeff in the chart
                #                    number.cex = 3/ncol(stats::chisq.test(formula$target,formula$tested)), # size of coeff
                #                    mar = c(0.5,0.5,4, 0.5), ## margin of plots
                #                    title = stringr::str_wrap(paste0("A Significant Statistical Association (p:",p.value,") was identified between: \n ", 
                #                                   label_varname(dico = dico,  x = var),
                #                                   "[row] & ",
                #                                   label_varname(dico = dico, x = by_var), "[col]" ), 100))       
           

         
        # check.class2 <- check.class |> dplyr::filter(Freq > 1)
        # #|> dplyr::select(Var1)
        # ### Testing number of levels for the 2 variables as 'x' and 'y' must have at least 2 levels
        # if ( ## We need at least 2 levels
        #   ## We need at least 2 levels
        #   ( nlevels(as.factor(as.character(check.class2$Var1))) > 1 ) &
        #   ( nlevels(as.factor(as.character(check.class2$Var2))) > 1 ) &
        #   ## If too many levels - more than 8, the corrogram is not legible...
        #   ( nlevels(as.factor(as.character(check.class2$Var1))) < 8 ) &
        #   ( nlevels(as.factor(as.character(check.class2$Var2))) < 8 )  &
        #   
        #   # ( nlevels(as.factor(as.character(formula$target))) > 1 ) &
        #   # ( nlevels(as.factor(as.character(formula$tested))) > 1 ) &
        #   #    ## If too many levels - more than 8, the corrogram is not legible...
        #   # ( nlevels(as.factor(as.character(formula$target))) < 8 ) &
        #   # ( nlevels(as.factor(as.character(formula$tested))) < 8 )  &
        #   ## May have class with zero value...
        #   # n.class == n.class.notnull
        #   ## Stop if there's no crossing of values because too many NA
        #   n.class.notnull > 2
        # ) { 
          
    
        #     
        #     
        #   } }  
        # else { #cat("There are either too many or not enough level to perform this analysis.. Clean your data.\n")
        #   
        #  cat(paste0("There are either too many or not enough level to assess correlation between ",var , " &  ", by_var ,". You may consider some data cleaning.\n"))
        # } 
   #    }
   #  
   # }

```

```{r examples-plot_correlation}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

plot_correlation(datalist = datalist,
              dico = dico, 
              var = "profile.occupation",
              by_var = "profile.country",
              datasource = NULL)
```

```{r tests-plot_correlation}
# test_that("plot_correlation works", {
# 
# })
```

## Multivariate


## Plotting Likert

```{r function-plot_likert}
#' @title Plotting Likert
#' 
#' @description Detect if we have more than 3 questions with the same response options within the same questions group
#' and represent the result using a standard likert plot - build from  https://github.com/jbryer/likert
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico An object of the "kobodico" class format as defined in kobocruncher
#' @param scopei group in which the likert frame are
#' @param list_namei name of the likert option list
#' @param repeatvari name of the frame within the dataset where to look for the data
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @param showcode display the code
#' 
#' @importFrom stats setNames
#' @importFrom dplyr if_any everything mutate_all funs 
#' @importFrom ggplot2 labs theme_minimal theme margin
#' @importFrom likert likert
#' 
#' @export

# prefixer::import_from(fun = plot_likert)



plot_likert <- function(datalist = datalist,
                        dico = dico,
                        scopei,
                        list_namei,
                        repeatvari,
                        datasource = NULL,
                        showcode = FALSE) {
 
   ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[[3]]$form_title ) }
  require(dplyr)
  require(ggplot2)
  require(likert)
  require(cowplot)
  
   ## Writing code instruction in report
    if( showcode == TRUE) {
      cat(paste0( 
   "`plot_likert(datalist, dico, scopei=\"",scopei, "\", list_namei=\"", list_namei, "\", repeatvari=\"", repeatvari, "\",datasource=params$datasource)` \n\n "))} else {}
             
   labelgroup <- as.data.frame(dico[["variables"]]) |>
            dplyr::filter( name  %in%  c(scopei)) |>
            dplyr::select( label) |>
            dplyr::pull()
          
    nlevel_likert <- as.data.frame(dico[[2]]) |>
            dplyr::filter( list_name ==   list_namei) |>
            dplyr::select( name, label)  |>
            dplyr::distinct() 
    labelrecode <- stats::setNames(as.character(nlevel_likert$label), nlevel_likert$name)
          
    ##  Subsetting data - checking levels - and applying label
    var <- as.data.frame(dico[["variables"]]) |>
                 dplyr::filter( list_name ==  list_namei &
                                scope == scopei  &
                                repeatvar == repeatvari  &
                                appearance != "label" )
    ## Just in case with have the first one being appearance label
    data <-kobo_frame(datalist = datalist, dico = dico, var = var[2, c("name")])
      
    likertframe <- data |>
            ## select only likert variable
            dplyr::select ( tidyselect::any_of( c(var$name)) ) |>
            ## Ensure they all have the same levels as factor
            dplyr::mutate_all(dplyr::funs(factor(., levels =c(nlevel_likert$name ))))  |>
            ## Recode variable with the label
            dplyr::mutate_all(dplyr::funs(dplyr::recode(., !!!labelrecode)))  |>
            #mutate_all(dplyr::recode( !!!labelrecode)) |>
            ## convert to dataframe to ensure likert() works
            as.data.frame() |> 
            ## remove potential var used for appearance 'label'
            dplyr::select_if(~!all(is.na(.))) |>
            ## Remove records where all na
            dplyr::filter(dplyr::if_any(dplyr::everything(), ~ !is.na(.)))
    
    
     
    if( nrow(likertframe) == 0 ) {
      cat("Chart could not be generated")
    } else {
      
     ## Replace with label for the variable 
     for ( j in 1:ncol(likertframe)){
       # j <- 1
       newname <- as.character(var[ var$name == names(likertframe)[j] , c("label")  ])
       names(likertframe)[j] <- newname
     }  
                                        
          # Build likert object
          likertframe.obj <- likert::likert(likertframe)
      
          ## get response rate
          rr <- nrow(likertframe)/ nrow(data)
          
          ## Now generate the plot
        a <- plot(likertframe.obj,
                  #center = 2,
                  wrap= 70) +
          ggplot2::labs(title = labelgroup, 
               caption = glue::glue("Response rate = {scales::label_percent(accuracy = .01)(rr)}, {nrow(likertframe)} on a total of {nrow(data)} records. \n Source: {datasource}"))+
          # guides(fill=guide_legend(title=NULL),    color=guide_legend(nrow=2, byrow=TRUE))  +
          #unhcrthemes::theme_unhcr(grid="X") +
          ggplot2::theme_minimal( base_size = 22) +
          ggplot2::theme( #plot.title=element_text(size=32, face="bold", color="black"), 
                 #plot.subtitle=element_text(size=19, face="italic", color="black"), 
                #text = element_text(size=22, color = "#333333"), 
                #legend.position="right",legend.direction="vertical"), legend.margin=margin()
                legend.position="bottom",
                legend.box="vertical")
        
        ## Extract the legend to put it fully belwo the main chart
        p1_legend <- cowplot::get_legend(a + 
                                  ggplot2::theme(legend.position="bottom", legend.box="vertical", legend.margin=ggplot2::margin(t = 0, unit='cm')) )
        
        #cowplot::ggdraw(p1_legend)
        p <-  cowplot::plot_grid(a +  ggplot2::theme(legend.position = 'none'), 
                                  p1_legend ,
                                  nrow = 2, 
                                  rel_heights = c(1, 0.1))
          
    return(p)      
        
    } 
        
    
}

```

```{r examples-plot_likert}
dicolikert <- kobo_dico( xlsformpath = system.file("form_likert.xlsx", package = "kobocruncher") )
datalistlikert <- kobo_data(datapath = system.file("data_likert.xlsx", package = "kobocruncher") )

plot_likert(datalist = datalistlikert,
            dico = dicolikert,
            datasource = NULL,
            scopei =  "group_ei8jz33",
            repeatvari =   "main",
            ## getting the list_name and corresponding label
            list_namei = "yk0td68" 
          )
```

```{r tests-plot_likert}
# test_that("plot_likert works", {
# 
# })
```


## Plotting clusters

 to do....
 
## Plotting prediction

 to do....

## Plotting scores

 to do....


## Plotting Header variable

```{r function-plot_header}
#' @title Output Header
#' 
#' @description Function to add headings within the crunching report - 
#' Headings are by defaults the groups defined in the xlsform - 
#' but can be replaced within the analysis plan by chapter and subchapter
#' 
#' @param dico path to the xlsform file used to colllect the data
#' @param var name of the variable to display
#' 
#' @importFrom stringr str_count str_c
#' @importFrom dplyr filter pull
#' @importFrom glue glue
#' 
#' @return text formatted as markdown
#' 
#' @export

# prefixer::import_from(fun = plot_header)



plot_header <- function(dico = dico,
                            var) {
  #browser()
  ## getting header levels
  lvl <- stringr::str_count(var, "\\.")
  
  label <- as.data.frame(dico[["variables"]]) |>
    dplyr::filter(name == var) |>
    ## Filter down in case the same var name was given to end group or repat...
    dplyr::filter(!type %in% c("end_group", "end_repeat")) |>
    dplyr::pull(label)
  
  ## In case the header comes from chapter
  lbchap <- as.data.frame(dico[[4]]) |>
    dplyr::filter(name == var) |>
    dplyr::pull(label)
  
  if (identical(label, character(0)))
  {
    title <- glue::glue("{lbchap}")
  } else {
    if (is.na(label)) {
      title <- glue::glue("({var})")
    } else
    {
      title <- label
    }
  }
  
  # Join multiple strings into a single string.
  hdr <- stringr::str_c(strrep("#", 1 + lvl), " ", title, sep = "")
  
  ## Now Printing the headers
  #head <- paste0("\n --- \n \n \n", hdr,"\n\n" )
  #header <- 
  #sprintf("------\n\n\n\n%s\n", hdr)
  #return(header)
  cat("------\n")
  cat("\n\n")
  cat("\n")
  cat(hdr)
  cat("\n\n")
  #return(head)
  #return( as.character(""))
  #return( cat(""))
  #return(hdr)
  #return(invisible(NULL))
}

```

```{r examples-plot_header}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )

plot_header( dico = dico, 
              var = "profile.profile")

# class(plot_header( dico = dico, 
#               var = "profile.profile"))
# 
dput(plot_header( dico = dico,
              var = "profile.profile"))
# 
message(plot_header( dico = dico, 
               var = "profile.profile"))

cat(plot_header( dico = dico, 
               var = "profile.profile"))

print(plot_header( dico = dico, 
              var = "profile.profile"),
      useSource = FALSE)

```

```{r tests-plot_header}
test_that("plot_header works", {
  
  dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
  check <- plot_header( dico = dico,   var = "profile")
  expect_true(inherits(plot_header, "function"))
  # expect_error(plot_header( dico = dico,   var = ""), " ")
  # expect_type(check, "list")
  # expect_identical(    check,  )
})
```

# Report generation

## Crunching Variables based on a plan

```{r function-kobo_cruncher}
#' @title Crunch all variables according to the analysis plan 
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico path to the xlsform file used to collect the data
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsfor
#' @param n if not NULL, lumps all levels except for the n most frequent (or least frequent if n < 0) - cf
#'            forcats::fct_lump_n()
#' @param n_by if not NULL, lumps all levels for the cross tabulation variable except for the n_by most frequent (or least frequent if n < 0) - cf
#'            forcats::fct_lump_n()
#' @export

# prefixer::import_from(fun = kobo_cruncher)


 
kobo_cruncher <- function(datalist = datalist, 
                          datasource = NULL,
                          dico = dico,
                          n = 5,
                          n_by = 5) {
  
  ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[[3]]$form_title ) }
  
  questions <- as.data.frame(dico[[4]])
  disaggregation <-  c(as.data.frame(dico[["variables"]]) |> 
                        dplyr::filter( !(is.na(disaggregation))) |>
                        dplyr::pull(name) )
  
  correlate <-   c(as.data.frame(dico[["variables"]]) |> 
                   dplyr::filter( !(is.na(correlate))) |>
                   dplyr::pull(name))
  
  
  ## If disaggregation not included in the function argument then use what's set up in the analysis plan
  if (  length(disaggregation) == 1 ) { 
    if (  disaggregation == "" ) { 
      disaggregation <- as.data.frame(dico[["variables"]]) |> 
        dplyr::filter( !(is.na(disaggregation))) |>
        dplyr::pull(name) } }
  

  # If correlate not included in the function argument then use what's set up in the analysis plan
  if (length(correlate) ==1) {
    if (correlate == "") { correlate <- as.data.frame(dico[["variables"]])|> 
      dplyr::filter( !(is.na(correlate))) |>
      dplyr::pull(name) }}
  
  ## Looping around the questions as set up in the report plan ###
  for ( i in 1:nrow(questions)) {
      type <-  questions[ i, c("type")]
      name <- questions[ i, c("name")]
      
      if (type == "begin_group") { cat(plot_header(dico = dico,
                                               var = name)) }
      
      ## Univariate analysis ######
      if (type == "select_one") print(plot_select_one(datalist = datalist, 
                                                dico = dico,
                                                var = name,  
                                                datasource = datasource,
                                                n = n,
                                                showcode = TRUE))
      
      if (type == "select_multiple") print(plot_select_multiple(datalist = datalist,
                                                          dico = dico, 
                                                          var = name,  
                                                          datasource = datasource,
                                                          n = n,
                                                          showcode = TRUE))
      
      if (type %in% c("numeric", "integer", "range")) print(plot_integer(datalist = datalist, 
                                                          dico = dico,
                                                          var = name,  
                                                          datasource = datasource,
                                                          showcode = TRUE))
      
      if (type == "text") print(plot_text(datalist = datalist, 
                                    dico = dico, 
                                    var = name,  
                                    datasource = datasource,
                                    showcode = TRUE))
      
    
       ## Bivariate analysis #####
      if (type == "select_one" &  length(disaggregation)>=1 ) {
        for (disag in disaggregation  ){
          if(disag  != "")
            print(plot_select_one_cross(datalist = datalist, 
                                  dico = dico,
                                  var = name, 
                                  by_var = disag, 
                                  datasource = datasource,
                                  n = n,
                                  n_by = n_by,
                                  showcode = TRUE)) }
      }
      if (type == "select_multiple" &  length(disaggregation)>=1 ) {
        for (disag in disaggregation  ){
          if(disag  != "")
            print(plot_select_multiple_cross(datalist = datalist, 
                                  dico = dico,
                                  var = name, 
                                  by_var = disag,
                                  datasource = datasource,
                                  n = n,
                                  n_by = n_by,
                                  showcode = TRUE)) }
      }
      if (type %in% c("numeric", "integer") &  length(disaggregation)>=1 ) {
        for (disag in disaggregation  ){
          
          if(disag  != "")
            print(plot_integer_cross(datalist = datalist, 
                               dico = dico,
                               var = name, 
                               by_var = disag, 
                               datasource = datasource,
                               showcode = TRUE)) }
      }
    
    ## Statistical Association  #
      if (type == "select_one" &  length(correlate)>=1 ) {
        for (correl in correlate  ){
          
          if(correl  != "")
            print(plot_correlation(datalist = datalist, 
                             dico = dico,
                             var = name, 
                             by_var = correl,
                             datasource = datasource,
                             showcode = TRUE)) }
      }
  
  }
}




```

```{r examples-kobo_cruncher}
dico <- kobo_dico( xlsformpath = system.file("sample_xlsform.xlsx", package = "kobocruncher") )
datalist <- kobo_data(datapath = system.file("data.xlsx", package = "kobocruncher") )

kobo_cruncher(datalist = datalist,
              dico = dico,
              datasource = "a great survey!")


```

```{r tests-kobo_cruncher}

# Unit Test: 

# context("Testing kobo_cruncher() function")
# 
# test_that("kobo_cruncher() produces the correct output", {
#   expect_equal(class(kobo_cruncher()), "list")
#   expect_equal(length(kobo_cruncher()), 5)
# })

# test_that("survey_label works", {
# 
# })
```

## Crunching Likert componnents

```{r function-kobo_likert}
#' @title Crunch all likert variables according to the analysis plan 
#' 
#' @param datalist An object of the "datalist" class as defined in kobocruncher 
#' @param dico path to the xlsform file used to colllect the data
#' @param datasource name of the data source to display, if set to NULL - then pulls the form_title within the settings of the xlsform 
#' @export

# prefixer::import_from(fun = kobo_likert)


 
kobo_likert <- function(datalist = datalist, 
                          datasource = NULL,
                          dico = dico) {
  
  ## Get default data source name 
  if( is.null(datasource)) {datasource <- as.character(  dico[[3]]$form_title ) }
  
  require(dplyr)
  ## Check the frequency of list_name within each group,
  ## Filter the combination of list and group where we have more than 3 occurrences
  # not taking in account when the appearance is not "label"
  grouplikert <- as.data.frame(dico[["variables"]]) |>
    dplyr::filter( type ==  "select_one") |>
    dplyr::filter( appearance !=  "label") |>
    
    ## Just include the var that are also in the plan
    dplyr::filter(name %in% dico[["plan"]]$name ) |>
    
    dplyr::group_by( scope, list_name, repeatvar) |>
    dplyr::summarise( cnt= dplyr::n() )|>
    dplyr::filter( cnt >= 2)
  
  if(nrow(grouplikert)  == 0) {
    cat("No potential likert in the form")
    } else {
    cat(paste0(nrow(grouplikert), " groups of likert questions in the form"))
       for (i in 1:nrow(grouplikert)  ) {
          ## getting the group and corresponding label
          scopei <-   as.character(grouplikert[i, c("scope")])
          repeatvari <-   as.character(grouplikert[i, c("repeatvar")])
          ## geting the list_name and corresponding label
          list_namei <- as.character( grouplikert[i, c("list_name")])
          
          print(plot_likert(datalist = datalist, 
                      datasource = datasource,
                      dico = dico,
                      scopei =  scopei,
                      repeatvari =  repeatvari,
                      list_namei = list_namei,
                      showcode = TRUE)) 
  
        }
    }
}



```

```{r examples-kobo_likert}
dicolikert <- kobo_dico( xlsformpath = system.file("form_likert.xlsx", package = "kobocruncher") )
datalistlikert <- kobo_data(datapath = system.file("data_likert.xlsx", package = "kobocruncher") )

kobo_likert(datalist = datalistlikert,
              dico = dicolikert,
              datasource = "a great survey!")


```

```{r tests-kobo_likert}

# ## Unit Test
# context("kobo_likert()")
# 
# test_that("kobo_likert() runs without errors", {
#   expect_error(kobo_likert())
# })
# 
# test_that("kobo_likert() returns the correct number of groups", {
#   expect_equal(nrow(grouplikert), kobo_likert())
# })
# 
# test_that("kobo_likert() plots the correct likert questions", {
#   expect_equal(plot_likert(datalist = datalist, 
#                       datasource = datasource,
#                       dico = dico,
#                       scopei =  scopei,
#                       repeatvari =  repeatvari,
#                       list_namei = list_namei,
#                       showcode = TRUE),
#               kobo_likert())
# })

# test_that("survey_label works", {
# 
# })
```
 
## Archive files in RIDL

    
```{r function-kobo_ridl}
#' Archive all crunching files in RIDL
#'
#' RIDL is UNHCR instance of a CKAN server and is accessible for UNHCR staff at
#' https://ridl.unhcr.org . It is designed to keep track and
#' document dataset within an organisation.
#'
#' You conveniently archive there your generated report and save
#' the work you did on a notebook: As you have been working on the data, you want
#' to keep track of it and save your work in a place where it can be useful for
#' other people and avaialble for peer review and quality assessment.
#'
#'
#' The function saves within the  the RIDL container you used to get the data
#'  from the following resources:
#'   * the generated report
#'   * the analysis plan, aka the extended  xlsform used to record relabeling, clean, indicator creation, question grouping, exploration settings
#'   * the source notebook
#'
#' The function behavior is the following -
#'   1. Get metadata from the RIDL dataset
#'   2. check if the resources to be uploaded is already shared based on the name
#'   3. if already there update, if not create
#'
#'  The function relies on   # install.packages("pak")
#'                           # pak::pkg_install("edouard-legoupil/riddle")
#'
#' @param ridl ridl container where the resources should be added
#' @param datafolder folder where the data used by the notebook are stored
#' @param form names of the file with the analysis plan
#' @param namethisfile all files are archived based on the name of notebook you created.
#'     The function automatically get the name of the notebook where it is run from,
#'     using
#'      basename(rstudioapi::getSourceEditorContext()$path )
#'
#' @param visibility can be  "public" per default or set to private for obscure reasons..
#' @param stage  allow to document your analysis stage
#'    * exploration_initial if your crunching is the very initial basic cleaning, relabeling of your data
#'    * exploration_advance if your crunching
#'    * interpretation_prez
#'    * dissemination_story
#'
#' @importFrom riddle dataset_show resource_metadata resource_create resource_update
#'
#' @return nothing all analysis files are added as a resources
#'
#' @export

# prefixer::import_from(fun = kobo_ridl)



kobo_ridl <- function(ridl,
                      datafolder,
                      form,
                      namethisfile,
                      visibility =  "public",
                      stage = "explo_initial"){
  
  
  
  ### name of the file...
  # retrieving path from getSourceEditorContext()
  # using $ operator
  ## Enter below the name you used to save this file - without extension
  #    namethisfile <- rstudioapi::getSourceEditorContext()$path
  
  ### Remove file name extension
  name <-  substr(namethisfile,1, nchar(namethisfile) -4)
  #
  #    ## Now just the name of the file
  #    name1 <-   basename(rstudioapi::getSourceEditorContext()$path )
  #    ## Remove file name extension
  #   name <-  substr(name1,1, nchar(name1) -4)
  #
  #     ### Time to archive your work once done!!
  
  time <- format(Sys.Date(),  '%d%b%y')
  
  # ### Uncomment and Run this only once you have knitted your file in order to quickly upload this to RIDL -
  # install.packages("pak")
  # pak::pkg_install("edouard-legoupil/riddle")
  
  # First let's get the dataset metadata
  p <- riddle::dataset_show(ridl)
  list_of_resources <- p[["resources"]][[1]]
  #names(list_of_resources)
  #   "description"
  # "file_type"        questionnaire microdata report script
  # "format"
  # "id"    "name"
  # "type"                "url"
  # "visibility"
  # "identifiability"
  # "version"
  # "script_dependencies"
  # "script_instructions"
  #  "script_software"
  # "source_code_repo"
  
  ### 1.  Publish the analysis plan #######
  nameanalysisplan = paste0("analysisPlan_", stage,"_", name,"_", ridl,"_", time )
  ### Check if the name is already in the resources
  if(nameanalysisplan %in% list_of_resources$name) {
    ## get the resource id
    resourceid <- list_of_resources |>
      dplyr::filter ( name == nameanalysisplan) |>
      dplyr::pull(id)
    ## get the new resource version
    curversion <- list_of_resources |>
      dplyr::filter ( name == nameanalysisplan) |>
      dplyr::pull(version)
    
    ##  Build resource metadata
    metadataanalysisplan <- riddle::resource_metadata(
      type = "script",
      url = paste0("analysisPlan_", stage,"_", name, "_", ridl,"_", time, ".xlsx"),
      name = nameanalysisplan,
      description = paste0("Analysis Plan to use with: ", stage,"_", name,"_", ridl,"_", time,
                           ". Built using kobocruncher "),
      format = ".xlsx",
      version = (curversion + 1),
      visibility =  visibility,
    # file_type = "other",
      file_type = "script",
      script_dependencies= "kobocruncher",
      script_instructions= "This excel file contains all specific metedata
             to relabel the original data, to group variable for automatic data
              exploration and to create calculated variables ",
      script_software= "R",
      source_code_repo= "https://edouard-legoupil.github.io/kobocruncher",
      ## Revise here based on the name from your crunching report
      upload =  httr::upload_file(here::here(datafolder, form))
    )
    riddle::resource_update(id = resourceid,
                            res_metadata = metadataanalysisplan)
  } else {
    
    metadataanalysisplan <- riddle::resource_metadata(
      type = "script",
      url = paste0("analysisPlan_", stage,"_", name, "_", ridl,"_", time, ".xlsx"),
      name = nameanalysisplan,
      description = paste0("Analysis Plan to use with: ", stage,"_", name,"_", ridl,"_", time,
                           ". Built using kobocruncher "),
      format = ".xlsx",
      visibility =  visibility,
   #  file_type = "other",
      file_type = "script",
      script_dependencies= "kobocruncher",
      script_instructions= "This excel file contains all specific metedata
             to relabel the original data, to group variable for automatic data
              exploration and to create calculated variables ",
      script_software= "R",
      source_code_repo= "https://edouard-legoupil.github.io/kobocruncher",
      ## Revise here based on the name from your crunching report
      upload =  httr::upload_file(here::here(datafolder, form))
    )
    riddle::resource_create(package_id = p$id,
                            res_metadata = metadataanalysisplan)
  }
  
  
  ### 2.  Now publish the current notebook #######
  namenotebook = paste0("notebook_", stage, name, ridl, time)
  ### Check if the name is already in the resources
  if(namenotebook %in% list_of_resources$name) {
    ## get the resource id
    resourceid <- list_of_resources |>
      dplyr::filter ( name == nameanalysisplan) |>
      dplyr::pull(id)
    ## get the new resource version
    curversion <- list_of_resources |>
      dplyr::filter ( name == nameanalysisplan) |>
      dplyr::pull(version)
    metadataanalysisscript <- riddle::resource_metadata(type = "script",
                                                        url = paste0("notebook_", stage, name, ridl, time, ".Rmd"),
                                                        name = namenotebook,
                                                        description = paste0("Notebook for ",
                                                                             stage,"_", name,"_", ridl,"_", time,
                                                                             " report. Built using kobocruncher "),
                                                        format = "rmd",
                                                        version = (curversion + 1),
                                                        visibility =  visibility,
                                           #             file_type = "other",
                                           file_type = "script",
                                                        script_dependencies= "kobocruncher",
                                                        script_instructions= "Use the data and the analysis
                                           plan documented in the report parameters and
                                           available within this RIDL dataset ",
                                                        script_software= "R",
                                                        source_code_repo= "https://edouard-legoupil.github.io/kobocruncher",
                                           # Revise here based on the name from your crunching report
                                                        upload = httr::upload_file(here::here(namethisfile))
    )
    
    riddle::resource_update(id = resourceid,
                            res_metadata =  metadataanalysisscript)
  } else {
    metadataanalysisscript <- riddle::resource_metadata(type = "script",
                                                        url = paste0("notebook_", stage, name, ridl, time, ".Rmd"),
                                                        name = namenotebook,
                                                        description = paste0("Notebook for ",
                                                                             stage,"_", name,"_", ridl,"_", time,
                                                                             " report. Built using kobocruncher "),
                                                        format = "Rmd",
                                                        visibility =  visibility,
                                            #            file_type = "other",
                                           file_type = "script",
                                                        script_dependencies= "kobocruncher",
                                                        script_instructions= "Use the data and the analysis
                                           plan documented in the report parameters and
                                           available within this RIDL dataset ",
                                                        script_software= "R",
                                                        source_code_repo= "https://edouard-legoupil.github.io/kobocruncher",
                                                        ## Revise here based on the name from your crunching report
                                                        upload = httr::upload_file(here::here(namethisfile))
    )
    riddle::resource_create(package_id = p$id,
                            res_metadata = metadataanalysisscript)
  }
  
  ## 3.  and now the generated report - that should be hopefully already generated ####
  namereport = paste0("output_", stage, name, ridl, time)
  if(stage == "interpretation_prez") { filext <- ".pptx"} else if(stage == "technical_report") { filext <- ".docx" } else { filext <- ".html" }
  ### Check if the name is already in the resources
  if(namereport %in% list_of_resources$name) {
    ## get the resource id
    resourceid <- list_of_resources |>
      dplyr::filter ( name == namereport) |>
      dplyr::pull(id)
    ## get the new resource version
    curversion <- list_of_resources |>
      dplyr::filter ( name == namereport) |>
      dplyr::pull(version)
    metadatareport <- riddle::resource_metadata(type = "attachment",
                                                url = paste0(stage, name, ridl, time,".html"),
                                                name = paste0(stage, name, ridl, time),
                                                description = paste0("Generated Report: ",
                                                                     stage,", ", name, " built on ", time,
                                                                     " using kobocruncher "),
                                                format = filext,
                                                version = (curversion + 1),
                                                visibility =  visibility,
                                                file_type = "report",
                                                ## Revise here based on the name from your crunching report
                                                upload = httr::upload_file(here::here(paste0(name,filext)))
    )
    
    riddle::resource_update(id = resourceid,
                            res_metadata = metadatareport)
  } else {
    metadatareport <- riddle::resource_metadata(type = "attachment",
                                                url = paste0(stage, name, ridl, time,".html"),
                                                name = paste0(stage, name, ridl, time),
                                                description = paste0("Generated Report: ",
                                                                     stage,", ", name, " built on ", time,
                                                                     " using kobocruncher "),
                                                format = filext,
                                                visibility =  visibility,
                                                file_type = "report",
                                                ## Revise here based on the name from your crunching report
                                                upload = httr::upload_file(here::here(paste0(name,filext)))
    )
    riddle::resource_create(package_id = p$id,
                            res_metadata = metadatareport)
  }
  
  
  ## Once all of it done, let's the user know about it...
  return( cat(paste0("Congrat! The Notebook", name, " together with linked output and analysis plan have been published on RIDL")))
}




```
  
```{r example-kobo_ridl}

### Example used for each template 
## Time to archive your work once done!!
# namethisfile = basename(rstudioapi::getSourceEditorContext()$path )  
# if( params$publish == "yes"){
#   kobo_ridl(ridl = params$ridl,
#             datafolder = params$datafolder,
#             form = params$form,
#             namethisfile =  namethisfile ,
#             visibility =  params$visibility,
#             stage = params$stage) }

 
```
  
```{r tests-kobo_ridl}


# Unit test for kobo_ridl() using testthat
# 
# context("kobo_ridl()")
# 
# # Create mock objects to use in the test
# ridl <- "testRidl"
# datafolder <- "data"
# form <- "form.xlsx"
# namethisfile <- "testFile"
# visibility <- "public"
# stage <- "explo_initial"
# 
# # Create test for function
# test_that("kobo_ridl() creates the right resources", {
#   expect_true(kobo_ridl(ridl, datafolder, form, namethisfile, visibility, stage))
# })

# test_that("kobo_ridl works", {   expect_true(inherits(kobo_ridl, "function")) })
```
  


## Report Template A for Automatic Data Exploration


    
```{r function-template_1_exploration}

#' Initial Template for Automatic Data Exploration
#' 
#' This template is designed for initial data crunching - The first RMD template gives an output in HTML for easy navigation - the left menu provides smooth transition.
#' It includes a function to automatically run throughout all the survey content. During this stage, data cleaning and new variable creation can be performed through iterations
#' This report also includes each plot syntax so that they can be easily pasted for the second report 
#' 
# usethis::use_rmarkdown_template(
#   template_name = "template_1_exploration",
#   template_dir = NULL,
#   template_description = "Automatic Data Exploration - html",
#   template_create_dir = TRUE
# ) 
#' 
#' @param   datafolder  "data-raw" This is the default folder where to put you data in
#' @param   ridl "ridlproject" Name of the ridl project where you data is documented and archived
#' @param   data "data.xlsx" Name of the data file
#' @param   form "form.xlsx" Name of the xlsform - 
#' @param   datasource "Study name reference" ## String used in caption for all your charts
#' @param   publish "no" Put to "yes" in order to add your report, source and analysis plan as ressource within the same ridl c
#' @param   republish "no"
#' @param   visibility "public"
#' @param   stage "exploration_initial" You may change this to exploration_advanced if you configuring many 
#' @param   language "" Check what you have in your xlsform - ::english (en) -or ::french (fr) or ::spanish (es)
#' @param folder folder within your project where to put the generated report. 
#' Folder will be created if it does not exist
#' 
#' @importFrom unhcrdown html_page pptx_slides paged_simple
#' @importFrom rmarkdown render
#' @importFrom here here
#' 
#' @return nothing the file for the report is generated
#' 
#' @export 

# prefixer::import_from(fun = template_1_exploration)


#'
template_1_exploration <- function(datafolder= "data-raw",
                                   ridl =  "ridlproject",
                                    data = "data.xlsx" ,
                                    form =  "form.xlsx",
                                    datasource = "Study name reference",
                                    publish =  "no", 
                                    republish = "no",
                                    visibility = "public",
                                    stage = "exploration_initial",
                                   language = "",
                                   folder = "Report"){
  
  
  ## Create the outfolder if it does not exist
  output_dir <- paste0(getwd(),"/",folder)
  if (!dir.exists(output_dir)) {dir.create(output_dir)}
  
  
  rmarkdown::render(
    system.file("rmarkdown/templates/template_A_exploration/skeleton/skeleton.Rmd", package = "kobocruncher"),
    output_file = here::here(folder, paste0('StatFactsheetCtr-', country_asylum_iso3c, '-', year, '.html') ),
    params = list(datafolder= datafolder,
                  ridl =  ridl,
                  data = data  ,
                  form =   form,
                  datasource = datasource,
                  publish =  publish, 
                  republish = publish,
                  visibility= visibility,
                  stage = stage,
                  language =language )  )
}
  
```
  
```{r example-template_1_exploration}
# template_1_exploration(datafolder= "data-raw",
#                                    ridl =  "ridlproject",
#                                     data = "data.xlsx" ,
#                                     form =  "form.xlsx",
#                                     datasource = "Study name reference",
#                                     publish =  "no", 
#                                     republish = "no",
#                                     visibility = "public",
#                                     stage = "exploration_initial",
#                                    language = "",
#                                    folder = "Report")
```
  
```{r tests-template_1_exploration}
# test_that("template_1_exploration works", { expect_true(inherits(template_1_exploration, "function")) })
```
  

```{r template_1_exploration}



```

## Report Template B for Joint Data Interpretation Session

The second template is used following the systematic data exploration. 
It will generate a PowerPoint presentation

See a more detailed presentation of that step here: https://www.youtube.com/watch?v=0jE-Y7g88K4&feature=youtu.be&t=2305 

```{r template_2_interpretation}
#' Second Template to prepare a presentation for the Joint Data Interpretation Session
#' 
# usethis::use_rmarkdown_template(
#   template_name = "template_2_interpretation",
#   template_dir = NULL,
#   template_description = "Joint Data Interpretation",
#   template_create_dir = TRUE
# )

```

## Report Template C for Note taking

The third template can be used  in a similar way than the presentation template. It will generate a  word document in order to take note.

An automatic table of content is generated but might required to be refreshed after the word document creation


```{r template_3_note}
#' Report Template 3 for Dissemination and Data Story Telling Template
#' The last template can be used to take note of the data interpretation session. 
#' It will generate a PDF or an paginated HTML page
# usethis::use_rmarkdown_template(
#   template_name = "template_C_notes",
#   template_dir = NULL,
#   template_description = "Note taking",
#   template_create_dir = TRUE
# )



```

## Report Template D for Dissemination and Data Story Telling Template

The last template can be used to build the final report. It includes some instructions and guidance on how to organize the content to increase your audience

It will generate a PDF or an paginated HTML page

```{r template_4_dissemination}
#' Report Template 3 for Dissemination and Data Story Telling Template
#' The last template can be used to take note of the data interpretation session. 
#' It will generate a PDF or an paginated HTML page
# usethis::use_rmarkdown_template(
#   template_name = "template_D_dissemination",
#   template_dir = NULL,
#   template_description = "Data brief and Story Telling",
#   template_create_dir = TRUE
# )



```

## Shiny App

```{r function-app_kobocruncher}
#' @title Shiny App - app_kobocruncher
#' 
#' @description  starts the graphical user interface developed with \emph{shiny}.
#' 
#' @param maxRequestSize (numeric) number defining the maximum allowed filesize (in megabytes)
#' for uploaded files, defaults to 50MB
#' @param debug logical if \code{TRUE}, set shiny-debugging options
#' @return starts the interactive graphical user interface 
#' @param theme select stylesheet for the interface. Supported choices are
#' \itemize{
#' \item 'yeti'
#' \item 'flatly'
#' \item 'journal'
#' \item 'IHSN'
#' }
#' @param ... arguments (e.g \code{host}) that are passed through \code{\link[shiny]{runApp}} when
#' starting the shiny application
#' @param shiny.server Setting this parameter to \code{TRUE} will return the app in the form of an 
#' object rather than invoking it. This is useful for deploying \code{app_kobocruncher} via \code{shiny-server}.
#' 
#' 
#' @importFrom shiny runApp shinyOptions
#' @export
#'


app_kobocruncher <- function(maxRequestSize=50, 
                        debug=FALSE, 
                        theme="IHSN", 
                        ..., 
                        shiny.server = FALSE) {
  if(!shiny.server)
    shiny::runApp(app_kobocruncher(maxRequestSize, debug, ggplot2::theme, ..., shiny.server = TRUE))
  
  if (!is.numeric(maxRequestSize)) {
    stop("argument 'maxRequestSize' must be numeric!\n")
  }
  
  if (maxRequestSize < 1) {
    maxRequestSize <- 10
  }
  
  appDir <- system.file("shiny", "kobocruncherApp", package="kobocruncher")
  
  if (appDir == "") {
    stop("Could not find example directory. Try re-installing `kobocruncher`.", call.=FALSE)
  }
  
  options(shiny.maxRequestSize=ceiling(maxRequestSize)*1024^2)
  options(shiny.fullstacktrace=debug)
  options(shiny.trace=debug)

  #.GlobalEnv$.startdir <- getwd()
  shiny::shinyOptions(.startdir = getwd())
  shiny::shinyOptions(.appDir = appDir)

  if (! theme %in% c("yeti","journal","flatly", "IHSN")) {
    stop("Invalid value for argument 'theme'\n")
  }

  if (theme=="yeti") {
    shiny::shinyOptions(.guitheme = "bootswatch_yeti.css")
    shiny::shinyOptions(.guijsfile = NULL)
  }

  if (theme=="journal") {
    shiny::shinyOptions(.guitheme = "bootswatch_journal.css")
    shiny::shinyOptions(.guijsfile = NULL)
  }
  if (theme=="flatly") {
    shiny::shinyOptions(.guitheme = "bootswatch_flatly.css")
    shiny::shinyOptions(.guijsfile = NULL)
  }

  if (theme=="IHSN") {
    shiny::shinyOptions(.guitheme = "ihsn-root.css")
    shiny::shinyOptions(.guijsfile = "js/ihsn-style.js")
  }
  
  source_from_appdir <- function(filename){
    source(file.path(appDir, filename), local = parent.frame(), chdir = TRUE)$value
  }
  
  shiny::shinyOptions(kobocruncherAppInvoked = TRUE)
  source_from_appdir("global.R")
  shiny::shinyOptions(kobocruncherAppInvoked = NULL)

  shiny::shinyApp(
    ui = source_from_appdir("ui.R"),
    server = source_from_appdir("server.R"),
    options = list(launch.browser=TRUE, ...)
  )
}

```

```{r examples-app_kobocruncher}

# app_kobocruncher(theme="flatly")
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_dev.Rmd", vignette_name = "Crunching Function for XlsForm")
```

